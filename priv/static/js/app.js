/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.js":
/*!**********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var Phoenix = (() => {\n  var __defProp = Object.defineProperty;\n\n  var __markAsModule = target => __defProp(target, \"__esModule\", {\n    value: true\n  });\n\n  var __export = (target, all) => {\n    __markAsModule(target);\n\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  }; // js/phoenix/index.js\n\n\n  var phoenix_exports = {};\n\n  __export(phoenix_exports, {\n    Channel: () => Channel,\n    LongPoll: () => LongPoll,\n    Presence: () => Presence,\n    Serializer: () => serializer_default,\n    Socket: () => Socket\n  }); // js/phoenix/utils.js\n\n\n  var closure = value => {\n    if (typeof value === \"function\") {\n      return value;\n    } else {\n      let closure2 = function () {\n        return value;\n      };\n\n      return closure2;\n    }\n  }; // js/phoenix/constants.js\n\n\n  var globalSelf = typeof self !== \"undefined\" ? self : null;\n  var phxWindow = typeof window !== \"undefined\" ? window : null;\n  var global = globalSelf || phxWindow || void 0;\n  var DEFAULT_VSN = \"2.0.0\";\n  var SOCKET_STATES = {\n    connecting: 0,\n    open: 1,\n    closing: 2,\n    closed: 3\n  };\n  var DEFAULT_TIMEOUT = 1e4;\n  var WS_CLOSE_NORMAL = 1e3;\n  var CHANNEL_STATES = {\n    closed: \"closed\",\n    errored: \"errored\",\n    joined: \"joined\",\n    joining: \"joining\",\n    leaving: \"leaving\"\n  };\n  var CHANNEL_EVENTS = {\n    close: \"phx_close\",\n    error: \"phx_error\",\n    join: \"phx_join\",\n    reply: \"phx_reply\",\n    leave: \"phx_leave\"\n  };\n  var TRANSPORTS = {\n    longpoll: \"longpoll\",\n    websocket: \"websocket\"\n  };\n  var XHR_STATES = {\n    complete: 4\n  }; // js/phoenix/push.js\n\n  var Push = class {\n    constructor(channel, event, payload, timeout) {\n      this.channel = channel;\n      this.event = event;\n\n      this.payload = payload || function () {\n        return {};\n      };\n\n      this.receivedResp = null;\n      this.timeout = timeout;\n      this.timeoutTimer = null;\n      this.recHooks = [];\n      this.sent = false;\n    }\n\n    resend(timeout) {\n      this.timeout = timeout;\n      this.reset();\n      this.send();\n    }\n\n    send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload(),\n        ref: this.ref,\n        join_ref: this.channel.joinRef()\n      });\n    }\n\n    receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({\n        status,\n        callback\n      });\n      return this;\n    }\n\n    reset() {\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n    }\n\n    matchReceive({\n      status,\n      response,\n      _ref\n    }) {\n      this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n    }\n\n    cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n\n      this.channel.off(this.refEvent);\n    }\n\n    cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n\n    startTimeout() {\n      if (this.timeoutTimer) {\n        this.cancelTimeout();\n      }\n\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n      this.channel.on(this.refEvent, payload => {\n        this.cancelRefEvent();\n        this.cancelTimeout();\n        this.receivedResp = payload;\n        this.matchReceive(payload);\n      });\n      this.timeoutTimer = setTimeout(() => {\n        this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n\n    hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n\n    trigger(status, response) {\n      this.channel.trigger(this.refEvent, {\n        status,\n        response\n      });\n    }\n\n  }; // js/phoenix/timer.js\n\n  var Timer = class {\n    constructor(callback, timerCalc) {\n      this.callback = callback;\n      this.timerCalc = timerCalc;\n      this.timer = null;\n      this.tries = 0;\n    }\n\n    reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    scheduleTimeout() {\n      clearTimeout(this.timer);\n      this.timer = setTimeout(() => {\n        this.tries = this.tries + 1;\n        this.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n\n  }; // js/phoenix/channel.js\n\n  var Channel = class {\n    constructor(topic, params, socket) {\n      this.state = CHANNEL_STATES.closed;\n      this.topic = topic;\n      this.params = closure(params || {});\n      this.socket = socket;\n      this.bindings = [];\n      this.bindingRef = 0;\n      this.timeout = this.socket.timeout;\n      this.joinedOnce = false;\n      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n      this.pushBuffer = [];\n      this.stateChangeRefs = [];\n      this.rejoinTimer = new Timer(() => {\n        if (this.socket.isConnected()) {\n          this.rejoin();\n        }\n      }, this.socket.rejoinAfterMs);\n      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n      this.stateChangeRefs.push(this.socket.onOpen(() => {\n        this.rejoinTimer.reset();\n\n        if (this.isErrored()) {\n          this.rejoin();\n        }\n      }));\n      this.joinPush.receive(\"ok\", () => {\n        this.state = CHANNEL_STATES.joined;\n        this.rejoinTimer.reset();\n        this.pushBuffer.forEach(pushEvent => pushEvent.send());\n        this.pushBuffer = [];\n      });\n      this.joinPush.receive(\"error\", () => {\n        this.state = CHANNEL_STATES.errored;\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.onClose(() => {\n        this.rejoinTimer.reset();\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n        this.state = CHANNEL_STATES.closed;\n        this.socket.remove(this);\n      });\n      this.onError(reason => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason);\n\n        if (this.isJoining()) {\n          this.joinPush.reset();\n        }\n\n        this.state = CHANNEL_STATES.errored;\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.joinPush.receive(\"timeout\", () => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n        leavePush.send();\n        this.state = CHANNEL_STATES.errored;\n        this.joinPush.reset();\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n        this.trigger(this.replyEventName(ref), payload);\n      });\n    }\n\n    join(timeout = this.timeout) {\n      if (this.joinedOnce) {\n        throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n      } else {\n        this.timeout = timeout;\n        this.joinedOnce = true;\n        this.rejoin();\n        return this.joinPush;\n      }\n    }\n\n    onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n\n    onError(callback) {\n      return this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n    }\n\n    on(event, callback) {\n      let ref = this.bindingRef++;\n      this.bindings.push({\n        event,\n        ref,\n        callback\n      });\n      return ref;\n    }\n\n    off(event, ref) {\n      this.bindings = this.bindings.filter(bind => {\n        return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n      });\n    }\n\n    canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n\n    push(event, payload, timeout = this.timeout) {\n      payload = payload || {};\n\n      if (!this.joinedOnce) {\n        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n      }\n\n      let pushEvent = new Push(this, event, function () {\n        return payload;\n      }, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    leave(timeout = this.timeout) {\n      this.rejoinTimer.reset();\n      this.joinPush.cancelTimeout();\n      this.state = CHANNEL_STATES.leaving;\n\n      let onClose = () => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`);\n        this.trigger(CHANNEL_EVENTS.close, \"leave\");\n      };\n\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n      leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n\n    onMessage(_event, payload, _ref) {\n      return payload;\n    }\n\n    isMember(topic, event, payload, joinRef) {\n      if (this.topic !== topic) {\n        return false;\n      }\n\n      if (joinRef && joinRef !== this.joinRef()) {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {\n          topic,\n          event,\n          payload,\n          joinRef\n        });\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    joinRef() {\n      return this.joinPush.ref;\n    }\n\n    rejoin(timeout = this.timeout) {\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n\n    trigger(event, payload, ref, joinRef) {\n      let handledPayload = this.onMessage(event, payload, ref, joinRef);\n\n      if (payload && !handledPayload) {\n        throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n      }\n\n      let eventBindings = this.bindings.filter(bind => bind.event === event);\n\n      for (let i = 0; i < eventBindings.length; i++) {\n        let bind = eventBindings[i];\n        bind.callback(handledPayload, ref, joinRef || this.joinRef());\n      }\n    }\n\n    replyEventName(ref) {\n      return `chan_reply_${ref}`;\n    }\n\n    isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n\n    isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n\n    isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n\n    isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n\n    isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n\n  }; // js/phoenix/ajax.js\n\n  var Ajax = class {\n    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (global.XDomainRequest) {\n        let req = new global.XDomainRequest();\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        let req = new global.XMLHttpRequest();\n        this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n\n    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      req.timeout = timeout;\n      req.open(method, endPoint);\n\n      req.onload = () => {\n        let response = this.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.onprogress = () => {};\n\n      req.send(body);\n    }\n\n    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      req.open(method, endPoint, true);\n      req.timeout = timeout;\n      req.setRequestHeader(\"Content-Type\", accept);\n\n      req.onerror = () => {\n        callback && callback(null);\n      };\n\n      req.onreadystatechange = () => {\n        if (req.readyState === XHR_STATES.complete && callback) {\n          let response = this.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n    }\n\n    static parseJSON(resp) {\n      if (!resp || resp === \"\") {\n        return null;\n      }\n\n      try {\n        return JSON.parse(resp);\n      } catch (e) {\n        console && console.log(\"failed to parse JSON response\", resp);\n        return null;\n      }\n    }\n\n    static serialize(obj, parentKey) {\n      let queryStr = [];\n\n      for (var key in obj) {\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n          continue;\n        }\n\n        let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n        let paramVal = obj[key];\n\n        if (typeof paramVal === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n\n      return queryStr.join(\"&\");\n    }\n\n    static appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return `${url}${prefix}${this.serialize(params)}`;\n    }\n\n  }; // js/phoenix/longpoll.js\n\n  var LongPoll = class {\n    constructor(endPoint) {\n      this.endPoint = null;\n      this.token = null;\n      this.skipHeartbeat = true;\n\n      this.onopen = function () {};\n\n      this.onerror = function () {};\n\n      this.onmessage = function () {};\n\n      this.onclose = function () {};\n\n      this.pollEndpoint = this.normalizeEndpoint(endPoint);\n      this.readyState = SOCKET_STATES.connecting;\n      this.poll();\n    }\n\n    normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n\n    endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, {\n        token: this.token\n      });\n    }\n\n    closeAndRetry() {\n      this.close();\n      this.readyState = SOCKET_STATES.connecting;\n    }\n\n    ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry();\n    }\n\n    poll() {\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n        return;\n      }\n\n      Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), resp => {\n        if (resp) {\n          var {\n            status,\n            token,\n            messages\n          } = resp;\n          this.token = token;\n        } else {\n          status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(msg => {\n              setTimeout(() => {\n                this.onmessage({\n                  data: msg\n                });\n              }, 0);\n            });\n            this.poll();\n            break;\n\n          case 204:\n            this.poll();\n            break;\n\n          case 410:\n            this.readyState = SOCKET_STATES.open;\n            this.onopen();\n            this.poll();\n            break;\n\n          case 403:\n            this.onerror();\n            this.close();\n            break;\n\n          case 0:\n          case 500:\n            this.onerror();\n            this.closeAndRetry();\n            break;\n\n          default:\n            throw new Error(`unhandled poll status ${status}`);\n        }\n      });\n    }\n\n    send(body) {\n      Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), resp => {\n        if (!resp || resp.status !== 200) {\n          this.onerror(resp && resp.status);\n          this.closeAndRetry();\n        }\n      });\n    }\n\n    close(_code, _reason) {\n      this.readyState = SOCKET_STATES.closed;\n      this.onclose();\n    }\n\n  }; // js/phoenix/presence.js\n\n  var Presence = class {\n    constructor(channel, opts = {}) {\n      let events = opts.events || {\n        state: \"presence_state\",\n        diff: \"presence_diff\"\n      };\n      this.state = {};\n      this.pendingDiffs = [];\n      this.channel = channel;\n      this.joinRef = null;\n      this.caller = {\n        onJoin: function () {},\n        onLeave: function () {},\n        onSync: function () {}\n      };\n      this.channel.on(events.state, newState => {\n        let {\n          onJoin,\n          onLeave,\n          onSync\n        } = this.caller;\n        this.joinRef = this.channel.joinRef();\n        this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n        this.pendingDiffs.forEach(diff => {\n          this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        });\n        this.pendingDiffs = [];\n        onSync();\n      });\n      this.channel.on(events.diff, diff => {\n        let {\n          onJoin,\n          onLeave,\n          onSync\n        } = this.caller;\n\n        if (this.inPendingSyncState()) {\n          this.pendingDiffs.push(diff);\n        } else {\n          this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n          onSync();\n        }\n      });\n    }\n\n    onJoin(callback) {\n      this.caller.onJoin = callback;\n    }\n\n    onLeave(callback) {\n      this.caller.onLeave = callback;\n    }\n\n    onSync(callback) {\n      this.caller.onSync = callback;\n    }\n\n    list(by) {\n      return Presence.list(this.state, by);\n    }\n\n    inPendingSyncState() {\n      return !this.joinRef || this.joinRef !== this.channel.joinRef();\n    }\n\n    static syncState(currentState, newState, onJoin, onLeave) {\n      let state = this.clone(currentState);\n      let joins = {};\n      let leaves = {};\n      this.map(state, (key, presence) => {\n        if (!newState[key]) {\n          leaves[key] = presence;\n        }\n      });\n      this.map(newState, (key, newPresence) => {\n        let currentPresence = state[key];\n\n        if (currentPresence) {\n          let newRefs = newPresence.metas.map(m => m.phx_ref);\n          let curRefs = currentPresence.metas.map(m => m.phx_ref);\n          let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0);\n          let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0);\n\n          if (joinedMetas.length > 0) {\n            joins[key] = newPresence;\n            joins[key].metas = joinedMetas;\n          }\n\n          if (leftMetas.length > 0) {\n            leaves[key] = this.clone(currentPresence);\n            leaves[key].metas = leftMetas;\n          }\n        } else {\n          joins[key] = newPresence;\n        }\n      });\n      return this.syncDiff(state, {\n        joins,\n        leaves\n      }, onJoin, onLeave);\n    }\n\n    static syncDiff(state, diff, onJoin, onLeave) {\n      let {\n        joins,\n        leaves\n      } = this.clone(diff);\n\n      if (!onJoin) {\n        onJoin = function () {};\n      }\n\n      if (!onLeave) {\n        onLeave = function () {};\n      }\n\n      this.map(joins, (key, newPresence) => {\n        let currentPresence = state[key];\n        state[key] = this.clone(newPresence);\n\n        if (currentPresence) {\n          let joinedRefs = state[key].metas.map(m => m.phx_ref);\n          let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0);\n          state[key].metas.unshift(...curMetas);\n        }\n\n        onJoin(key, currentPresence, newPresence);\n      });\n      this.map(leaves, (key, leftPresence) => {\n        let currentPresence = state[key];\n\n        if (!currentPresence) {\n          return;\n        }\n\n        let refsToRemove = leftPresence.metas.map(m => m.phx_ref);\n        currentPresence.metas = currentPresence.metas.filter(p => {\n          return refsToRemove.indexOf(p.phx_ref) < 0;\n        });\n        onLeave(key, currentPresence, leftPresence);\n\n        if (currentPresence.metas.length === 0) {\n          delete state[key];\n        }\n      });\n      return state;\n    }\n\n    static list(presences, chooser) {\n      if (!chooser) {\n        chooser = function (key, pres) {\n          return pres;\n        };\n      }\n\n      return this.map(presences, (key, presence) => {\n        return chooser(key, presence);\n      });\n    }\n\n    static map(obj, func) {\n      return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n    }\n\n    static clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n\n  }; // js/phoenix/serializer.js\n\n  var serializer_default = {\n    HEADER_LENGTH: 1,\n    META_LENGTH: 4,\n    KINDS: {\n      push: 0,\n      reply: 1,\n      broadcast: 2\n    },\n\n    encode(msg, callback) {\n      if (msg.payload.constructor === ArrayBuffer) {\n        return callback(this.binaryEncode(msg));\n      } else {\n        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n        return callback(JSON.stringify(payload));\n      }\n    },\n\n    decode(rawPayload, callback) {\n      if (rawPayload.constructor === ArrayBuffer) {\n        return callback(this.binaryDecode(rawPayload));\n      } else {\n        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n        return callback({\n          join_ref,\n          ref,\n          topic,\n          event,\n          payload\n        });\n      }\n    },\n\n    binaryEncode(message) {\n      let {\n        join_ref,\n        ref,\n        event,\n        topic,\n        payload\n      } = message;\n      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n      let view = new DataView(header);\n      let offset = 0;\n      view.setUint8(offset++, this.KINDS.push);\n      view.setUint8(offset++, join_ref.length);\n      view.setUint8(offset++, ref.length);\n      view.setUint8(offset++, topic.length);\n      view.setUint8(offset++, event.length);\n      Array.from(join_ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(event, char => view.setUint8(offset++, char.charCodeAt(0)));\n      var combined = new Uint8Array(header.byteLength + payload.byteLength);\n      combined.set(new Uint8Array(header), 0);\n      combined.set(new Uint8Array(payload), header.byteLength);\n      return combined.buffer;\n    },\n\n    binaryDecode(buffer) {\n      let view = new DataView(buffer);\n      let kind = view.getUint8(0);\n      let decoder = new TextDecoder();\n\n      switch (kind) {\n        case this.KINDS.push:\n          return this.decodePush(buffer, view, decoder);\n\n        case this.KINDS.reply:\n          return this.decodeReply(buffer, view, decoder);\n\n        case this.KINDS.broadcast:\n          return this.decodeBroadcast(buffer, view, decoder);\n      }\n    },\n\n    decodePush(buffer, view, decoder) {\n      let joinRefSize = view.getUint8(1);\n      let topicSize = view.getUint8(2);\n      let eventSize = view.getUint8(3);\n      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n      offset = offset + joinRefSize;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      return {\n        join_ref: joinRef,\n        ref: null,\n        topic,\n        event,\n        payload: data\n      };\n    },\n\n    decodeReply(buffer, view, decoder) {\n      let joinRefSize = view.getUint8(1);\n      let refSize = view.getUint8(2);\n      let topicSize = view.getUint8(3);\n      let eventSize = view.getUint8(4);\n      let offset = this.HEADER_LENGTH + this.META_LENGTH;\n      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n      offset = offset + joinRefSize;\n      let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n      offset = offset + refSize;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      let payload = {\n        status: event,\n        response: data\n      };\n      return {\n        join_ref: joinRef,\n        ref,\n        topic,\n        event: CHANNEL_EVENTS.reply,\n        payload\n      };\n    },\n\n    decodeBroadcast(buffer, view, decoder) {\n      let topicSize = view.getUint8(1);\n      let eventSize = view.getUint8(2);\n      let offset = this.HEADER_LENGTH + 2;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      return {\n        join_ref: null,\n        ref: null,\n        topic,\n        event,\n        payload: data\n      };\n    }\n\n  }; // js/phoenix/socket.js\n\n  var Socket = class {\n    constructor(endPoint, opts = {}) {\n      this.stateChangeCallbacks = {\n        open: [],\n        close: [],\n        error: [],\n        message: []\n      };\n      this.channels = [];\n      this.sendBuffer = [];\n      this.ref = 0;\n      this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n      this.transport = opts.transport || global.WebSocket || LongPoll;\n      this.establishedConnections = 0;\n      this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n      this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n      this.closeWasClean = false;\n      this.binaryType = opts.binaryType || \"arraybuffer\";\n      this.connectClock = 1;\n\n      if (this.transport !== LongPoll) {\n        this.encode = opts.encode || this.defaultEncoder;\n        this.decode = opts.decode || this.defaultDecoder;\n      } else {\n        this.encode = this.defaultEncoder;\n        this.decode = this.defaultDecoder;\n      }\n\n      let awaitingConnectionOnPageShow = null;\n\n      if (phxWindow && phxWindow.addEventListener) {\n        phxWindow.addEventListener(\"pagehide\", _e => {\n          if (this.conn) {\n            this.disconnect();\n            awaitingConnectionOnPageShow = this.connectClock;\n          }\n        });\n        phxWindow.addEventListener(\"pageshow\", _e => {\n          if (awaitingConnectionOnPageShow === this.connectClock) {\n            awaitingConnectionOnPageShow = null;\n            this.connect();\n          }\n        });\n      }\n\n      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n\n      this.rejoinAfterMs = tries => {\n        if (opts.rejoinAfterMs) {\n          return opts.rejoinAfterMs(tries);\n        } else {\n          return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n        }\n      };\n\n      this.reconnectAfterMs = tries => {\n        if (opts.reconnectAfterMs) {\n          return opts.reconnectAfterMs(tries);\n        } else {\n          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n        }\n      };\n\n      this.logger = opts.logger || null;\n      this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n      this.params = closure(opts.params || {});\n      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n      this.vsn = opts.vsn || DEFAULT_VSN;\n      this.heartbeatTimer = null;\n      this.pendingHeartbeatRef = null;\n      this.reconnectTimer = new Timer(() => {\n        this.teardown(() => this.connect());\n      }, this.reconnectAfterMs);\n    }\n\n    replaceTransport(newTransport) {\n      this.disconnect();\n      this.transport = newTransport;\n    }\n\n    protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n\n    endPointURL() {\n      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), {\n        vsn: this.vsn\n      });\n\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n\n      if (uri.charAt(1) === \"/\") {\n        return `${this.protocol()}:${uri}`;\n      }\n\n      return `${this.protocol()}://${location.host}${uri}`;\n    }\n\n    disconnect(callback, code, reason) {\n      this.connectClock++;\n      this.closeWasClean = true;\n      this.reconnectTimer.reset();\n      this.teardown(callback, code, reason);\n    }\n\n    connect(params) {\n      this.connectClock++;\n\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = closure(params);\n      }\n\n      if (this.conn) {\n        return;\n      }\n\n      this.closeWasClean = false;\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.binaryType = this.binaryType;\n      this.conn.timeout = this.longpollerTimeout;\n\n      this.conn.onopen = () => this.onConnOpen();\n\n      this.conn.onerror = error => this.onConnError(error);\n\n      this.conn.onmessage = event => this.onConnMessage(event);\n\n      this.conn.onclose = event => this.onConnClose(event);\n    }\n\n    log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    hasLogger() {\n      return this.logger !== null;\n    }\n\n    onOpen(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.open.push([ref, callback]);\n      return ref;\n    }\n\n    onClose(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.close.push([ref, callback]);\n      return ref;\n    }\n\n    onError(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.error.push([ref, callback]);\n      return ref;\n    }\n\n    onMessage(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.message.push([ref, callback]);\n      return ref;\n    }\n\n    onConnOpen() {\n      if (this.hasLogger()) this.log(\"transport\", `connected to ${this.endPointURL()}`);\n      this.closeWasClean = false;\n      this.establishedConnections++;\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.resetHeartbeat();\n      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n    }\n\n    heartbeatTimeout() {\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n\n        if (this.hasLogger()) {\n          this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n        }\n\n        this.abnormalClose(\"heartbeat timeout\");\n      }\n    }\n\n    resetHeartbeat() {\n      if (this.conn && this.conn.skipHeartbeat) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = null;\n      clearTimeout(this.heartbeatTimer);\n      setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n\n    teardown(callback, code, reason) {\n      if (!this.conn) {\n        return callback && callback();\n      }\n\n      this.waitForBufferDone(() => {\n        if (this.conn) {\n          if (code) {\n            this.conn.close(code, reason || \"\");\n          } else {\n            this.conn.close();\n          }\n        }\n\n        this.waitForSocketClosed(() => {\n          if (this.conn) {\n            this.conn.onclose = function () {};\n\n            this.conn = null;\n          }\n\n          callback && callback();\n        });\n      });\n    }\n\n    waitForBufferDone(callback, tries = 1) {\n      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n        callback();\n        return;\n      }\n\n      setTimeout(() => {\n        this.waitForBufferDone(callback, tries + 1);\n      }, 150 * tries);\n    }\n\n    waitForSocketClosed(callback, tries = 1) {\n      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n        callback();\n        return;\n      }\n\n      setTimeout(() => {\n        this.waitForSocketClosed(callback, tries + 1);\n      }, 150 * tries);\n    }\n\n    onConnClose(event) {\n      if (this.hasLogger()) this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearTimeout(this.heartbeatTimer);\n\n      if (!this.closeWasClean) {\n        this.reconnectTimer.scheduleTimeout();\n      }\n\n      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n    }\n\n    onConnError(error) {\n      if (this.hasLogger()) this.log(\"transport\", error);\n      let transportBefore = this.transport;\n      let establishedBefore = this.establishedConnections;\n      this.stateChangeCallbacks.error.forEach(([, callback]) => {\n        callback(error, transportBefore, establishedBefore);\n      });\n\n      if (transportBefore === this.transport || establishedBefore > 0) {\n        this.triggerChanError();\n      }\n    }\n\n    triggerChanError() {\n      this.channels.forEach(channel => {\n        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n          channel.trigger(CHANNEL_EVENTS.error);\n        }\n      });\n    }\n\n    connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n\n        case SOCKET_STATES.open:\n          return \"open\";\n\n        case SOCKET_STATES.closing:\n          return \"closing\";\n\n        default:\n          return \"closed\";\n      }\n    }\n\n    isConnected() {\n      return this.connectionState() === \"open\";\n    }\n\n    remove(channel) {\n      this.off(channel.stateChangeRefs);\n      this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef());\n    }\n\n    off(refs) {\n      for (let key in this.stateChangeCallbacks) {\n        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n          return refs.indexOf(ref) === -1;\n        });\n      }\n    }\n\n    channel(topic, chanParams = {}) {\n      let chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n\n    push(data) {\n      if (this.hasLogger()) {\n        let {\n          topic,\n          event,\n          payload,\n          ref,\n          join_ref\n        } = data;\n        this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n      }\n\n      if (this.isConnected()) {\n        this.encode(data, result => this.conn.send(result));\n      } else {\n        this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)));\n      }\n    }\n\n    makeRef() {\n      let newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n\n    sendHeartbeat() {\n      if (this.pendingHeartbeatRef && !this.isConnected()) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: \"phoenix\",\n        event: \"heartbeat\",\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n    }\n\n    abnormalClose(reason) {\n      this.closeWasClean = false;\n\n      if (this.isConnected()) {\n        this.conn.close(WS_CLOSE_NORMAL, reason);\n      }\n    }\n\n    flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(callback => callback());\n        this.sendBuffer = [];\n      }\n    }\n\n    onConnMessage(rawMessage) {\n      this.decode(rawMessage.data, msg => {\n        let {\n          topic,\n          event,\n          payload,\n          ref,\n          join_ref\n        } = msg;\n\n        if (ref && ref === this.pendingHeartbeatRef) {\n          clearTimeout(this.heartbeatTimer);\n          this.pendingHeartbeatRef = null;\n          setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n        }\n\n        if (this.hasLogger()) this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n\n        for (let i = 0; i < this.channels.length; i++) {\n          const channel = this.channels[i];\n\n          if (!channel.isMember(topic, event, payload, join_ref)) {\n            continue;\n          }\n\n          channel.trigger(event, payload, ref, join_ref);\n        }\n\n        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n          let [, callback] = this.stateChangeCallbacks.message[i];\n          callback(msg);\n        }\n      });\n    }\n\n    leaveOpenTopic(topic) {\n      let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()));\n\n      if (dupChannel) {\n        if (this.hasLogger()) this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n        dupChannel.leave();\n      }\n    }\n\n  };\n  return phoenix_exports;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanM/MzFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGhvZW5peCA9ICgoKSA9PiB7XG4gIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICAgIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2luZGV4LmpzXG4gIHZhciBwaG9lbml4X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQocGhvZW5peF9leHBvcnRzLCB7XG4gICAgQ2hhbm5lbDogKCkgPT4gQ2hhbm5lbCxcbiAgICBMb25nUG9sbDogKCkgPT4gTG9uZ1BvbGwsXG4gICAgUHJlc2VuY2U6ICgpID0+IFByZXNlbmNlLFxuICAgIFNlcmlhbGl6ZXI6ICgpID0+IHNlcmlhbGl6ZXJfZGVmYXVsdCxcbiAgICBTb2NrZXQ6ICgpID0+IFNvY2tldFxuICB9KTtcblxuICAvLyBqcy9waG9lbml4L3V0aWxzLmpzXG4gIHZhciBjbG9zdXJlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbG9zdXJlMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNsb3N1cmUyO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2NvbnN0YW50cy5qc1xuICB2YXIgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGw7XG4gIHZhciBwaHhXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbDtcbiAgdmFyIGdsb2JhbCA9IGdsb2JhbFNlbGYgfHwgcGh4V2luZG93IHx8IHZvaWQgMDtcbiAgdmFyIERFRkFVTFRfVlNOID0gXCIyLjAuMFwiO1xuICB2YXIgU09DS0VUX1NUQVRFUyA9IHsgY29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzIH07XG4gIHZhciBERUZBVUxUX1RJTUVPVVQgPSAxZTQ7XG4gIHZhciBXU19DTE9TRV9OT1JNQUwgPSAxZTM7XG4gIHZhciBDSEFOTkVMX1NUQVRFUyA9IHtcbiAgICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gICAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gICAgam9pbmVkOiBcImpvaW5lZFwiLFxuICAgIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICAgIGxlYXZpbmc6IFwibGVhdmluZ1wiXG4gIH07XG4gIHZhciBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgICBlcnJvcjogXCJwaHhfZXJyb3JcIixcbiAgICBqb2luOiBcInBoeF9qb2luXCIsXG4gICAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gICAgbGVhdmU6IFwicGh4X2xlYXZlXCJcbiAgfTtcbiAgdmFyIFRSQU5TUE9SVFMgPSB7XG4gICAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbiAgfTtcbiAgdmFyIFhIUl9TVEFURVMgPSB7XG4gICAgY29tcGxldGU6IDRcbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3B1c2guanNcbiAgdmFyIFB1c2ggPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpIHtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMucmVjSG9va3MgPSBbXTtcbiAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBzZW5kKCkge1xuICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICB0aGlzLnNlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCgpLFxuICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoc3RhdHVzKSkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgdGhpcy5yZWYgPSBudWxsO1xuICAgICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGw7XG4gICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSwgX3JlZiB9KSB7XG4gICAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cykuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpO1xuICAgIH1cbiAgICBjYW5jZWxSZWZFdmVudCgpIHtcbiAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5uZWwub2ZmKHRoaXMucmVmRXZlbnQpO1xuICAgIH1cbiAgICBjYW5jZWxUaW1lb3V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgaWYgKHRoaXMudGltZW91dFRpbWVyKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKTtcbiAgICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKHRoaXMucmVmRXZlbnQsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZDtcbiAgICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pO1xuICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgaGFzUmVjZWl2ZWQoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxuICAgIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgdGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCwgeyBzdGF0dXMsIHJlc3BvbnNlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3RpbWVyLmpzXG4gIHZhciBUaW1lciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgdGltZXJDYWxjKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgfVxuICAgIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2NoYW5uZWwuanNcbiAgdmFyIENoYW5uZWwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSk7XG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuYmluZGluZ1JlZiA9IDA7XG4gICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0O1xuICAgICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dCk7XG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW107XG4gICAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlam9pbigpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5pc0Vycm9yZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVqb2luKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50KSA9PiBwdXNoRXZlbnQuc2VuZCgpKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uQ2xvc2UoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSlcbiAgICAgICAgICB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkVycm9yKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pO1xuICAgICAgICBpZiAodGhpcy5pc0pvaW5pbmcoKSkge1xuICAgICAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpO1xuICAgICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGlmICh0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWpvaW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2g7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIChyZWFzb24pID0+IGNhbGxiYWNrKHJlYXNvbikpO1xuICAgIH1cbiAgICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCByZWYgPSB0aGlzLmJpbmRpbmdSZWYrKztcbiAgICAgIHRoaXMuYmluZGluZ3MucHVzaCh7IGV2ZW50LCByZWYsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgb2ZmKGV2ZW50LCByZWYpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FuUHVzaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKTtcbiAgICB9XG4gICAgcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge307XG4gICAgICBpZiAoIXRoaXMuam9pbmVkT25jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKTtcbiAgICAgIH1cbiAgICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBpZiAodGhpcy5jYW5QdXNoKCkpIHtcbiAgICAgICAgcHVzaEV2ZW50LnNlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdXNoRXZlbnQ7XG4gICAgfVxuICAgIGxlYXZlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgIHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGxlYXZlICR7dGhpcy50b3BpY31gKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBcImxlYXZlXCIpO1xuICAgICAgfTtcbiAgICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRpbWVvdXQpO1xuICAgICAgbGVhdmVQdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBvbkNsb3NlKCkpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSk7XG4gICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgaWYgKCF0aGlzLmNhblB1c2goKSkge1xuICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcihcIm9rXCIsIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWF2ZVB1c2g7XG4gICAgfVxuICAgIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpIHtcbiAgICAgIGlmICh0aGlzLnRvcGljICE9PSB0b3BpYykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBqb2luUmVmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmO1xuICAgIH1cbiAgICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgaWYgKHRoaXMuaXNMZWF2aW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYyk7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICB0cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpIHtcbiAgICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMub25NZXNzYWdlKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpO1xuICAgICAgaWYgKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IGJpbmQuZXZlbnQgPT09IGV2ZW50KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV07XG4gICAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWA7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICB9XG4gICAgaXNFcnJvcmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgfVxuICAgIGlzSm9pbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICB9XG4gICAgaXNKb2luaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgfVxuICAgIGlzTGVhdmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2FqYXguanNcbiAgdmFyIEFqYXggPSBjbGFzcyB7XG4gICAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHRoaXMueGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHRoaXMueGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB4ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spIHtcbiAgICAgIHJlcS50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQpO1xuICAgICAgcmVxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgIH07XG4gICAgICBpZiAob250aW1lb3V0KSB7XG4gICAgICAgIHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQ7XG4gICAgICB9XG4gICAgICByZXEub25wcm9ncmVzcyA9ICgpID0+IHtcbiAgICAgIH07XG4gICAgICByZXEuc2VuZChib2R5KTtcbiAgICB9XG4gICAgc3RhdGljIHhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spIHtcbiAgICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQsIHRydWUpO1xuICAgICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgYWNjZXB0KTtcbiAgICAgIHJlcS5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKTtcbiAgICAgIH07XG4gICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob250aW1lb3V0KSB7XG4gICAgICAgIHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQ7XG4gICAgICB9XG4gICAgICByZXEuc2VuZChib2R5KTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlSlNPTihyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AgfHwgcmVzcCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3ApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIiwgcmVzcCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgcGFyZW50S2V5KSB7XG4gICAgICBsZXQgcXVlcnlTdHIgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtS2V5ID0gcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fVske2tleX1dYCA6IGtleTtcbiAgICAgICAgbGV0IHBhcmFtVmFsID0gb2JqW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1WYWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBxdWVyeVN0ci5wdXNoKHRoaXMuc2VyaWFsaXplKHBhcmFtVmFsLCBwYXJhbUtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXJ5U3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtS2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtVmFsKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBxdWVyeVN0ci5qb2luKFwiJlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGFwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcykge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgICB9XG4gICAgICBsZXQgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/IFwiJlwiIDogXCI/XCI7XG4gICAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7dGhpcy5zZXJpYWxpemUocGFyYW1zKX1gO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2xvbmdwb2xsLmpzXG4gIHZhciBMb25nUG9sbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihlbmRQb2ludCkge1xuICAgICAgdGhpcy5lbmRQb2ludCA9IG51bGw7XG4gICAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICAgIHRoaXMuc2tpcEhlYXJ0YmVhdCA9IHRydWU7XG4gICAgICB0aGlzLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIHRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5wb2xsRW5kcG9pbnQgPSB0aGlzLm5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KTtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZztcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgICBub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCkge1xuICAgICAgcmV0dXJuIGVuZFBvaW50LnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIikucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChcIiguKikvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKTtcbiAgICB9XG4gICAgZW5kcG9pbnRVUkwoKSB7XG4gICAgICByZXR1cm4gQWpheC5hcHBlbmRQYXJhbXModGhpcy5wb2xsRW5kcG9pbnQsIHsgdG9rZW46IHRoaXMudG9rZW4gfSk7XG4gICAgfVxuICAgIGNsb3NlQW5kUmV0cnkoKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc7XG4gICAgfVxuICAgIG9udGltZW91dCgpIHtcbiAgICAgIHRoaXMub25lcnJvcihcInRpbWVvdXRcIik7XG4gICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoKTtcbiAgICB9XG4gICAgcG9sbCgpIHtcbiAgICAgIGlmICghKHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBBamF4LnJlcXVlc3QoXCJHRVRcIiwgdGhpcy5lbmRwb2ludFVSTCgpLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgbnVsbCwgdGhpcy50aW1lb3V0LCB0aGlzLm9udGltZW91dC5iaW5kKHRoaXMpLCAocmVzcCkgPT4ge1xuICAgICAgICBpZiAocmVzcCkge1xuICAgICAgICAgIHZhciB7IHN0YXR1cywgdG9rZW4sIG1lc3NhZ2VzIH0gPSByZXNwO1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtc2cpID0+IHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbm1lc3NhZ2UoeyBkYXRhOiBtc2cgfSk7XG4gICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQxMDpcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMub3BlbjtcbiAgICAgICAgICAgIHRoaXMub25vcGVuKCk7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgdGhpcy5vbmVycm9yKCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHBvbGwgc3RhdHVzICR7c3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2VuZChib2R5KSB7XG4gICAgICBBamF4LnJlcXVlc3QoXCJQT1NUXCIsIHRoaXMuZW5kcG9pbnRVUkwoKSwgXCJhcHBsaWNhdGlvbi9qc29uXCIsIGJvZHksIHRoaXMudGltZW91dCwgdGhpcy5vbmVycm9yLmJpbmQodGhpcywgXCJ0aW1lb3V0XCIpLCAocmVzcCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3AgfHwgcmVzcC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIHRoaXMub25lcnJvcihyZXNwICYmIHJlc3Auc3RhdHVzKTtcbiAgICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKF9jb2RlLCBfcmVhc29uKSB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNsb3NlZDtcbiAgICAgIHRoaXMub25jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIHZhciBQcmVzZW5jZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pIHtcbiAgICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7IHN0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwiIH07XG4gICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgICB0aGlzLmNhbGxlciA9IHtcbiAgICAgICAgb25Kb2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfSxcbiAgICAgICAgb25MZWF2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLnN0YXRlLCAobmV3U3RhdGUpID0+IHtcbiAgICAgICAgbGV0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKChkaWZmKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICBvblN5bmMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCAoZGlmZikgPT4ge1xuICAgICAgICBsZXQgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgIGlmICh0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIG9uSm9pbihjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb25TeW5jKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgbGlzdChieSkge1xuICAgICAgcmV0dXJuIFByZXNlbmNlLmxpc3QodGhpcy5zdGF0ZSwgYnkpO1xuICAgIH1cbiAgICBpblBlbmRpbmdTeW5jU3RhdGUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCk7XG4gICAgfVxuICAgIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSk7XG4gICAgICBsZXQgam9pbnMgPSB7fTtcbiAgICAgIGxldCBsZWF2ZXMgPSB7fTtcbiAgICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgICBpZiAoIW5ld1N0YXRlW2tleV0pIHtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKChtKSA9PiBtLnBoeF9yZWYpO1xuICAgICAgICAgIGxldCBjdXJSZWZzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IG5ld1JlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgICAgaWYgKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZTtcbiAgICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlZnRNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKTtcbiAgICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgbGV0IHsgam9pbnMsIGxlYXZlcyB9ID0gdGhpcy5jbG9uZShkaWZmKTtcbiAgICAgIGlmICghb25Kb2luKSB7XG4gICAgICAgIG9uSm9pbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICAgIG9uTGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpO1xuICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlKSB7XG4gICAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKChtKSA9PiBqb2luZWRSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApO1xuICAgICAgICAgIHN0YXRlW2tleV0ubWV0YXMudW5zaGlmdCguLi5jdXJNZXRhcyk7XG4gICAgICAgIH1cbiAgICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldO1xuICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcigocCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSk7XG4gICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2UubWV0YXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpIHtcbiAgICAgIGlmICghY2hvb3Nlcikge1xuICAgICAgICBjaG9vc2VyID0gZnVuY3Rpb24oa2V5LCBwcmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXM7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKChrZXkpID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY2xvbmUob2JqKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peC9zZXJpYWxpemVyLmpzXG4gIHZhciBzZXJpYWxpemVyX2RlZmF1bHQgPSB7XG4gICAgSEVBREVSX0xFTkdUSDogMSxcbiAgICBNRVRBX0xFTkdUSDogNCxcbiAgICBLSU5EUzogeyBwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyIH0sXG4gICAgZW5jb2RlKG1zZywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh7IGpvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJpbmFyeUVuY29kZShtZXNzYWdlKSB7XG4gICAgICBsZXQgeyBqb2luX3JlZiwgcmVmLCBldmVudCwgdG9waWMsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoO1xuICAgICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKTtcbiAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcik7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBqb2luX3JlZi5sZW5ndGgpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aCk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0b3BpYy5sZW5ndGgpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgZXZlbnQubGVuZ3RoKTtcbiAgICAgIEFycmF5LmZyb20oam9pbl9yZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgIEFycmF5LmZyb20ocmVmLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICBBcnJheS5mcm9tKHRvcGljLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICBBcnJheS5mcm9tKGV2ZW50LCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIHBheWxvYWQuYnl0ZUxlbmd0aCk7XG4gICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoaGVhZGVyKSwgMCk7XG4gICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiBjb21iaW5lZC5idWZmZXI7XG4gICAgfSxcbiAgICBiaW5hcnlEZWNvZGUoYnVmZmVyKSB7XG4gICAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2Rlcik7XG4gICAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgICBjYXNlIHRoaXMuS0lORFMuYnJvYWRjYXN0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSk7XG4gICAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxO1xuICAgICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemU7XG4gICAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICByZXR1cm4geyBqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYywgZXZlbnQsIHBheWxvYWQ6IGRhdGEgfTtcbiAgICB9LFxuICAgIGRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgIGxldCByZWZTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoNCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSDtcbiAgICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplO1xuICAgICAgbGV0IHJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHJlZlNpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHJlZlNpemU7XG4gICAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBsZXQgcGF5bG9hZCA9IHsgc3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGEgfTtcbiAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBqb2luUmVmLCByZWYsIHRvcGljLCBldmVudDogQ0hBTk5FTF9FVkVOVFMucmVwbHksIHBheWxvYWQgfTtcbiAgICB9LFxuICAgIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMik7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljLCBldmVudCwgcGF5bG9hZDogZGF0YSB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3NvY2tldC5qc1xuICB2YXIgU29ja2V0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pIHtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7IG9wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW10gfTtcbiAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgdGhpcy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVDtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0cy50cmFuc3BvcnQgfHwgZ2xvYmFsLldlYlNvY2tldCB8fCBMb25nUG9sbDtcbiAgICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDA7XG4gICAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gc2VyaWFsaXplcl9kZWZhdWx0LmVuY29kZS5iaW5kKHNlcmlhbGl6ZXJfZGVmYXVsdCk7XG4gICAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gc2VyaWFsaXplcl9kZWZhdWx0LmRlY29kZS5iaW5kKHNlcmlhbGl6ZXJfZGVmYXVsdCk7XG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuYmluYXJ5VHlwZSA9IG9wdHMuYmluYXJ5VHlwZSB8fCBcImFycmF5YnVmZmVyXCI7XG4gICAgICB0aGlzLmNvbm5lY3RDbG9jayA9IDE7XG4gICAgICBpZiAodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlcjtcbiAgICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbmNvZGUgPSB0aGlzLmRlZmF1bHRFbmNvZGVyO1xuICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVmYXVsdERlY29kZXI7XG4gICAgICB9XG4gICAgICBsZXQgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGw7XG4gICAgICBpZiAocGh4V2luZG93ICYmIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgKF9lKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCAoX2UpID0+IHtcbiAgICAgICAgICBpZiAoYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9PT0gdGhpcy5jb25uZWN0Q2xvY2spIHtcbiAgICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzZTQ7XG4gICAgICB0aGlzLnJlam9pbkFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdHMucmVqb2luQWZ0ZXJNcykge1xuICAgICAgICAgIHJldHVybiBvcHRzLnJlam9pbkFmdGVyTXModHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMWUzLCAyZTMsIDVlM11bdHJpZXMgLSAxXSB8fCAxZTQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdHMucmVjb25uZWN0QWZ0ZXJNcykge1xuICAgICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMWUzLCAyZTNdW3RyaWVzIC0gMV0gfHwgNWUzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5sb2dnZXIgPSBvcHRzLmxvZ2dlciB8fCBudWxsO1xuICAgICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMmU0O1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KTtcbiAgICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtUUkFOU1BPUlRTLndlYnNvY2tldH1gO1xuICAgICAgdGhpcy52c24gPSBvcHRzLnZzbiB8fCBERUZBVUxUX1ZTTjtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKTtcbiAgICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgfVxuICAgIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0O1xuICAgIH1cbiAgICBwcm90b2NvbCgpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5wcm90b2NvbC5tYXRjaCgvXmh0dHBzLykgPyBcIndzc1wiIDogXCJ3c1wiO1xuICAgIH1cbiAgICBlbmRQb2ludFVSTCgpIHtcbiAgICAgIGxldCB1cmkgPSBBamF4LmFwcGVuZFBhcmFtcyhBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwgeyB2c246IHRoaXMudnNuIH0pO1xuICAgICAgaWYgKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgICB9XG4gICAgICBpZiAodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucHJvdG9jb2woKX06JHt1cml9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWA7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoY2FsbGJhY2ssIGNvZGUsIHJlYXNvbikge1xuICAgICAgdGhpcy5jb25uZWN0Q2xvY2srKztcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IHRydWU7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCk7XG4gICAgICB0aGlzLnRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pO1xuICAgIH1cbiAgICBjb25uZWN0KHBhcmFtcykge1xuICAgICAgdGhpcy5jb25uZWN0Q2xvY2srKztcbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlO1xuICAgICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSk7XG4gICAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZTtcbiAgICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dDtcbiAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKTtcbiAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLm9uQ29ubkVycm9yKGVycm9yKTtcbiAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHRoaXMub25Db25uTWVzc2FnZShldmVudCk7XG4gICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudCk7XG4gICAgfVxuICAgIGxvZyhraW5kLCBtc2csIGRhdGEpIHtcbiAgICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIGhhc0xvZ2dlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvZ2dlciAhPT0gbnVsbDtcbiAgICB9XG4gICAgb25PcGVuKGNhbGxiYWNrKSB7XG4gICAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4ucHVzaChbcmVmLCBjYWxsYmFja10pO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgb25DbG9zZShjYWxsYmFjaykge1xuICAgICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSk7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBvbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLnB1c2goW3JlZiwgY2FsbGJhY2tdKTtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIG9uTWVzc2FnZShjYWxsYmFjaykge1xuICAgICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLnB1c2goW3JlZiwgY2FsbGJhY2tdKTtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIG9uQ29ubk9wZW4oKSB7XG4gICAgICBpZiAodGhpcy5oYXNMb2dnZXIoKSlcbiAgICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kUG9pbnRVUkwoKX1gKTtcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlO1xuICAgICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zKys7XG4gICAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpO1xuICAgICAgdGhpcy5yZXNldEhlYXJ0YmVhdCgpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soKSk7XG4gICAgfVxuICAgIGhlYXJ0YmVhdFRpbWVvdXQoKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFibm9ybWFsQ2xvc2UoXCJoZWFydGJlYXQgdGltZW91dFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRIZWFydGJlYXQoKSB7XG4gICAgICBpZiAodGhpcy5jb25uICYmIHRoaXMuY29ubi5za2lwSGVhcnRiZWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xuICAgIH1cbiAgICB0ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKSB7XG4gICAgICBpZiAoIXRoaXMuY29ubikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gfHwgXCJcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgd2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzID0gMSkge1xuICAgICAgaWYgKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgIXRoaXMuY29ubi5idWZmZXJlZEFtb3VudCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgKyAxKTtcbiAgICAgIH0sIDE1MCAqIHRyaWVzKTtcbiAgICB9XG4gICAgd2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgPSAxKSB7XG4gICAgICBpZiAodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jbG9zZWQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgKyAxKTtcbiAgICAgIH0sIDE1MCAqIHRyaWVzKTtcbiAgICB9XG4gICAgb25Db25uQ2xvc2UoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImNsb3NlXCIsIGV2ZW50KTtcbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgaWYgKCF0aGlzLmNsb3NlV2FzQ2xlYW4pIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICAgIH1cbiAgICBvbkNvbm5FcnJvcihlcnJvcikge1xuICAgICAgaWYgKHRoaXMuaGFzTG9nZ2VyKCkpXG4gICAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGVycm9yKTtcbiAgICAgIGxldCB0cmFuc3BvcnRCZWZvcmUgPSB0aGlzLnRyYW5zcG9ydDtcbiAgICAgIGxldCBlc3RhYmxpc2hlZEJlZm9yZSA9IHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucztcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCB0cmFuc3BvcnRCZWZvcmUsIGVzdGFibGlzaGVkQmVmb3JlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRyYW5zcG9ydEJlZm9yZSA9PT0gdGhpcy50cmFuc3BvcnQgfHwgZXN0YWJsaXNoZWRCZWZvcmUgPiAwKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgIGlmICghKGNoYW5uZWwuaXNFcnJvcmVkKCkgfHwgY2hhbm5lbC5pc0xlYXZpbmcoKSB8fCBjaGFubmVsLmlzQ2xvc2VkKCkpKSB7XG4gICAgICAgICAgY2hhbm5lbC50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOlxuICAgICAgICAgIHJldHVybiBcImNvbm5lY3RpbmdcIjtcbiAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgICAgcmV0dXJuIFwib3BlblwiO1xuICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzpcbiAgICAgICAgICByZXR1cm4gXCJjbG9zaW5nXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiY2xvc2VkXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IFwib3BlblwiO1xuICAgIH1cbiAgICByZW1vdmUoY2hhbm5lbCkge1xuICAgICAgdGhpcy5vZmYoY2hhbm5lbC5zdGF0ZUNoYW5nZVJlZnMpO1xuICAgICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKChjKSA9PiBjLmpvaW5SZWYoKSAhPT0gY2hhbm5lbC5qb2luUmVmKCkpO1xuICAgIH1cbiAgICBvZmYocmVmcykge1xuICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldLmZpbHRlcigoW3JlZl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVmcy5pbmRleE9mKHJlZikgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcyA9IHt9KSB7XG4gICAgICBsZXQgY2hhbiA9IG5ldyBDaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zLCB0aGlzKTtcbiAgICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKTtcbiAgICAgIHJldHVybiBjaGFuO1xuICAgIH1cbiAgICBwdXNoKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKSB7XG4gICAgICAgIGxldCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZiB9ID0gZGF0YTtcbiAgICAgICAgdGhpcy5sb2coXCJwdXNoXCIsIGAke3RvcGljfSAke2V2ZW50fSAoJHtqb2luX3JlZn0sICR7cmVmfSlgLCBwYXlsb2FkKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgKHJlc3VsdCkgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaCgoKSA9PiB0aGlzLmVuY29kZShkYXRhLCAocmVzdWx0KSA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1ha2VSZWYoKSB7XG4gICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxO1xuICAgICAgaWYgKG5ld1JlZiA9PT0gdGhpcy5yZWYpIHtcbiAgICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWYgPSBuZXdSZWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc2VuZEhlYXJ0YmVhdCgpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgJiYgIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLm1ha2VSZWYoKTtcbiAgICAgIHRoaXMucHVzaCh7IHRvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiB9KTtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGVhcnRiZWF0VGltZW91dCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xuICAgIH1cbiAgICBhYm5vcm1hbENsb3NlKHJlYXNvbikge1xuICAgICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZShXU19DTE9TRV9OT1JNQUwsIHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoU2VuZEJ1ZmZlcigpIHtcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSkge1xuICAgICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCAobXNnKSA9PiB7XG4gICAgICAgIGxldCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZiB9ID0gbXNnO1xuICAgICAgICBpZiAocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNMb2dnZXIoKSlcbiAgICAgICAgICB0aGlzLmxvZyhcInJlY2VpdmVcIiwgYCR7cGF5bG9hZC5zdGF0dXMgfHwgXCJcIn0gJHt0b3BpY30gJHtldmVudH0gJHtyZWYgJiYgXCIoXCIgKyByZWYgKyBcIilcIiB8fCBcIlwifWAsIHBheWxvYWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgICAgICBpZiAoIWNoYW5uZWwuaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luX3JlZikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFubmVsLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IFssIGNhbGxiYWNrXSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtpXTtcbiAgICAgICAgICBjYWxsYmFjayhtc2cpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmVPcGVuVG9waWModG9waWMpIHtcbiAgICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5pc0pvaW5lZCgpIHx8IGMuaXNKb2luaW5nKCkpKTtcbiAgICAgIGlmIChkdXBDaGFubmVsKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKTtcbiAgICAgICAgZHVwQ2hhbm5lbC5sZWF2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHBob2VuaXhfZXhwb3J0cztcbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQWpGQTtBQUNBO0FBbUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUEzTEE7QUFDQTtBQTZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBNUVBO0FBQ0E7QUE4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJGQTtBQUNBO0FBdUZBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFMQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXBJQTtBQUNBO0FBc0lBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQWhHQTtBQUNBO0FBa0dBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF2VUE7QUF3VUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../deps/phoenix/priv/static/phoenix.js\n");

/***/ }),

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element, targetModifierKey) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n    if (target) form.target = target;else if (targetModifierKey) form.target = \"_blank\";\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element, e.metaKey || e.shiftKey);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2RlcHMvcGhvZW5peF9odG1sL3ByaXYvc3RhdGljL3Bob2VuaXhfaHRtbC5qcz80N2Q4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xuXG4gIGZ1bmN0aW9uIGV2ZW50Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcbiAgICAvLyBJRTw9OSBTdXBwb3J0XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgIHJldHVybiBDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlbGVtZW50LCB0YXJnZXRNb2RpZmllcktleSkge1xuICAgIHZhciB0byA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b1wiKSxcbiAgICAgICAgbWV0aG9kID0gYnVpbGRIaWRkZW5JbnB1dChcIl9tZXRob2RcIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSksXG4gICAgICAgIGNzcmYgPSBidWlsZEhpZGRlbklucHV0KFwiX2NzcmZfdG9rZW5cIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNzcmZcIikpLFxuICAgICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIHRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuXG4gICAgZm9ybS5tZXRob2QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSA9PT0gXCJnZXRcIikgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgZm9ybS5hY3Rpb24gPSB0bztcbiAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuXG4gICAgaWYgKHRhcmdldCkgZm9ybS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZWxzZSBpZiAodGFyZ2V0TW9kaWZpZXJLZXkpIGZvcm0udGFyZ2V0ID0gXCJfYmxhbmtcIjtcblxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2QpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG5cbiAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBob2VuaXhMaW5rRXZlbnQgPSBuZXcgUG9seWZpbGxFdmVudCgncGhvZW5peC5saW5rLmNsaWNrJywge1xuICAgICAgICBcImJ1YmJsZXNcIjogdHJ1ZSwgXCJjYW5jZWxhYmxlXCI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVsZW1lbnQuZGlzcGF0Y2hFdmVudChwaG9lbml4TGlua0V2ZW50KSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikpIHtcbiAgICAgICAgaGFuZGxlQ2xpY2soZWxlbWVudCwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9LCBmYWxzZSk7XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Bob2VuaXgubGluay5jbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbmZpcm1cIik7XG4gICAgaWYobWVzc2FnZSAmJiAhd2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../deps/phoenix_html/priv/static/phoenix_html.js\n");

/***/ }),

/***/ "../deps/phoenix_live_view/priv/static/phoenix_live_view.js":
/*!******************************************************************!*\
  !*** ../deps/phoenix_live_view/priv/static/phoenix_live_view.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var LiveView = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n\n  var __markAsModule = target => __defProp(target, \"__esModule\", {\n    value: true\n  });\n\n  var __export = (target, all) => {\n    __markAsModule(target);\n\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  }; // js/phoenix_live_view/index.js\n\n\n  var phoenix_live_view_exports = {};\n\n  __export(phoenix_live_view_exports, {\n    LiveSocket: () => LiveSocket\n  }); // js/phoenix_live_view/constants.js\n\n\n  var CONSECUTIVE_RELOADS = \"consecutive-reloads\";\n  var MAX_RELOADS = 10;\n  var RELOAD_JITTER = [1e3, 3e3];\n  var FAILSAFE_JITTER = 3e4;\n  var PHX_EVENT_CLASSES = [\"phx-click-loading\", \"phx-change-loading\", \"phx-submit-loading\", \"phx-keydown-loading\", \"phx-keyup-loading\", \"phx-blur-loading\", \"phx-focus-loading\"];\n  var PHX_COMPONENT = \"data-phx-component\";\n  var PHX_LIVE_LINK = \"data-phx-link\";\n  var PHX_TRACK_STATIC = \"track-static\";\n  var PHX_LINK_STATE = \"data-phx-link-state\";\n  var PHX_REF = \"data-phx-ref\";\n  var PHX_TRACK_UPLOADS = \"track-uploads\";\n  var PHX_UPLOAD_REF = \"data-phx-upload-ref\";\n  var PHX_PREFLIGHTED_REFS = \"data-phx-preflighted-refs\";\n  var PHX_DONE_REFS = \"data-phx-done-refs\";\n  var PHX_DROP_TARGET = \"drop-target\";\n  var PHX_ACTIVE_ENTRY_REFS = \"data-phx-active-refs\";\n  var PHX_LIVE_FILE_UPDATED = \"phx:live-file:updated\";\n  var PHX_SKIP = \"data-phx-skip\";\n  var PHX_REMOVE = \"data-phx-remove\";\n  var PHX_PAGE_LOADING = \"page-loading\";\n  var PHX_CONNECTED_CLASS = \"phx-connected\";\n  var PHX_DISCONNECTED_CLASS = \"phx-disconnected\";\n  var PHX_NO_FEEDBACK_CLASS = \"phx-no-feedback\";\n  var PHX_ERROR_CLASS = \"phx-error\";\n  var PHX_PARENT_ID = \"data-phx-parent-id\";\n  var PHX_MAIN = \"data-phx-main\";\n  var PHX_ROOT_ID = \"data-phx-root-id\";\n  var PHX_TRIGGER_ACTION = \"trigger-action\";\n  var PHX_FEEDBACK_FOR = \"feedback-for\";\n  var PHX_HAS_FOCUSED = \"phx-has-focused\";\n  var FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\"];\n  var CHECKABLE_INPUTS = [\"checkbox\", \"radio\"];\n  var PHX_HAS_SUBMITTED = \"phx-has-submitted\";\n  var PHX_SESSION = \"data-phx-session\";\n  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;\n  var PHX_STATIC = \"data-phx-static\";\n  var PHX_READONLY = \"data-phx-readonly\";\n  var PHX_DISABLED = \"data-phx-disabled\";\n  var PHX_DISABLE_WITH = \"disable-with\";\n  var PHX_DISABLE_WITH_RESTORE = \"data-phx-disable-with-restore\";\n  var PHX_HOOK = \"hook\";\n  var PHX_DEBOUNCE = \"debounce\";\n  var PHX_THROTTLE = \"throttle\";\n  var PHX_UPDATE = \"update\";\n  var PHX_KEY = \"key\";\n  var PHX_PRIVATE = \"phxPrivate\";\n  var PHX_AUTO_RECOVER = \"auto-recover\";\n  var PHX_LV_DEBUG = \"phx:live-socket:debug\";\n  var PHX_LV_PROFILE = \"phx:live-socket:profiling\";\n  var PHX_LV_LATENCY_SIM = \"phx:live-socket:latency-sim\";\n  var PHX_PROGRESS = \"progress\";\n  var LOADER_TIMEOUT = 1;\n  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\n  var BINDING_PREFIX = \"phx-\";\n  var PUSH_TIMEOUT = 3e4;\n  var DEBOUNCE_TRIGGER = \"debounce-trigger\";\n  var THROTTLED = \"throttled\";\n  var DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\n  var DEFAULTS = {\n    debounce: 300,\n    throttle: 300\n  };\n  var DYNAMICS = \"d\";\n  var STATIC = \"s\";\n  var COMPONENTS = \"c\";\n  var EVENTS = \"e\";\n  var REPLY = \"r\";\n  var TITLE = \"t\"; // js/phoenix_live_view/entry_uploader.js\n\n  var EntryUploader = class {\n    constructor(entry, chunkSize, liveSocket) {\n      this.liveSocket = liveSocket;\n      this.entry = entry;\n      this.offset = 0;\n      this.chunkSize = chunkSize;\n      this.chunkTimer = null;\n      this.uploadChannel = liveSocket.channel(`lvu:${entry.ref}`, {\n        token: entry.metadata()\n      });\n    }\n\n    error(reason) {\n      clearTimeout(this.chunkTimer);\n      this.uploadChannel.leave();\n      this.entry.error(reason);\n    }\n\n    upload() {\n      this.uploadChannel.onError(reason => this.error(reason));\n      this.uploadChannel.join().receive(\"ok\", _data => this.readNextChunk()).receive(\"error\", reason => this.error(reason));\n    }\n\n    isDone() {\n      return this.offset >= this.entry.file.size;\n    }\n\n    readNextChunk() {\n      let reader = new window.FileReader();\n      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);\n\n      reader.onload = e => {\n        if (e.target.error === null) {\n          this.offset += e.target.result.byteLength;\n          this.pushChunk(e.target.result);\n        } else {\n          return logError(\"Read error: \" + e.target.error);\n        }\n      };\n\n      reader.readAsArrayBuffer(blob);\n    }\n\n    pushChunk(chunk) {\n      if (!this.uploadChannel.isJoined()) {\n        return;\n      }\n\n      this.uploadChannel.push(\"chunk\", chunk).receive(\"ok\", () => {\n        this.entry.progress(this.offset / this.entry.file.size * 100);\n\n        if (!this.isDone()) {\n          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);\n        }\n      });\n    }\n\n  }; // js/phoenix_live_view/utils.js\n\n  var logError = (msg, obj) => console.error && console.error(msg, obj);\n\n  var isCid = cid => typeof cid === \"number\";\n\n  function detectDuplicateIds() {\n    let ids = new Set();\n    let elems = document.querySelectorAll(\"*[id]\");\n\n    for (let i = 0, len = elems.length; i < len; i++) {\n      if (ids.has(elems[i].id)) {\n        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);\n      } else {\n        ids.add(elems[i].id);\n      }\n    }\n  }\n\n  var debug = (view, kind, msg, obj) => {\n    if (view.liveSocket.isDebugEnabled()) {\n      console.log(`${view.id} ${kind}: ${msg} - `, obj);\n    }\n  };\n\n  var closure = val => typeof val === \"function\" ? val : function () {\n    return val;\n  };\n\n  var clone = obj => {\n    return JSON.parse(JSON.stringify(obj));\n  };\n\n  var closestPhxBinding = (el, binding, borderEl) => {\n    do {\n      if (el.matches(`[${binding}]`)) {\n        return el;\n      }\n\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));\n\n    return null;\n  };\n\n  var isObject = obj => {\n    return obj !== null && typeof obj === \"object\" && !(obj instanceof Array);\n  };\n\n  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);\n\n  var isEmpty = obj => {\n    for (let x in obj) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var maybe = (el, callback) => el && callback(el);\n\n  var channelUploader = function (entries, onError, resp, liveSocket) {\n    entries.forEach(entry => {\n      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket);\n      entryUploader.upload();\n    });\n  }; // js/phoenix_live_view/browser.js\n\n\n  var Browser = {\n    canPushState() {\n      return typeof history.pushState !== \"undefined\";\n    },\n\n    dropLocal(localStorage, namespace, subkey) {\n      return localStorage.removeItem(this.localKey(namespace, subkey));\n    },\n\n    updateLocal(localStorage, namespace, subkey, initial, func) {\n      let current = this.getLocal(localStorage, namespace, subkey);\n      let key = this.localKey(namespace, subkey);\n      let newVal = current === null ? initial : func(current);\n      localStorage.setItem(key, JSON.stringify(newVal));\n      return newVal;\n    },\n\n    getLocal(localStorage, namespace, subkey) {\n      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));\n    },\n\n    updateCurrentState(callback) {\n      if (!this.canPushState()) {\n        return;\n      }\n\n      history.replaceState(callback(history.state || {}), \"\", window.location.href);\n    },\n\n    pushState(kind, meta, to) {\n      if (this.canPushState()) {\n        if (to !== window.location.href) {\n          if (meta.type == \"redirect\" && meta.scroll) {\n            let currentState = history.state || {};\n            currentState.scroll = meta.scroll;\n            history.replaceState(currentState, \"\", window.location.href);\n          }\n\n          delete meta.scroll;\n          history[kind + \"State\"](meta, \"\", to || null);\n          let hashEl = this.getHashTargetEl(window.location.hash);\n\n          if (hashEl) {\n            hashEl.scrollIntoView();\n          } else if (meta.type === \"redirect\") {\n            window.scroll(0, 0);\n          }\n        }\n      } else {\n        this.redirect(to);\n      }\n    },\n\n    setCookie(name, value) {\n      document.cookie = `${name}=${value}`;\n    },\n\n    getCookie(name) {\n      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), \"$1\");\n    },\n\n    redirect(toURL, flash) {\n      if (flash) {\n        Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\n      }\n\n      window.location = toURL;\n    },\n\n    localKey(namespace, subkey) {\n      return `${namespace}-${subkey}`;\n    },\n\n    getHashTargetEl(maybeHash) {\n      let hash = maybeHash.toString().substring(1);\n\n      if (hash === \"\") {\n        return;\n      }\n\n      return document.getElementById(hash) || document.querySelector(`a[name=\"${hash}\"]`);\n    }\n\n  };\n  var browser_default = Browser; // js/phoenix_live_view/dom.js\n\n  var DOM = {\n    byId(id) {\n      return document.getElementById(id) || logError(`no id found for ${id}`);\n    },\n\n    removeClass(el, className) {\n      el.classList.remove(className);\n\n      if (el.classList.length === 0) {\n        el.removeAttribute(\"class\");\n      }\n    },\n\n    all(node, query, callback) {\n      if (!node) {\n        return [];\n      }\n\n      let array = Array.from(node.querySelectorAll(query));\n      return callback ? array.forEach(callback) : array;\n    },\n\n    childNodeLength(html) {\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return template.content.childElementCount;\n    },\n\n    isUploadInput(el) {\n      return el.type === \"file\" && el.getAttribute(PHX_UPLOAD_REF) !== null;\n    },\n\n    findUploadInputs(node) {\n      return this.all(node, `input[type=\"file\"][${PHX_UPLOAD_REF}]`);\n    },\n\n    findComponentNodeList(node, cid) {\n      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}=\"${cid}\"]`), node);\n    },\n\n    isPhxDestroyed(node) {\n      return node.id && DOM.private(node, \"destroyed\") ? true : false;\n    },\n\n    markPhxChildDestroyed(el) {\n      el.setAttribute(PHX_SESSION, \"\");\n      this.putPrivate(el, \"destroyed\", true);\n    },\n\n    findPhxChildrenInFragment(html, parentId) {\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return this.findPhxChildren(template.content, parentId);\n    },\n\n    isIgnored(el, phxUpdate) {\n      return (el.getAttribute(phxUpdate) || el.getAttribute(\"data-phx-update\")) === \"ignore\";\n    },\n\n    isPhxUpdate(el, phxUpdate, updateTypes) {\n      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;\n    },\n\n    findPhxChildren(el, parentId) {\n      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}=\"${parentId}\"]`);\n    },\n\n    findParentCIDs(node, cids) {\n      let initial = new Set(cids);\n      return cids.reduce((acc, cid) => {\n        let selector = `[${PHX_COMPONENT}=\"${cid}\"] [${PHX_COMPONENT}]`;\n        this.filterWithinSameLiveView(this.all(node, selector), node).map(el => parseInt(el.getAttribute(PHX_COMPONENT))).forEach(childCID => acc.delete(childCID));\n        return acc;\n      }, initial);\n    },\n\n    filterWithinSameLiveView(nodes, parent) {\n      if (parent.querySelector(PHX_VIEW_SELECTOR)) {\n        return nodes.filter(el => this.withinSameLiveView(el, parent));\n      } else {\n        return nodes;\n      }\n    },\n\n    withinSameLiveView(node, parent) {\n      while (node = node.parentNode) {\n        if (node.isSameNode(parent)) {\n          return true;\n        }\n\n        if (node.getAttribute(PHX_SESSION) !== null) {\n          return false;\n        }\n      }\n    },\n\n    private(el, key) {\n      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\n    },\n\n    deletePrivate(el, key) {\n      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\n    },\n\n    putPrivate(el, key, value) {\n      if (!el[PHX_PRIVATE]) {\n        el[PHX_PRIVATE] = {};\n      }\n\n      el[PHX_PRIVATE][key] = value;\n    },\n\n    copyPrivates(target, source) {\n      if (source[PHX_PRIVATE]) {\n        target[PHX_PRIVATE] = clone(source[PHX_PRIVATE]);\n      }\n    },\n\n    putTitle(str) {\n      let titleEl = document.querySelector(\"title\");\n      let {\n        prefix,\n        suffix\n      } = titleEl.dataset;\n      document.title = `${prefix || \"\"}${str}${suffix || \"\"}`;\n    },\n\n    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback) {\n      let debounce = el.getAttribute(phxDebounce);\n      let throttle = el.getAttribute(phxThrottle);\n\n      if (debounce === \"\") {\n        debounce = defaultDebounce;\n      }\n\n      if (throttle === \"\") {\n        throttle = defaultThrottle;\n      }\n\n      let value = debounce || throttle;\n\n      switch (value) {\n        case null:\n          return callback();\n\n        case \"blur\":\n          if (this.once(el, \"debounce-blur\")) {\n            el.addEventListener(\"blur\", () => callback());\n          }\n\n          return;\n\n        default:\n          let timeout = parseInt(value);\n\n          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();\n\n          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);\n\n          if (isNaN(timeout)) {\n            return logError(`invalid throttle/debounce value: ${value}`);\n          }\n\n          if (throttle) {\n            let newKeyDown = false;\n\n            if (event.type === \"keydown\") {\n              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);\n              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);\n              newKeyDown = prevKey !== event.key;\n            }\n\n            if (!newKeyDown && this.private(el, THROTTLED)) {\n              return false;\n            } else {\n              callback();\n              this.putPrivate(el, THROTTLED, true);\n              setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER), timeout);\n            }\n          } else {\n            setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle), timeout);\n          }\n\n          let form = el.form;\n\n          if (form && this.once(form, \"bind-debounce\")) {\n            form.addEventListener(\"submit\", () => {\n              Array.from(new FormData(form).entries(), ([name]) => {\n                let input = form.querySelector(`[name=\"${name}\"]`);\n                this.incCycle(input, DEBOUNCE_TRIGGER);\n                this.deletePrivate(input, THROTTLED);\n              });\n            });\n          }\n\n          if (this.once(el, \"bind-debounce\")) {\n            el.addEventListener(\"blur\", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));\n          }\n\n      }\n    },\n\n    triggerCycle(el, key, currentCycle) {\n      let [cycle, trigger] = this.private(el, key);\n\n      if (!currentCycle) {\n        currentCycle = cycle;\n      }\n\n      if (currentCycle === cycle) {\n        this.incCycle(el, key);\n        trigger();\n      }\n    },\n\n    once(el, key) {\n      if (this.private(el, key) === true) {\n        return false;\n      }\n\n      this.putPrivate(el, key, true);\n      return true;\n    },\n\n    incCycle(el, key, trigger = function () {}) {\n      let [currentCycle] = this.private(el, key) || [0, trigger];\n      currentCycle++;\n      this.putPrivate(el, key, [currentCycle, trigger]);\n      return currentCycle;\n    },\n\n    discardError(container, el, phxFeedbackFor) {\n      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);\n      let input = field && container.querySelector(`[id=\"${field}\"], [name=\"${field}\"]`);\n\n      if (!input) {\n        return;\n      }\n\n      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {\n        el.classList.add(PHX_NO_FEEDBACK_CLASS);\n      }\n    },\n\n    showError(inputEl, phxFeedbackFor) {\n      if (inputEl.id || inputEl.name) {\n        this.all(inputEl.form, `[${phxFeedbackFor}=\"${inputEl.id}\"], [${phxFeedbackFor}=\"${inputEl.name}\"]`, el => {\n          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);\n        });\n      }\n    },\n\n    isPhxChild(node) {\n      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n    },\n\n    dispatchEvent(target, eventString, detail = {}) {\n      let event = new CustomEvent(eventString, {\n        bubbles: true,\n        cancelable: true,\n        detail\n      });\n      target.dispatchEvent(event);\n    },\n\n    cloneNode(node, html) {\n      if (typeof html === \"undefined\") {\n        return node.cloneNode(true);\n      } else {\n        let cloned = node.cloneNode(false);\n        cloned.innerHTML = html;\n        return cloned;\n      }\n    },\n\n    mergeAttrs(target, source, opts = {}) {\n      let exclude = opts.exclude || [];\n      let isIgnored = opts.isIgnored;\n      let sourceAttrs = source.attributes;\n\n      for (let i = sourceAttrs.length - 1; i >= 0; i--) {\n        let name = sourceAttrs[i].name;\n\n        if (exclude.indexOf(name) < 0) {\n          target.setAttribute(name, source.getAttribute(name));\n        }\n      }\n\n      let targetAttrs = target.attributes;\n\n      for (let i = targetAttrs.length - 1; i >= 0; i--) {\n        let name = targetAttrs[i].name;\n\n        if (isIgnored) {\n          if (name.startsWith(\"data-\") && !source.hasAttribute(name)) {\n            target.removeAttribute(name);\n          }\n        } else {\n          if (!source.hasAttribute(name)) {\n            target.removeAttribute(name);\n          }\n        }\n      }\n    },\n\n    mergeFocusedInput(target, source) {\n      if (!(target instanceof HTMLSelectElement)) {\n        DOM.mergeAttrs(target, source, {\n          except: [\"value\"]\n        });\n      }\n\n      if (source.readOnly) {\n        target.setAttribute(\"readonly\", true);\n      } else {\n        target.removeAttribute(\"readonly\");\n      }\n    },\n\n    hasSelectionRange(el) {\n      return el.setSelectionRange && (el.type === \"text\" || el.type === \"textarea\");\n    },\n\n    restoreFocus(focused, selectionStart, selectionEnd) {\n      if (!DOM.isTextualInput(focused)) {\n        return;\n      }\n\n      let wasFocused = focused.matches(\":focus\");\n\n      if (focused.readOnly) {\n        focused.blur();\n      }\n\n      if (!wasFocused) {\n        focused.focus();\n      }\n\n      if (this.hasSelectionRange(focused)) {\n        focused.setSelectionRange(selectionStart, selectionEnd);\n      }\n    },\n\n    isFormInput(el) {\n      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== \"button\";\n    },\n\n    syncAttrsToProps(el) {\n      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {\n        el.checked = el.getAttribute(\"checked\") !== null;\n      }\n    },\n\n    syncPropsToAttrs(el) {\n      if (el instanceof HTMLSelectElement) {\n        let selectedItem = el.options.item(el.selectedIndex);\n\n        if (selectedItem && selectedItem.getAttribute(\"selected\") === null) {\n          selectedItem.setAttribute(\"selected\", \"\");\n        }\n      }\n    },\n\n    isTextualInput(el) {\n      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n    },\n\n    isNowTriggerFormExternal(el, phxTriggerExternal) {\n      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;\n    },\n\n    syncPendingRef(fromEl, toEl, disableWith) {\n      let ref = fromEl.getAttribute(PHX_REF);\n\n      if (ref === null) {\n        return true;\n      }\n\n      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {\n        if (DOM.isUploadInput(fromEl)) {\n          DOM.mergeAttrs(fromEl, toEl, {\n            isIgnored: true\n          });\n        }\n\n        DOM.putPrivate(fromEl, PHX_REF, toEl);\n        return false;\n      } else {\n        PHX_EVENT_CLASSES.forEach(className => {\n          fromEl.classList.contains(className) && toEl.classList.add(className);\n        });\n        toEl.setAttribute(PHX_REF, ref);\n        return true;\n      }\n    },\n\n    cleanChildNodes(container, phxUpdate) {\n      if (DOM.isPhxUpdate(container, phxUpdate, [\"append\", \"prepend\"])) {\n        let toRemove = [];\n        container.childNodes.forEach(childNode => {\n          if (!childNode.id) {\n            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === \"\";\n\n            if (!isEmptyTextNode) {\n              logError(`only HTML element tags with an id are allowed inside containers with phx-update.\n\nremoving illegal node: \"${(childNode.outerHTML || childNode.nodeValue).trim()}\"\n\n`);\n            }\n\n            toRemove.push(childNode);\n          }\n        });\n        toRemove.forEach(childNode => childNode.remove());\n      }\n    },\n\n    replaceRootContainer(container, tagName, attrs) {\n      let retainedAttrs = new Set([\"id\", PHX_SESSION, PHX_STATIC, PHX_MAIN]);\n\n      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {\n        Array.from(container.attributes).filter(attr => !retainedAttrs.has(attr.name.toLowerCase())).forEach(attr => container.removeAttribute(attr.name));\n        Object.keys(attrs).filter(name => !retainedAttrs.has(name.toLowerCase())).forEach(attr => container.setAttribute(attr, attrs[attr]));\n        return container;\n      } else {\n        let newContainer = document.createElement(tagName);\n        Object.keys(attrs).forEach(attr => newContainer.setAttribute(attr, attrs[attr]));\n        retainedAttrs.forEach(attr => newContainer.setAttribute(attr, container.getAttribute(attr)));\n        newContainer.innerHTML = container.innerHTML;\n        container.replaceWith(newContainer);\n        return newContainer;\n      }\n    }\n\n  };\n  var dom_default = DOM; // js/phoenix_live_view/upload_entry.js\n\n  var UploadEntry = class {\n    static isActive(fileEl, file) {\n      let isNew = file._phxRef === void 0;\n      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n      return file.size > 0 && (isNew || isActive);\n    }\n\n    static isPreflighted(fileEl, file) {\n      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(\",\");\n      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n      return isPreflighted && this.isActive(fileEl, file);\n    }\n\n    constructor(fileEl, file, view) {\n      this.ref = LiveUploader.genFileRef(file);\n      this.fileEl = fileEl;\n      this.file = file;\n      this.view = view;\n      this.meta = null;\n      this._isCancelled = false;\n      this._isDone = false;\n      this._progress = 0;\n      this._lastProgressSent = -1;\n\n      this._onDone = function () {};\n\n      this._onElUpdated = this.onElUpdated.bind(this);\n      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n    }\n\n    metadata() {\n      return this.meta;\n    }\n\n    progress(progress) {\n      this._progress = Math.floor(progress);\n\n      if (this._progress > this._lastProgressSent) {\n        if (this._progress >= 100) {\n          this._progress = 100;\n          this._lastProgressSent = 100;\n          this._isDone = true;\n          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {\n            LiveUploader.untrackFile(this.fileEl, this.file);\n\n            this._onDone();\n          });\n        } else {\n          this._lastProgressSent = this._progress;\n          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\n        }\n      }\n    }\n\n    cancel() {\n      this._isCancelled = true;\n      this._isDone = true;\n\n      this._onDone();\n    }\n\n    isDone() {\n      return this._isDone;\n    }\n\n    error(reason = \"failed\") {\n      this.view.pushFileProgress(this.fileEl, this.ref, {\n        error: reason\n      });\n      LiveUploader.clearFiles(this.fileEl);\n    }\n\n    onDone(callback) {\n      this._onDone = () => {\n        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n        callback();\n      };\n    }\n\n    onElUpdated() {\n      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n\n      if (activeRefs.indexOf(this.ref) === -1) {\n        this.cancel();\n      }\n    }\n\n    toPreflightPayload() {\n      return {\n        last_modified: this.file.lastModified,\n        name: this.file.name,\n        size: this.file.size,\n        type: this.file.type,\n        ref: this.ref\n      };\n    }\n\n    uploader(uploaders) {\n      if (this.meta.uploader) {\n        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);\n        return {\n          name: this.meta.uploader,\n          callback\n        };\n      } else {\n        return {\n          name: \"channel\",\n          callback: channelUploader\n        };\n      }\n    }\n\n    zipPostFlight(resp) {\n      this.meta = resp.entries[this.ref];\n\n      if (!this.meta) {\n        logError(`no preflight upload response returned with ref ${this.ref}`, {\n          input: this.fileEl,\n          response: resp\n        });\n      }\n    }\n\n  }; // js/phoenix_live_view/live_uploader.js\n\n  var liveUploaderFileRef = 0;\n  var LiveUploader = class {\n    static genFileRef(file) {\n      let ref = file._phxRef;\n\n      if (ref !== void 0) {\n        return ref;\n      } else {\n        file._phxRef = (liveUploaderFileRef++).toString();\n        return file._phxRef;\n      }\n    }\n\n    static getEntryDataURL(inputEl, ref, callback) {\n      let file = this.activeFiles(inputEl).find(file2 => this.genFileRef(file2) === ref);\n      callback(URL.createObjectURL(file));\n    }\n\n    static hasUploadsInProgress(formEl) {\n      let active = 0;\n      dom_default.findUploadInputs(formEl).forEach(input => {\n        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {\n          active++;\n        }\n      });\n      return active > 0;\n    }\n\n    static serializeUploads(inputEl) {\n      let files = this.activeFiles(inputEl);\n      let fileData = {};\n      files.forEach(file => {\n        let entry = {\n          path: inputEl.name\n        };\n        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);\n        fileData[uploadRef] = fileData[uploadRef] || [];\n        entry.ref = this.genFileRef(file);\n        entry.name = file.name || entry.ref;\n        entry.type = file.type;\n        entry.size = file.size;\n        fileData[uploadRef].push(entry);\n      });\n      return fileData;\n    }\n\n    static clearFiles(inputEl) {\n      inputEl.value = null;\n      inputEl.removeAttribute(PHX_UPLOAD_REF);\n      dom_default.putPrivate(inputEl, \"files\", []);\n    }\n\n    static untrackFile(inputEl, file) {\n      dom_default.putPrivate(inputEl, \"files\", dom_default.private(inputEl, \"files\").filter(f => !Object.is(f, file)));\n    }\n\n    static trackFiles(inputEl, files) {\n      if (inputEl.getAttribute(\"multiple\") !== null) {\n        let newFiles = files.filter(file => !this.activeFiles(inputEl).find(f => Object.is(f, file)));\n        dom_default.putPrivate(inputEl, \"files\", this.activeFiles(inputEl).concat(newFiles));\n        inputEl.value = null;\n      } else {\n        dom_default.putPrivate(inputEl, \"files\", files);\n      }\n    }\n\n    static activeFileInputs(formEl) {\n      let fileInputs = dom_default.findUploadInputs(formEl);\n      return Array.from(fileInputs).filter(el => el.files && this.activeFiles(el).length > 0);\n    }\n\n    static activeFiles(input) {\n      return (dom_default.private(input, \"files\") || []).filter(f => UploadEntry.isActive(input, f));\n    }\n\n    static inputsAwaitingPreflight(formEl) {\n      let fileInputs = dom_default.findUploadInputs(formEl);\n      return Array.from(fileInputs).filter(input => this.filesAwaitingPreflight(input).length > 0);\n    }\n\n    static filesAwaitingPreflight(input) {\n      return this.activeFiles(input).filter(f => !UploadEntry.isPreflighted(input, f));\n    }\n\n    constructor(inputEl, view, onComplete) {\n      this.view = view;\n      this.onComplete = onComplete;\n      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map(file => new UploadEntry(inputEl, file, view));\n      this.numEntriesInProgress = this._entries.length;\n    }\n\n    entries() {\n      return this._entries;\n    }\n\n    initAdapterUpload(resp, onError, liveSocket) {\n      this._entries = this._entries.map(entry => {\n        entry.zipPostFlight(resp);\n        entry.onDone(() => {\n          this.numEntriesInProgress--;\n\n          if (this.numEntriesInProgress === 0) {\n            this.onComplete();\n          }\n        });\n        return entry;\n      });\n\n      let groupedEntries = this._entries.reduce((acc, entry) => {\n        let {\n          name,\n          callback\n        } = entry.uploader(liveSocket.uploaders);\n        acc[name] = acc[name] || {\n          callback,\n          entries: []\n        };\n        acc[name].entries.push(entry);\n        return acc;\n      }, {});\n\n      for (let name in groupedEntries) {\n        let {\n          callback,\n          entries\n        } = groupedEntries[name];\n        callback(entries, onError, resp, liveSocket);\n      }\n    }\n\n  }; // js/phoenix_live_view/hooks.js\n\n  var Hooks = {\n    LiveFileUpload: {\n      activeRefs() {\n        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);\n      },\n\n      preflightedRefs() {\n        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);\n      },\n\n      mounted() {\n        this.preflightedWas = this.preflightedRefs();\n      },\n\n      updated() {\n        let newPreflights = this.preflightedRefs();\n\n        if (this.preflightedWas !== newPreflights) {\n          this.preflightedWas = newPreflights;\n\n          if (newPreflights === \"\") {\n            this.__view.cancelSubmit(this.el.form);\n          }\n        }\n\n        if (this.activeRefs() === \"\") {\n          this.el.value = null;\n        }\n\n        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));\n      }\n\n    },\n    LiveImgPreview: {\n      mounted() {\n        this.ref = this.el.getAttribute(\"data-phx-entry-ref\");\n        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));\n        LiveUploader.getEntryDataURL(this.inputEl, this.ref, url => {\n          this.url = url;\n          this.el.src = url;\n        });\n      },\n\n      destroyed() {\n        URL.revokeObjectURL(this.url);\n      }\n\n    }\n  };\n  var hooks_default = Hooks; // js/phoenix_live_view/dom_post_morph_restorer.js\n\n  var DOMPostMorphRestorer = class {\n    constructor(containerBefore, containerAfter, updateType) {\n      let idsBefore = new Set();\n      let idsAfter = new Set([...containerAfter.children].map(child => child.id));\n      let elementsToModify = [];\n      Array.from(containerBefore.children).forEach(child => {\n        if (child.id) {\n          idsBefore.add(child.id);\n\n          if (idsAfter.has(child.id)) {\n            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;\n            elementsToModify.push({\n              elementId: child.id,\n              previousElementId\n            });\n          }\n        }\n      });\n      this.containerId = containerAfter.id;\n      this.updateType = updateType;\n      this.elementsToModify = elementsToModify;\n      this.elementIdsToAdd = [...idsAfter].filter(id => !idsBefore.has(id));\n    }\n\n    perform() {\n      let container = dom_default.byId(this.containerId);\n      this.elementsToModify.forEach(elementToModify => {\n        if (elementToModify.previousElementId) {\n          maybe(document.getElementById(elementToModify.previousElementId), previousElem => {\n            maybe(document.getElementById(elementToModify.elementId), elem => {\n              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;\n\n              if (!isInRightPlace) {\n                previousElem.insertAdjacentElement(\"afterend\", elem);\n              }\n            });\n          });\n        } else {\n          maybe(document.getElementById(elementToModify.elementId), elem => {\n            let isInRightPlace = elem.previousElementSibling == null;\n\n            if (!isInRightPlace) {\n              container.insertAdjacentElement(\"afterbegin\", elem);\n            }\n          });\n        }\n      });\n\n      if (this.updateType == \"prepend\") {\n        this.elementIdsToAdd.reverse().forEach(elemId => {\n          maybe(document.getElementById(elemId), elem => container.insertAdjacentElement(\"afterbegin\", elem));\n        });\n      }\n    }\n\n  }; // node_modules/morphdom/dist/morphdom-esm.js\n\n  var DOCUMENT_FRAGMENT_NODE = 11;\n\n  function morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n      attr = toNodeAttrs[i];\n      attrName = attr.name;\n      attrNamespaceURI = attr.namespaceURI;\n      attrValue = attr.value;\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName;\n        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n        if (fromValue !== attrValue) {\n          if (attr.prefix === \"xmlns\") {\n            attrName = attr.name;\n          }\n\n          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n        }\n      } else {\n        fromValue = fromNode.getAttribute(attrName);\n\n        if (fromValue !== attrValue) {\n          fromNode.setAttribute(attrName, attrValue);\n        }\n      }\n    }\n\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n      attr = fromNodeAttrs[d];\n      attrName = attr.name;\n      attrNamespaceURI = attr.namespaceURI;\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName;\n\n        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n          fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n        }\n      } else {\n        if (!toNode.hasAttribute(attrName)) {\n          fromNode.removeAttribute(attrName);\n        }\n      }\n    }\n  }\n\n  var range;\n  var NS_XHTML = \"http://www.w3.org/1999/xhtml\";\n  var doc = typeof document === \"undefined\" ? void 0 : document;\n  var HAS_TEMPLATE_SUPPORT = !!doc && \"content\" in doc.createElement(\"template\");\n  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && \"createContextualFragment\" in doc.createRange();\n\n  function createFragmentFromTemplate(str) {\n    var template = doc.createElement(\"template\");\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n  }\n\n  function createFragmentFromRange(str) {\n    if (!range) {\n      range = doc.createRange();\n      range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n  }\n\n  function createFragmentFromWrap(str) {\n    var fragment = doc.createElement(\"body\");\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n  }\n\n  function toElement(str) {\n    str = str.trim();\n\n    if (HAS_TEMPLATE_SUPPORT) {\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n  }\n\n  function compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n      return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    if (fromCodeStart <= 90 && toCodeStart >= 97) {\n      return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {\n      return toNodeName === fromNodeName.toUpperCase();\n    } else {\n      return false;\n    }\n  }\n\n  function createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);\n  }\n\n  function moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n\n    while (curChild) {\n      var nextChild = curChild.nextSibling;\n      toEl.appendChild(curChild);\n      curChild = nextChild;\n    }\n\n    return toEl;\n  }\n\n  function syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n      fromEl[name] = toEl[name];\n\n      if (fromEl[name]) {\n        fromEl.setAttribute(name, \"\");\n      } else {\n        fromEl.removeAttribute(name);\n      }\n    }\n  }\n\n  var specialElHandlers = {\n    OPTION: function (fromEl, toEl) {\n      var parentNode = fromEl.parentNode;\n\n      if (parentNode) {\n        var parentName = parentNode.nodeName.toUpperCase();\n\n        if (parentName === \"OPTGROUP\") {\n          parentNode = parentNode.parentNode;\n          parentName = parentNode && parentNode.nodeName.toUpperCase();\n        }\n\n        if (parentName === \"SELECT\" && !parentNode.hasAttribute(\"multiple\")) {\n          if (fromEl.hasAttribute(\"selected\") && !toEl.selected) {\n            fromEl.setAttribute(\"selected\", \"selected\");\n            fromEl.removeAttribute(\"selected\");\n          }\n\n          parentNode.selectedIndex = -1;\n        }\n      }\n\n      syncBooleanAttrProp(fromEl, toEl, \"selected\");\n    },\n    INPUT: function (fromEl, toEl) {\n      syncBooleanAttrProp(fromEl, toEl, \"checked\");\n      syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n\n      if (fromEl.value !== toEl.value) {\n        fromEl.value = toEl.value;\n      }\n\n      if (!toEl.hasAttribute(\"value\")) {\n        fromEl.removeAttribute(\"value\");\n      }\n    },\n    TEXTAREA: function (fromEl, toEl) {\n      var newValue = toEl.value;\n\n      if (fromEl.value !== newValue) {\n        fromEl.value = newValue;\n      }\n\n      var firstChild = fromEl.firstChild;\n\n      if (firstChild) {\n        var oldValue = firstChild.nodeValue;\n\n        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {\n          return;\n        }\n\n        firstChild.nodeValue = newValue;\n      }\n    },\n    SELECT: function (fromEl, toEl) {\n      if (!toEl.hasAttribute(\"multiple\")) {\n        var selectedIndex = -1;\n        var i = 0;\n        var curChild = fromEl.firstChild;\n        var optgroup;\n        var nodeName;\n\n        while (curChild) {\n          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n\n          if (nodeName === \"OPTGROUP\") {\n            optgroup = curChild;\n            curChild = optgroup.firstChild;\n          } else {\n            if (nodeName === \"OPTION\") {\n              if (curChild.hasAttribute(\"selected\")) {\n                selectedIndex = i;\n                break;\n              }\n\n              i++;\n            }\n\n            curChild = curChild.nextSibling;\n\n            if (!curChild && optgroup) {\n              curChild = optgroup.nextSibling;\n              optgroup = null;\n            }\n          }\n        }\n\n        fromEl.selectedIndex = selectedIndex;\n      }\n    }\n  };\n  var ELEMENT_NODE = 1;\n  var DOCUMENT_FRAGMENT_NODE$1 = 11;\n  var TEXT_NODE = 3;\n  var COMMENT_NODE = 8;\n\n  function noop() {}\n\n  function defaultGetNodeKey(node) {\n    if (node) {\n      return node.getAttribute && node.getAttribute(\"id\") || node.id;\n    }\n  }\n\n  function morphdomFactory(morphAttrs2) {\n    return function morphdom2(fromNode, toNode, options) {\n      if (!options) {\n        options = {};\n      }\n\n      if (typeof toNode === \"string\") {\n        if (fromNode.nodeName === \"#document\" || fromNode.nodeName === \"HTML\" || fromNode.nodeName === \"BODY\") {\n          var toNodeHtml = toNode;\n          toNode = doc.createElement(\"html\");\n          toNode.innerHTML = toNodeHtml;\n        } else {\n          toNode = toElement(toNode);\n        }\n      }\n\n      var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n      var onNodeAdded = options.onNodeAdded || noop;\n      var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n      var onElUpdated = options.onElUpdated || noop;\n      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n      var onNodeDiscarded = options.onNodeDiscarded || noop;\n      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n      var childrenOnly = options.childrenOnly === true;\n      var fromNodesLookup = Object.create(null);\n      var keyedRemovalList = [];\n\n      function addKeyedRemoval(key) {\n        keyedRemovalList.push(key);\n      }\n\n      function walkDiscardedChildNodes(node, skipKeyedNodes) {\n        if (node.nodeType === ELEMENT_NODE) {\n          var curChild = node.firstChild;\n\n          while (curChild) {\n            var key = void 0;\n\n            if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n              addKeyedRemoval(key);\n            } else {\n              onNodeDiscarded(curChild);\n\n              if (curChild.firstChild) {\n                walkDiscardedChildNodes(curChild, skipKeyedNodes);\n              }\n            }\n\n            curChild = curChild.nextSibling;\n          }\n        }\n      }\n\n      function removeNode(node, parentNode, skipKeyedNodes) {\n        if (onBeforeNodeDiscarded(node) === false) {\n          return;\n        }\n\n        if (parentNode) {\n          parentNode.removeChild(node);\n        }\n\n        onNodeDiscarded(node);\n        walkDiscardedChildNodes(node, skipKeyedNodes);\n      }\n\n      function indexTree(node) {\n        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n          var curChild = node.firstChild;\n\n          while (curChild) {\n            var key = getNodeKey(curChild);\n\n            if (key) {\n              fromNodesLookup[key] = curChild;\n            }\n\n            indexTree(curChild);\n            curChild = curChild.nextSibling;\n          }\n        }\n      }\n\n      indexTree(fromNode);\n\n      function handleNodeAdded(el) {\n        onNodeAdded(el);\n        var curChild = el.firstChild;\n\n        while (curChild) {\n          var nextSibling = curChild.nextSibling;\n          var key = getNodeKey(curChild);\n\n          if (key) {\n            var unmatchedFromEl = fromNodesLookup[key];\n\n            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n              morphEl(unmatchedFromEl, curChild);\n            } else {\n              handleNodeAdded(curChild);\n            }\n          } else {\n            handleNodeAdded(curChild);\n          }\n\n          curChild = nextSibling;\n        }\n      }\n\n      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n        while (curFromNodeChild) {\n          var fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            removeNode(curFromNodeChild, fromEl, true);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        }\n      }\n\n      function morphEl(fromEl, toEl, childrenOnly2) {\n        var toElKey = getNodeKey(toEl);\n\n        if (toElKey) {\n          delete fromNodesLookup[toElKey];\n        }\n\n        if (!childrenOnly2) {\n          if (onBeforeElUpdated(fromEl, toEl) === false) {\n            return;\n          }\n\n          morphAttrs2(fromEl, toEl);\n          onElUpdated(fromEl);\n\n          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n            return;\n          }\n        }\n\n        if (fromEl.nodeName !== \"TEXTAREA\") {\n          morphChildren(fromEl, toEl);\n        } else {\n          specialElHandlers.TEXTAREA(fromEl, toEl);\n        }\n      }\n\n      function morphChildren(fromEl, toEl) {\n        var curToNodeChild = toEl.firstChild;\n        var curFromNodeChild = fromEl.firstChild;\n        var curToNodeKey;\n        var curFromNodeKey;\n        var fromNextSibling;\n        var toNextSibling;\n        var matchingFromEl;\n\n        outer: while (curToNodeChild) {\n          toNextSibling = curToNodeChild.nextSibling;\n          curToNodeKey = getNodeKey(curToNodeChild);\n\n          while (curFromNodeChild) {\n            fromNextSibling = curFromNodeChild.nextSibling;\n\n            if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n\n            curFromNodeKey = getNodeKey(curFromNodeChild);\n            var curFromNodeType = curFromNodeChild.nodeType;\n            var isCompatible = void 0;\n\n            if (curFromNodeType === curToNodeChild.nodeType) {\n              if (curFromNodeType === ELEMENT_NODE) {\n                if (curToNodeKey) {\n                  if (curToNodeKey !== curFromNodeKey) {\n                    if (matchingFromEl = fromNodesLookup[curToNodeKey]) {\n                      if (fromNextSibling === matchingFromEl) {\n                        isCompatible = false;\n                      } else {\n                        fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                        if (curFromNodeKey) {\n                          addKeyedRemoval(curFromNodeKey);\n                        } else {\n                          removeNode(curFromNodeChild, fromEl, true);\n                        }\n\n                        curFromNodeChild = matchingFromEl;\n                      }\n                    } else {\n                      isCompatible = false;\n                    }\n                  }\n                } else if (curFromNodeKey) {\n                  isCompatible = false;\n                }\n\n                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n\n                if (isCompatible) {\n                  morphEl(curFromNodeChild, curToNodeChild);\n                }\n              } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                isCompatible = true;\n\n                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                  curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                }\n              }\n            }\n\n            if (isCompatible) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n\n            if (curFromNodeKey) {\n              addKeyedRemoval(curFromNodeKey);\n            } else {\n              removeNode(curFromNodeChild, fromEl, true);\n            }\n\n            curFromNodeChild = fromNextSibling;\n          }\n\n          if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n            fromEl.appendChild(matchingFromEl);\n            morphEl(matchingFromEl, curToNodeChild);\n          } else {\n            var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n\n            if (onBeforeNodeAddedResult !== false) {\n              if (onBeforeNodeAddedResult) {\n                curToNodeChild = onBeforeNodeAddedResult;\n              }\n\n              if (curToNodeChild.actualize) {\n                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n              }\n\n              fromEl.appendChild(curToNodeChild);\n              handleNodeAdded(curToNodeChild);\n            }\n          }\n\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n        }\n\n        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n        var specialElHandler = specialElHandlers[fromEl.nodeName];\n\n        if (specialElHandler) {\n          specialElHandler(fromEl, toEl);\n        }\n      }\n\n      var morphedNode = fromNode;\n      var morphedNodeType = morphedNode.nodeType;\n      var toNodeType = toNode.nodeType;\n\n      if (!childrenOnly) {\n        if (morphedNodeType === ELEMENT_NODE) {\n          if (toNodeType === ELEMENT_NODE) {\n            if (!compareNodeNames(fromNode, toNode)) {\n              onNodeDiscarded(fromNode);\n              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n            }\n          } else {\n            morphedNode = toNode;\n          }\n        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {\n          if (toNodeType === morphedNodeType) {\n            if (morphedNode.nodeValue !== toNode.nodeValue) {\n              morphedNode.nodeValue = toNode.nodeValue;\n            }\n\n            return morphedNode;\n          } else {\n            morphedNode = toNode;\n          }\n        }\n      }\n\n      if (morphedNode === toNode) {\n        onNodeDiscarded(fromNode);\n      } else {\n        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n          return;\n        }\n\n        morphEl(morphedNode, toNode, childrenOnly);\n\n        if (keyedRemovalList) {\n          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {\n            var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n\n            if (elToRemove) {\n              removeNode(elToRemove, elToRemove.parentNode, false);\n            }\n          }\n        }\n      }\n\n      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n        if (morphedNode.actualize) {\n          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n        }\n\n        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n      }\n\n      return morphedNode;\n    };\n  }\n\n  var morphdom = morphdomFactory(morphAttrs);\n  var morphdom_esm_default = morphdom; // js/phoenix_live_view/dom_patch.js\n\n  var DOMPatch = class {\n    static patchEl(fromEl, toEl, activeElement) {\n      morphdom_esm_default(fromEl, toEl, {\n        childrenOnly: false,\n        onBeforeElUpdated: (fromEl2, toEl2) => {\n          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {\n            dom_default.mergeFocusedInput(fromEl2, toEl2);\n            return false;\n          }\n        }\n      });\n    }\n\n    constructor(view, container, id, html, targetCID) {\n      this.view = view;\n      this.liveSocket = view.liveSocket;\n      this.container = container;\n      this.id = id;\n      this.rootID = view.root.id;\n      this.html = html;\n      this.targetCID = targetCID;\n      this.cidPatch = isCid(this.targetCID);\n      this.callbacks = {\n        beforeadded: [],\n        beforeupdated: [],\n        beforephxChildAdded: [],\n        afteradded: [],\n        afterupdated: [],\n        afterdiscarded: [],\n        afterphxChildAdded: []\n      };\n    }\n\n    before(kind, callback) {\n      this.callbacks[`before${kind}`].push(callback);\n    }\n\n    after(kind, callback) {\n      this.callbacks[`after${kind}`].push(callback);\n    }\n\n    trackBefore(kind, ...args) {\n      this.callbacks[`before${kind}`].forEach(callback => callback(...args));\n    }\n\n    trackAfter(kind, ...args) {\n      this.callbacks[`after${kind}`].forEach(callback => callback(...args));\n    }\n\n    markPrunableContentForRemoval() {\n      dom_default.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", el => {\n        el.setAttribute(PHX_REMOVE, \"\");\n      });\n    }\n\n    perform() {\n      let {\n        view,\n        liveSocket,\n        container,\n        html\n      } = this;\n      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;\n\n      if (this.isCIDPatch() && !targetContainer) {\n        return;\n      }\n\n      let focused = liveSocket.getActiveElement();\n      let {\n        selectionStart,\n        selectionEnd\n      } = focused && dom_default.hasSelectionRange(focused) ? focused : {};\n      let phxUpdate = liveSocket.binding(PHX_UPDATE);\n      let phxFeedbackFor = liveSocket.binding(PHX_FEEDBACK_FOR);\n      let disableWith = liveSocket.binding(PHX_DISABLE_WITH);\n      let phxTriggerExternal = liveSocket.binding(PHX_TRIGGER_ACTION);\n      let added = [];\n      let updates = [];\n      let appendPrependUpdates = [];\n      let externalFormTriggered = null;\n      let diffHTML = liveSocket.time(\"premorph container prep\", () => {\n        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);\n      });\n      this.trackBefore(\"added\", container);\n      this.trackBefore(\"updated\", container, container);\n      liveSocket.time(\"morphdom\", () => {\n        morphdom_esm_default(targetContainer, diffHTML, {\n          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,\n          getNodeKey: node => {\n            return dom_default.isPhxDestroyed(node) ? null : node.id;\n          },\n          onBeforeNodeAdded: el => {\n            this.trackBefore(\"added\", el);\n            return el;\n          },\n          onNodeAdded: el => {\n            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              externalFormTriggered = el;\n            }\n\n            dom_default.discardError(targetContainer, el, phxFeedbackFor);\n\n            if (dom_default.isPhxChild(el) && view.ownsElement(el)) {\n              this.trackAfter(\"phxChildAdded\", el);\n            }\n\n            added.push(el);\n          },\n          onNodeDiscarded: el => {\n            if (dom_default.isPhxChild(el)) {\n              liveSocket.destroyViewByEl(el);\n            }\n\n            this.trackAfter(\"discarded\", el);\n          },\n          onBeforeNodeDiscarded: el => {\n            if (el.getAttribute && el.getAttribute(PHX_REMOVE) !== null) {\n              return true;\n            }\n\n            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, [\"append\", \"prepend\"]) && el.id) {\n              return false;\n            }\n\n            if (this.skipCIDSibling(el)) {\n              return false;\n            }\n\n            return true;\n          },\n          onElUpdated: el => {\n            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              externalFormTriggered = el;\n            }\n\n            updates.push(el);\n          },\n          onBeforeElUpdated: (fromEl, toEl) => {\n            dom_default.cleanChildNodes(toEl, phxUpdate);\n\n            if (this.skipCIDSibling(toEl)) {\n              return false;\n            }\n\n            if (dom_default.isIgnored(fromEl, phxUpdate)) {\n              this.trackBefore(\"updated\", fromEl, toEl);\n              dom_default.mergeAttrs(fromEl, toEl, {\n                isIgnored: true\n              });\n              updates.push(fromEl);\n              return false;\n            }\n\n            if (fromEl.type === \"number\" && fromEl.validity && fromEl.validity.badInput) {\n              return false;\n            }\n\n            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {\n              if (dom_default.isUploadInput(fromEl)) {\n                this.trackBefore(\"updated\", fromEl, toEl);\n                updates.push(fromEl);\n              }\n\n              return false;\n            }\n\n            if (dom_default.isPhxChild(toEl)) {\n              let prevSession = fromEl.getAttribute(PHX_SESSION);\n              dom_default.mergeAttrs(fromEl, toEl, {\n                exclude: [PHX_STATIC]\n              });\n\n              if (prevSession !== \"\") {\n                fromEl.setAttribute(PHX_SESSION, prevSession);\n              }\n\n              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);\n              return false;\n            }\n\n            dom_default.copyPrivates(toEl, fromEl);\n            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);\n            dom_default.syncPropsToAttrs(toEl);\n            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);\n\n            if (isFocusedFormEl && !this.forceFocusedSelectUpdate(fromEl, toEl)) {\n              this.trackBefore(\"updated\", fromEl, toEl);\n              dom_default.mergeFocusedInput(fromEl, toEl);\n              dom_default.syncAttrsToProps(fromEl);\n              updates.push(fromEl);\n              return false;\n            } else {\n              if (dom_default.isPhxUpdate(toEl, phxUpdate, [\"append\", \"prepend\"])) {\n                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));\n              }\n\n              dom_default.syncAttrsToProps(toEl);\n              this.trackBefore(\"updated\", fromEl, toEl);\n              return true;\n            }\n          }\n        });\n      });\n\n      if (liveSocket.isDebugEnabled()) {\n        detectDuplicateIds();\n      }\n\n      if (appendPrependUpdates.length > 0) {\n        liveSocket.time(\"post-morph append/prepend restoration\", () => {\n          appendPrependUpdates.forEach(update => update.perform());\n        });\n      }\n\n      liveSocket.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));\n      dom_default.dispatchEvent(document, \"phx:update\");\n      added.forEach(el => this.trackAfter(\"added\", el));\n      updates.forEach(el => this.trackAfter(\"updated\", el));\n\n      if (externalFormTriggered) {\n        liveSocket.disconnect();\n        externalFormTriggered.submit();\n      }\n\n      return true;\n    }\n\n    forceFocusedSelectUpdate(fromEl, toEl) {\n      let isSelect = [\"select\", \"select-one\", \"select-multiple\"].find(t => t === fromEl.type);\n      return fromEl.multiple === true || isSelect && fromEl.innerHTML != toEl.innerHTML;\n    }\n\n    isCIDPatch() {\n      return this.cidPatch;\n    }\n\n    skipCIDSibling(el) {\n      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;\n    }\n\n    targetCIDContainer(html) {\n      if (!this.isCIDPatch()) {\n        return;\n      }\n\n      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);\n\n      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {\n        return first;\n      } else {\n        return first && first.parentNode;\n      }\n    }\n\n    buildDiffHTML(container, html, phxUpdate, targetContainer) {\n      let isCIDPatch = this.isCIDPatch();\n      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();\n\n      if (!isCIDPatch || isCIDWithSingleRoot) {\n        return html;\n      } else {\n        let diffContainer = null;\n        let template = document.createElement(\"template\");\n        diffContainer = dom_default.cloneNode(targetContainer);\n        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);\n        template.innerHTML = html;\n        rest.forEach(el => el.remove());\n        Array.from(diffContainer.childNodes).forEach(child => {\n          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n        });\n        Array.from(template.content.childNodes).forEach(el => diffContainer.insertBefore(el, firstComponent));\n        firstComponent.remove();\n        return diffContainer.outerHTML;\n      }\n    }\n\n  }; // js/phoenix_live_view/rendered.js\n\n  var Rendered = class {\n    static extract(diff) {\n      let {\n        [REPLY]: reply,\n        [EVENTS]: events,\n        [TITLE]: title\n      } = diff;\n      delete diff[REPLY];\n      delete diff[EVENTS];\n      delete diff[TITLE];\n      return {\n        diff,\n        title,\n        reply: reply || null,\n        events: events || []\n      };\n    }\n\n    constructor(viewId, rendered) {\n      this.viewId = viewId;\n      this.rendered = {};\n      this.mergeDiff(rendered);\n    }\n\n    parentViewId() {\n      return this.viewId;\n    }\n\n    toString(onlyCids) {\n      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);\n    }\n\n    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {\n      onlyCids = onlyCids ? new Set(onlyCids) : null;\n      let output = {\n        buffer: \"\",\n        components,\n        onlyCids\n      };\n      this.toOutputBuffer(rendered, output);\n      return output.buffer;\n    }\n\n    componentCIDs(diff) {\n      return Object.keys(diff[COMPONENTS] || {}).map(i => parseInt(i));\n    }\n\n    isComponentOnlyDiff(diff) {\n      if (!diff[COMPONENTS]) {\n        return false;\n      }\n\n      return Object.keys(diff).length === 1;\n    }\n\n    getComponent(diff, cid) {\n      return diff[COMPONENTS][cid];\n    }\n\n    mergeDiff(diff) {\n      let newc = diff[COMPONENTS];\n      let cache = {};\n      delete diff[COMPONENTS];\n      this.rendered = this.mutableMerge(this.rendered, diff);\n      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};\n\n      if (newc) {\n        let oldc = this.rendered[COMPONENTS];\n\n        for (let cid in newc) {\n          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);\n        }\n\n        for (var key in newc) {\n          oldc[key] = newc[key];\n        }\n\n        diff[COMPONENTS] = newc;\n      }\n    }\n\n    cachedFindComponent(cid, cdiff, oldc, newc, cache) {\n      if (cache[cid]) {\n        return cache[cid];\n      } else {\n        let ndiff,\n            stat,\n            scid = cdiff[STATIC];\n\n        if (isCid(scid)) {\n          let tdiff;\n\n          if (scid > 0) {\n            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);\n          } else {\n            tdiff = oldc[-scid];\n          }\n\n          stat = tdiff[STATIC];\n          ndiff = this.cloneMerge(tdiff, cdiff);\n          ndiff[STATIC] = stat;\n        } else {\n          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);\n        }\n\n        cache[cid] = ndiff;\n        return ndiff;\n      }\n    }\n\n    mutableMerge(target, source) {\n      if (source[STATIC] !== void 0) {\n        return source;\n      } else {\n        this.doMutableMerge(target, source);\n        return target;\n      }\n    }\n\n    doMutableMerge(target, source) {\n      for (let key in source) {\n        let val = source[key];\n        let targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n          this.doMutableMerge(targetVal, val);\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n\n    cloneMerge(target, source) {\n      let merged = __spreadValues(__spreadValues({}, target), source);\n\n      for (let key in merged) {\n        let val = source[key];\n        let targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n          merged[key] = this.cloneMerge(targetVal, val);\n        }\n      }\n\n      return merged;\n    }\n\n    componentToString(cid) {\n      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);\n    }\n\n    pruneCIDs(cids) {\n      cids.forEach(cid => delete this.rendered[COMPONENTS][cid]);\n    }\n\n    get() {\n      return this.rendered;\n    }\n\n    isNewFingerprint(diff = {}) {\n      return !!diff[STATIC];\n    }\n\n    toOutputBuffer(rendered, output) {\n      if (rendered[DYNAMICS]) {\n        return this.comprehensionToBuffer(rendered, output);\n      }\n\n      let {\n        [STATIC]: statics\n      } = rendered;\n      output.buffer += statics[0];\n\n      for (let i = 1; i < statics.length; i++) {\n        this.dynamicToBuffer(rendered[i - 1], output);\n        output.buffer += statics[i];\n      }\n    }\n\n    comprehensionToBuffer(rendered, output) {\n      let {\n        [DYNAMICS]: dynamics,\n        [STATIC]: statics\n      } = rendered;\n\n      for (let d = 0; d < dynamics.length; d++) {\n        let dynamic = dynamics[d];\n        output.buffer += statics[0];\n\n        for (let i = 1; i < statics.length; i++) {\n          this.dynamicToBuffer(dynamic[i - 1], output);\n          output.buffer += statics[i];\n        }\n      }\n    }\n\n    dynamicToBuffer(rendered, output) {\n      if (typeof rendered === \"number\") {\n        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);\n      } else if (isObject(rendered)) {\n        this.toOutputBuffer(rendered, output);\n      } else {\n        output.buffer += rendered;\n      }\n    }\n\n    recursiveCIDToString(components, cid, onlyCids) {\n      let component = components[cid] || logError(`no component for CID ${cid}`, components);\n      let template = document.createElement(\"template\");\n      template.innerHTML = this.recursiveToString(component, components, onlyCids);\n      let container = template.content;\n      let skip = onlyCids && !onlyCids.has(cid);\n      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          if (child.getAttribute(PHX_COMPONENT)) {\n            return [hasNodes, true];\n          }\n\n          child.setAttribute(PHX_COMPONENT, cid);\n\n          if (!child.id) {\n            child.id = `${this.parentViewId()}-${cid}-${i}`;\n          }\n\n          if (skip) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n\n          return [true, hasComponents];\n        } else {\n          if (child.nodeValue.trim() !== \"\") {\n            logError(`only HTML element tags are allowed at the root of components.\n\ngot: \"${child.nodeValue.trim()}\"\n\nwithin:\n`, template.innerHTML.trim());\n            child.replaceWith(this.createSpan(child.nodeValue, cid));\n            return [true, hasComponents];\n          } else {\n            child.remove();\n            return [hasNodes, hasComponents];\n          }\n        }\n      }, [false, false]);\n\n      if (!hasChildNodes && !hasChildComponents) {\n        logError(\"expected at least one HTML element tag inside a component, but the component is empty:\\n\", template.innerHTML.trim());\n        return this.createSpan(\"\", cid).outerHTML;\n      } else if (!hasChildNodes && hasChildComponents) {\n        logError(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", template.innerHTML.trim());\n        return template.innerHTML;\n      } else {\n        return template.innerHTML;\n      }\n    }\n\n    createSpan(text, cid) {\n      let span = document.createElement(\"span\");\n      span.innerText = text;\n      span.setAttribute(PHX_COMPONENT, cid);\n      return span;\n    }\n\n  }; // js/phoenix_live_view/view_hook.js\n\n  var viewHookID = 1;\n  var ViewHook = class {\n    static makeID() {\n      return viewHookID++;\n    }\n\n    static elementID(el) {\n      return el.phxHookId;\n    }\n\n    constructor(view, el, callbacks) {\n      this.__view = view;\n      this.__liveSocket = view.liveSocket;\n      this.__callbacks = callbacks;\n      this.__listeners = new Set();\n      this.__isDisconnected = false;\n      this.el = el;\n      this.el.phxHookId = this.constructor.makeID();\n\n      for (let key in this.__callbacks) {\n        this[key] = this.__callbacks[key];\n      }\n    }\n\n    __mounted() {\n      this.mounted && this.mounted();\n    }\n\n    __updated() {\n      this.updated && this.updated();\n    }\n\n    __beforeUpdate() {\n      this.beforeUpdate && this.beforeUpdate();\n    }\n\n    __destroyed() {\n      this.destroyed && this.destroyed();\n    }\n\n    __reconnected() {\n      if (this.__isDisconnected) {\n        this.__isDisconnected = false;\n        this.reconnected && this.reconnected();\n      }\n    }\n\n    __disconnected() {\n      this.__isDisconnected = true;\n      this.disconnected && this.disconnected();\n    }\n\n    pushEvent(event, payload = {}, onReply = function () {}) {\n      return this.__view.pushHookEvent(null, event, payload, onReply);\n    }\n\n    pushEventTo(phxTarget, event, payload = {}, onReply = function () {}) {\n      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {\n        return view.pushHookEvent(targetCtx, event, payload, onReply);\n      });\n    }\n\n    handleEvent(event, callback) {\n      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);\n\n      window.addEventListener(`phx:hook:${event}`, callbackRef);\n\n      this.__listeners.add(callbackRef);\n\n      return callbackRef;\n    }\n\n    removeHandleEvent(callbackRef) {\n      let event = callbackRef(null, true);\n      window.removeEventListener(`phx:hook:${event}`, callbackRef);\n\n      this.__listeners.delete(callbackRef);\n    }\n\n    upload(name, files) {\n      return this.__view.dispatchUploads(name, files);\n    }\n\n    uploadTo(phxTarget, name, files) {\n      return this.__view.withinTargets(phxTarget, view => view.dispatchUploads(name, files));\n    }\n\n    __cleanup__() {\n      this.__listeners.forEach(callbackRef => this.removeHandleEvent(callbackRef));\n    }\n\n  }; // js/phoenix_live_view/view.js\n\n  var serializeForm = (form, meta = {}) => {\n    let formData = new FormData(form);\n    let toRemove = [];\n    formData.forEach((val, key, _index) => {\n      if (val instanceof File) {\n        toRemove.push(key);\n      }\n    });\n    toRemove.forEach(key => formData.delete(key));\n    let params = new URLSearchParams();\n\n    for (let [key, val] of formData.entries()) {\n      params.append(key, val);\n    }\n\n    for (let metaKey in meta) {\n      params.append(metaKey, meta[metaKey]);\n    }\n\n    return params.toString();\n  };\n\n  var View = class {\n    constructor(el, liveSocket, parentView, flash) {\n      this.liveSocket = liveSocket;\n      this.flash = flash;\n      this.parent = parentView;\n      this.root = parentView ? parentView.root : this;\n      this.el = el;\n      this.id = this.el.id;\n      this.ref = 0;\n      this.childJoins = 0;\n      this.loaderTimer = null;\n      this.pendingDiffs = [];\n      this.pruningCIDs = [];\n      this.redirect = false;\n      this.href = null;\n      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;\n      this.joinPending = true;\n      this.destroyed = false;\n\n      this.joinCallback = function () {};\n\n      this.stopCallback = function () {};\n\n      this.pendingJoinOps = this.parent ? null : [];\n      this.viewHooks = {};\n      this.uploaders = {};\n      this.formSubmits = [];\n      this.children = this.parent ? null : {};\n      this.root.children[this.id] = {};\n      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {\n        return {\n          redirect: this.redirect ? this.href : void 0,\n          url: this.redirect ? void 0 : this.href || void 0,\n          params: this.connectParams(),\n          session: this.getSession(),\n          static: this.getStatic(),\n          flash: this.flash\n        };\n      });\n      this.showLoader(this.liveSocket.loaderTimeout);\n      this.bindChannel();\n    }\n\n    setHref(href) {\n      this.href = href;\n    }\n\n    setRedirect(href) {\n      this.redirect = true;\n      this.href = href;\n    }\n\n    isMain() {\n      return this.liveSocket.main === this;\n    }\n\n    connectParams() {\n      let params = this.liveSocket.params(this.el);\n      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map(node => node.src || node.href).filter(url => typeof url === \"string\");\n\n      if (manifest.length > 0) {\n        params[\"_track_static\"] = manifest;\n      }\n\n      params[\"_mounts\"] = this.joinCount;\n      return params;\n    }\n\n    isConnected() {\n      return this.channel.canPush();\n    }\n\n    getSession() {\n      return this.el.getAttribute(PHX_SESSION);\n    }\n\n    getStatic() {\n      let val = this.el.getAttribute(PHX_STATIC);\n      return val === \"\" ? null : val;\n    }\n\n    destroy(callback = function () {}) {\n      this.destroyAllChildren();\n      this.destroyed = true;\n      delete this.root.children[this.id];\n\n      if (this.parent) {\n        delete this.root.children[this.parent.id][this.id];\n      }\n\n      clearTimeout(this.loaderTimer);\n\n      let onFinished = () => {\n        callback();\n\n        for (let id in this.viewHooks) {\n          this.destroyHook(this.viewHooks[id]);\n        }\n      };\n\n      dom_default.markPhxChildDestroyed(this.el);\n      this.log(\"destroyed\", () => [\"the child has been removed from the parent\"]);\n      this.channel.leave().receive(\"ok\", onFinished).receive(\"error\", onFinished).receive(\"timeout\", onFinished);\n    }\n\n    setContainerClasses(...classes) {\n      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n      this.el.classList.add(...classes);\n    }\n\n    isLoading() {\n      return this.el.classList.contains(PHX_DISCONNECTED_CLASS);\n    }\n\n    showLoader(timeout) {\n      clearTimeout(this.loaderTimer);\n\n      if (timeout) {\n        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);\n      } else {\n        for (let id in this.viewHooks) {\n          this.viewHooks[id].__disconnected();\n        }\n\n        this.setContainerClasses(PHX_DISCONNECTED_CLASS);\n      }\n    }\n\n    hideLoader() {\n      clearTimeout(this.loaderTimer);\n      this.setContainerClasses(PHX_CONNECTED_CLASS);\n    }\n\n    triggerReconnected() {\n      for (let id in this.viewHooks) {\n        this.viewHooks[id].__reconnected();\n      }\n    }\n\n    log(kind, msgCallback) {\n      this.liveSocket.log(this, kind, msgCallback);\n    }\n\n    withinTargets(phxTarget, callback) {\n      if (phxTarget instanceof HTMLElement) {\n        return this.liveSocket.owner(phxTarget, view => callback(view, phxTarget));\n      }\n\n      if (/^(0|[1-9]\\d*)$/.test(phxTarget)) {\n        let targets = dom_default.findComponentNodeList(this.el, phxTarget);\n\n        if (targets.length === 0) {\n          logError(`no component found matching phx-target of ${phxTarget}`);\n        } else {\n          callback(this, targets[0]);\n        }\n      } else {\n        let targets = Array.from(document.querySelectorAll(phxTarget));\n\n        if (targets.length === 0) {\n          logError(`nothing found matching the phx-target selector \"${phxTarget}\"`);\n        }\n\n        targets.forEach(target => this.liveSocket.owner(target, view => callback(view, target)));\n      }\n    }\n\n    applyDiff(type, rawDiff, callback) {\n      this.log(type, () => [\"\", clone(rawDiff)]);\n      let {\n        diff,\n        reply,\n        events,\n        title\n      } = Rendered.extract(rawDiff);\n\n      if (title) {\n        dom_default.putTitle(title);\n      }\n\n      callback({\n        diff,\n        reply,\n        events\n      });\n      return reply;\n    }\n\n    onJoin(resp) {\n      let {\n        rendered,\n        container\n      } = resp;\n\n      if (container) {\n        let [tag, attrs] = container;\n        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);\n      }\n\n      this.childJoins = 0;\n      this.joinPending = true;\n      this.flash = null;\n      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);\n      this.applyDiff(\"mount\", rendered, ({\n        diff,\n        events\n      }) => {\n        this.rendered = new Rendered(this.id, diff);\n        let html = this.renderContainer(null, \"join\");\n        this.dropPendingRefs();\n        let forms = this.formsForRecovery(html);\n        this.joinCount++;\n\n        if (forms.length > 0) {\n          forms.forEach(([form, newForm, newCid], i) => {\n            this.pushFormRecovery(form, newCid, resp2 => {\n              if (i === forms.length - 1) {\n                this.onJoinComplete(resp2, html, events);\n              }\n            });\n          });\n        } else {\n          this.onJoinComplete(resp, html, events);\n        }\n      });\n    }\n\n    dropPendingRefs() {\n      dom_default.all(this.el, `[${PHX_REF}]`, el => el.removeAttribute(PHX_REF));\n    }\n\n    onJoinComplete({\n      live_patch\n    }, html, events) {\n      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {\n        return this.applyJoinPatch(live_patch, html, events);\n      }\n\n      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter(toEl => {\n        let fromEl = toEl.id && this.el.querySelector(`[id=\"${toEl.id}\"]`);\n        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);\n\n        if (phxStatic) {\n          toEl.setAttribute(PHX_STATIC, phxStatic);\n        }\n\n        return this.joinChild(toEl);\n      });\n\n      if (newChildren.length === 0) {\n        if (this.parent) {\n          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n          this.applyJoinPatch(live_patch, html, events);\n        }\n      } else {\n        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\n      }\n    }\n\n    attachTrueDocEl() {\n      this.el = dom_default.byId(this.id);\n      this.el.setAttribute(PHX_ROOT_ID, this.root.id);\n    }\n\n    dispatchEvents(events) {\n      events.forEach(([event, payload]) => {\n        window.dispatchEvent(new CustomEvent(`phx:hook:${event}`, {\n          detail: payload\n        }));\n      });\n    }\n\n    applyJoinPatch(live_patch, html, events) {\n      this.attachTrueDocEl();\n      let patch = new DOMPatch(this, this.el, this.id, html, null);\n      patch.markPrunableContentForRemoval();\n      this.performPatch(patch, false);\n      this.joinNewChildren();\n      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, hookEl => {\n        let hook = this.addHook(hookEl);\n\n        if (hook) {\n          hook.__mounted();\n        }\n      });\n      this.joinPending = false;\n      this.dispatchEvents(events);\n      this.applyPendingUpdates();\n\n      if (live_patch) {\n        let {\n          kind,\n          to\n        } = live_patch;\n        this.liveSocket.historyPatch(to, kind);\n      }\n\n      this.hideLoader();\n\n      if (this.joinCount > 1) {\n        this.triggerReconnected();\n      }\n\n      this.stopCallback();\n    }\n\n    triggerBeforeUpdateHook(fromEl, toEl) {\n      this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [fromEl, toEl]);\n      let hook = this.getHook(fromEl);\n      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));\n\n      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {\n        hook.__beforeUpdate();\n\n        return hook;\n      }\n    }\n\n    performPatch(patch, pruneCids) {\n      let destroyedCIDs = [];\n      let phxChildrenAdded = false;\n      let updatedHookIds = new Set();\n      patch.after(\"added\", el => {\n        this.liveSocket.triggerDOM(\"onNodeAdded\", [el]);\n        let newHook = this.addHook(el);\n\n        if (newHook) {\n          newHook.__mounted();\n        }\n      });\n      patch.after(\"phxChildAdded\", _el => phxChildrenAdded = true);\n      patch.before(\"updated\", (fromEl, toEl) => {\n        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);\n\n        if (hook) {\n          updatedHookIds.add(fromEl.id);\n        }\n      });\n      patch.after(\"updated\", el => {\n        if (updatedHookIds.has(el.id)) {\n          this.getHook(el).__updated();\n        }\n      });\n      patch.after(\"discarded\", el => {\n        let cid = this.componentID(el);\n\n        if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {\n          destroyedCIDs.push(cid);\n        }\n\n        let hook = this.getHook(el);\n        hook && this.destroyHook(hook);\n      });\n      patch.perform();\n\n      if (pruneCids) {\n        this.maybePushComponentsDestroyed(destroyedCIDs);\n      }\n\n      return phxChildrenAdded;\n    }\n\n    joinNewChildren() {\n      dom_default.findPhxChildren(this.el, this.id).forEach(el => this.joinChild(el));\n    }\n\n    getChildById(id) {\n      return this.root.children[this.id][id];\n    }\n\n    getDescendentByEl(el) {\n      if (el.id === this.id) {\n        return this;\n      } else {\n        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];\n      }\n    }\n\n    destroyDescendent(id) {\n      for (let parentId in this.root.children) {\n        for (let childId in this.root.children[parentId]) {\n          if (childId === id) {\n            return this.root.children[parentId][childId].destroy();\n          }\n        }\n      }\n    }\n\n    joinChild(el) {\n      let child = this.getChildById(el.id);\n\n      if (!child) {\n        let view = new View(el, this.liveSocket, this);\n        this.root.children[this.id][view.id] = view;\n        view.join();\n        this.childJoins++;\n        return true;\n      }\n    }\n\n    isJoinPending() {\n      return this.joinPending;\n    }\n\n    ackJoin(_child) {\n      this.childJoins--;\n\n      if (this.childJoins === 0) {\n        if (this.parent) {\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n        }\n      }\n    }\n\n    onAllChildJoinsComplete() {\n      this.joinCallback();\n      this.pendingJoinOps.forEach(([view, op]) => {\n        if (!view.isDestroyed()) {\n          op();\n        }\n      });\n      this.pendingJoinOps = [];\n    }\n\n    update(diff, events) {\n      if (this.isJoinPending() || this.liveSocket.hasPendingLink()) {\n        return this.pendingDiffs.push({\n          diff,\n          events\n        });\n      }\n\n      this.rendered.mergeDiff(diff);\n      let phxChildrenAdded = false;\n\n      if (this.rendered.isComponentOnlyDiff(diff)) {\n        this.liveSocket.time(\"component patch complete\", () => {\n          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));\n          parentCids.forEach(parentCID => {\n            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {\n              phxChildrenAdded = true;\n            }\n          });\n        });\n      } else if (!isEmpty(diff)) {\n        this.liveSocket.time(\"full patch complete\", () => {\n          let html = this.renderContainer(diff, \"update\");\n          let patch = new DOMPatch(this, this.el, this.id, html, null);\n          phxChildrenAdded = this.performPatch(patch, true);\n        });\n      }\n\n      this.dispatchEvents(events);\n\n      if (phxChildrenAdded) {\n        this.joinNewChildren();\n      }\n    }\n\n    renderContainer(diff, kind) {\n      return this.liveSocket.time(`toString diff (${kind})`, () => {\n        let tag = this.el.tagName;\n        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;\n        let html = this.rendered.toString(cids);\n        return `<${tag}>${html}</${tag}>`;\n      });\n    }\n\n    componentPatch(diff, cid) {\n      if (isEmpty(diff)) return false;\n      let html = this.rendered.componentToString(cid);\n      let patch = new DOMPatch(this, this.el, this.id, html, cid);\n      let childrenAdded = this.performPatch(patch, true);\n      return childrenAdded;\n    }\n\n    getHook(el) {\n      return this.viewHooks[ViewHook.elementID(el)];\n    }\n\n    addHook(el) {\n      if (ViewHook.elementID(el) || !el.getAttribute) {\n        return;\n      }\n\n      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));\n\n      if (hookName && !this.ownsElement(el)) {\n        return;\n      }\n\n      let callbacks = this.liveSocket.getHookCallbacks(hookName);\n\n      if (callbacks) {\n        if (!el.id) {\n          logError(`no DOM ID for hook \"${hookName}\". Hooks require a unique ID on each element.`, el);\n        }\n\n        let hook = new ViewHook(this, el, callbacks);\n        this.viewHooks[ViewHook.elementID(hook.el)] = hook;\n        return hook;\n      } else if (hookName !== null) {\n        logError(`unknown hook found for \"${hookName}\"`, el);\n      }\n    }\n\n    destroyHook(hook) {\n      hook.__destroyed();\n\n      hook.__cleanup__();\n\n      delete this.viewHooks[ViewHook.elementID(hook.el)];\n    }\n\n    applyPendingUpdates() {\n      this.pendingDiffs.forEach(({\n        diff,\n        events\n      }) => this.update(diff, events));\n      this.pendingDiffs = [];\n    }\n\n    onChannel(event, cb) {\n      this.liveSocket.onChannel(this.channel, event, resp => {\n        if (this.isJoinPending()) {\n          this.root.pendingJoinOps.push([this, () => cb(resp)]);\n        } else {\n          cb(resp);\n        }\n      });\n    }\n\n    bindChannel() {\n      this.liveSocket.onChannel(this.channel, \"diff\", rawDiff => {\n        this.applyDiff(\"update\", rawDiff, ({\n          diff,\n          events\n        }) => this.update(diff, events));\n      });\n      this.onChannel(\"redirect\", ({\n        to,\n        flash\n      }) => this.onRedirect({\n        to,\n        flash\n      }));\n      this.onChannel(\"live_patch\", redir => this.onLivePatch(redir));\n      this.onChannel(\"live_redirect\", redir => this.onLiveRedirect(redir));\n      this.channel.onError(reason => this.onError(reason));\n      this.channel.onClose(reason => this.onClose(reason));\n    }\n\n    destroyAllChildren() {\n      for (let id in this.root.children[this.id]) {\n        this.getChildById(id).destroy();\n      }\n    }\n\n    onLiveRedirect(redir) {\n      let {\n        to,\n        kind,\n        flash\n      } = redir;\n      let url = this.expandURL(to);\n      this.liveSocket.historyRedirect(url, kind, flash);\n    }\n\n    onLivePatch(redir) {\n      let {\n        to,\n        kind\n      } = redir;\n      this.href = this.expandURL(to);\n      this.liveSocket.historyPatch(to, kind);\n    }\n\n    expandURL(to) {\n      return to.startsWith(\"/\") ? `${window.location.protocol}//${window.location.host}${to}` : to;\n    }\n\n    onRedirect({\n      to,\n      flash\n    }) {\n      this.liveSocket.redirect(to, flash);\n    }\n\n    isDestroyed() {\n      return this.destroyed;\n    }\n\n    join(callback) {\n      if (!this.parent) {\n        this.stopCallback = this.liveSocket.withPageLoading({\n          to: this.href,\n          kind: \"initial\"\n        });\n      }\n\n      this.joinCallback = () => callback && callback(this.joinCount);\n\n      this.liveSocket.wrapPush(this, {\n        timeout: false\n      }, () => {\n        return this.channel.join().receive(\"ok\", data => !this.isDestroyed() && this.onJoin(data)).receive(\"error\", resp => !this.isDestroyed() && this.onJoinError(resp)).receive(\"timeout\", () => !this.isDestroyed() && this.onJoinError({\n          reason: \"timeout\"\n        }));\n      });\n    }\n\n    onJoinError(resp) {\n      if (resp.reason === \"unauthorized\" || resp.reason === \"stale\") {\n        this.log(\"error\", () => [\"unauthorized live_redirect. Falling back to page request\", resp]);\n        return this.onRedirect({\n          to: this.href\n        });\n      }\n\n      if (resp.redirect || resp.live_redirect) {\n        this.joinPending = false;\n        this.channel.leave();\n      }\n\n      if (resp.redirect) {\n        return this.onRedirect(resp.redirect);\n      }\n\n      if (resp.live_redirect) {\n        return this.onLiveRedirect(resp.live_redirect);\n      }\n\n      this.log(\"error\", () => [\"unable to join\", resp]);\n      return this.liveSocket.reloadWithJitter(this);\n    }\n\n    onClose(reason) {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      if (this.isJoinPending() && document.visibilityState !== \"hidden\" || this.liveSocket.hasPendingLink() && reason !== \"leave\") {\n        return this.liveSocket.reloadWithJitter(this);\n      }\n\n      this.destroyAllChildren();\n      this.liveSocket.dropActiveElement(this);\n\n      if (document.activeElement) {\n        document.activeElement.blur();\n      }\n\n      if (this.liveSocket.isUnloaded()) {\n        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\n      }\n    }\n\n    onError(reason) {\n      this.onClose(reason);\n      this.log(\"error\", () => [\"view crashed\", reason]);\n\n      if (!this.liveSocket.isUnloaded()) {\n        this.displayError();\n      }\n    }\n\n    displayError() {\n      if (this.isMain()) {\n        dom_default.dispatchEvent(window, \"phx:page-loading-start\", {\n          to: this.href,\n          kind: \"error\"\n        });\n      }\n\n      this.showLoader();\n      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n    }\n\n    pushWithReply(refGenerator, event, payload, onReply = function () {}) {\n      if (!this.isConnected()) {\n        return;\n      }\n\n      let [ref, [el]] = refGenerator ? refGenerator() : [null, []];\n\n      let onLoadingDone = function () {};\n\n      if (el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {\n        onLoadingDone = this.liveSocket.withPageLoading({\n          kind: \"element\",\n          target: el\n        });\n      }\n\n      if (typeof payload.cid !== \"number\") {\n        delete payload.cid;\n      }\n\n      return this.liveSocket.wrapPush(this, {\n        timeout: true\n      }, () => {\n        return this.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", resp => {\n          let hookReply = null;\n\n          if (ref !== null) {\n            this.undoRefs(ref);\n          }\n\n          if (resp.diff) {\n            hookReply = this.applyDiff(\"update\", resp.diff, ({\n              diff,\n              events\n            }) => {\n              this.update(diff, events);\n            });\n          }\n\n          if (resp.redirect) {\n            this.onRedirect(resp.redirect);\n          }\n\n          if (resp.live_patch) {\n            this.onLivePatch(resp.live_patch);\n          }\n\n          if (resp.live_redirect) {\n            this.onLiveRedirect(resp.live_redirect);\n          }\n\n          onLoadingDone();\n          onReply(resp, hookReply);\n        });\n      });\n    }\n\n    undoRefs(ref) {\n      dom_default.all(this.el, `[${PHX_REF}=\"${ref}\"]`, el => {\n        let disabledVal = el.getAttribute(PHX_DISABLED);\n        el.removeAttribute(PHX_REF);\n\n        if (el.getAttribute(PHX_READONLY) !== null) {\n          el.readOnly = false;\n          el.removeAttribute(PHX_READONLY);\n        }\n\n        if (disabledVal !== null) {\n          el.disabled = disabledVal === \"true\" ? true : false;\n          el.removeAttribute(PHX_DISABLED);\n        }\n\n        PHX_EVENT_CLASSES.forEach(className => dom_default.removeClass(el, className));\n        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);\n\n        if (disableRestore !== null) {\n          el.innerText = disableRestore;\n          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);\n        }\n\n        let toEl = dom_default.private(el, PHX_REF);\n\n        if (toEl) {\n          let hook = this.triggerBeforeUpdateHook(el, toEl);\n          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());\n\n          if (hook) {\n            hook.__updated();\n          }\n\n          dom_default.deletePrivate(el, PHX_REF);\n        }\n      });\n    }\n\n    putRef(elements, event) {\n      let newRef = this.ref++;\n      let disableWith = this.binding(PHX_DISABLE_WITH);\n      elements.forEach(el => {\n        el.classList.add(`phx-${event}-loading`);\n        el.setAttribute(PHX_REF, newRef);\n        let disableText = el.getAttribute(disableWith);\n\n        if (disableText !== null) {\n          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {\n            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);\n          }\n\n          el.innerText = disableText;\n        }\n      });\n      return [newRef, elements];\n    }\n\n    componentID(el) {\n      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);\n      return cid ? parseInt(cid) : null;\n    }\n\n    targetComponentID(target, targetCtx) {\n      if (target.getAttribute(this.binding(\"target\"))) {\n        return this.closestComponentID(targetCtx);\n      } else {\n        return null;\n      }\n    }\n\n    closestComponentID(targetCtx) {\n      if (targetCtx) {\n        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), el => this.ownsElement(el) && this.componentID(el));\n      } else {\n        return null;\n      }\n    }\n\n    pushHookEvent(targetCtx, event, payload, onReply) {\n      if (!this.isConnected()) {\n        this.log(\"hook\", () => [\"unable to push hook event. LiveView not connected\", event, payload]);\n        return false;\n      }\n\n      let [ref, els] = this.putRef([], \"hook\");\n      this.pushWithReply(() => [ref, els], \"event\", {\n        type: \"hook\",\n        event,\n        value: payload,\n        cid: this.closestComponentID(targetCtx)\n      }, (resp, reply) => onReply(reply, ref));\n      return ref;\n    }\n\n    extractMeta(el, meta) {\n      let prefix = this.binding(\"value-\");\n\n      for (let i = 0; i < el.attributes.length; i++) {\n        let name = el.attributes[i].name;\n\n        if (name.startsWith(prefix)) {\n          meta[name.replace(prefix, \"\")] = el.getAttribute(name);\n        }\n      }\n\n      if (el.value !== void 0) {\n        meta.value = el.value;\n\n        if (el.tagName === \"INPUT\" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {\n          delete meta.value;\n        }\n      }\n\n      return meta;\n    }\n\n    pushEvent(type, el, targetCtx, phxEvent, meta) {\n      this.pushWithReply(() => this.putRef([el], type), \"event\", {\n        type,\n        event: phxEvent,\n        value: this.extractMeta(el, meta),\n        cid: this.targetComponentID(el, targetCtx)\n      });\n    }\n\n    pushKey(keyElement, targetCtx, kind, phxEvent, meta) {\n      this.pushWithReply(() => this.putRef([keyElement], kind), \"event\", {\n        type: kind,\n        event: phxEvent,\n        value: this.extractMeta(keyElement, meta),\n        cid: this.targetComponentID(keyElement, targetCtx)\n      });\n    }\n\n    pushFileProgress(fileEl, entryRef, progress, onReply = function () {}) {\n      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {\n        view.pushWithReply(null, \"progress\", {\n          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),\n          ref: fileEl.getAttribute(PHX_UPLOAD_REF),\n          entry_ref: entryRef,\n          progress,\n          cid: view.targetComponentID(fileEl.form, targetCtx)\n        }, onReply);\n      });\n    }\n\n    pushInput(inputEl, targetCtx, forceCid, phxEvent, eventTarget, callback) {\n      let uploads;\n      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);\n\n      let refGenerator = () => this.putRef([inputEl, inputEl.form], \"change\");\n\n      let formData = serializeForm(inputEl.form, {\n        _target: eventTarget.name\n      });\n\n      if (inputEl.files && inputEl.files.length > 0) {\n        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));\n      }\n\n      uploads = LiveUploader.serializeUploads(inputEl);\n      let event = {\n        type: \"form\",\n        event: phxEvent,\n        value: formData,\n        uploads,\n        cid\n      };\n      this.pushWithReply(refGenerator, \"event\", event, resp => {\n        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));\n\n        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute(\"data-phx-auto-upload\") !== null) {\n          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {\n            let [ref, _els] = refGenerator();\n            this.uploadFiles(inputEl.form, targetCtx, ref, cid, _uploads => {\n              callback && callback(resp);\n              this.triggerAwaitingSubmit(inputEl.form);\n            });\n          }\n        } else {\n          callback && callback(resp);\n        }\n      });\n    }\n\n    triggerAwaitingSubmit(formEl) {\n      let awaitingSubmit = this.getScheduledSubmit(formEl);\n\n      if (awaitingSubmit) {\n        let [_el, _ref, callback] = awaitingSubmit;\n        this.cancelSubmit(formEl);\n        callback();\n      }\n    }\n\n    getScheduledSubmit(formEl) {\n      return this.formSubmits.find(([el, _callback]) => el.isSameNode(formEl));\n    }\n\n    scheduleSubmit(formEl, ref, callback) {\n      if (this.getScheduledSubmit(formEl)) {\n        return true;\n      }\n\n      this.formSubmits.push([formEl, ref, callback]);\n    }\n\n    cancelSubmit(formEl) {\n      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {\n        if (el.isSameNode(formEl)) {\n          this.undoRefs(ref);\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n\n    pushFormSubmit(formEl, targetCtx, phxEvent, onReply) {\n      let filterIgnored = el => {\n        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);\n        return !(userIgnored || closestPhxBinding(el, \"data-phx-update=ignore\", el.form));\n      };\n\n      let filterDisables = el => {\n        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));\n      };\n\n      let filterButton = el => el.tagName == \"BUTTON\";\n\n      let filterInput = el => [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(el.tagName);\n\n      let refGenerator = () => {\n        let formElements = Array.from(formEl.elements);\n        let disables = formElements.filter(filterDisables);\n        let buttons = formElements.filter(filterButton).filter(filterIgnored);\n        let inputs = formElements.filter(filterInput).filter(filterIgnored);\n        buttons.forEach(button => {\n          button.setAttribute(PHX_DISABLED, button.disabled);\n          button.disabled = true;\n        });\n        inputs.forEach(input => {\n          input.setAttribute(PHX_READONLY, input.readOnly);\n          input.readOnly = true;\n\n          if (input.files) {\n            input.setAttribute(PHX_DISABLED, input.disabled);\n            input.disabled = true;\n          }\n        });\n        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), \"\");\n        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), \"submit\");\n      };\n\n      let cid = this.targetComponentID(formEl, targetCtx);\n\n      if (LiveUploader.hasUploadsInProgress(formEl)) {\n        let [ref, _els] = refGenerator();\n        return this.scheduleSubmit(formEl, ref, () => this.pushFormSubmit(formEl, targetCtx, phxEvent, onReply));\n      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\n        let [ref, els] = refGenerator();\n\n        let proxyRefGen = () => [ref, els];\n\n        this.uploadFiles(formEl, targetCtx, ref, cid, _uploads => {\n          let formData = serializeForm(formEl, {});\n          this.pushWithReply(proxyRefGen, \"event\", {\n            type: \"form\",\n            event: phxEvent,\n            value: formData,\n            cid\n          }, onReply);\n        });\n      } else {\n        let formData = serializeForm(formEl);\n        this.pushWithReply(refGenerator, \"event\", {\n          type: \"form\",\n          event: phxEvent,\n          value: formData,\n          cid\n        }, onReply);\n      }\n    }\n\n    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {\n      let joinCountAtUpload = this.joinCount;\n      let inputEls = LiveUploader.activeFileInputs(formEl);\n      let numFileInputsInProgress = inputEls.length;\n      inputEls.forEach(inputEl => {\n        let uploader = new LiveUploader(inputEl, this, () => {\n          numFileInputsInProgress--;\n\n          if (numFileInputsInProgress === 0) {\n            onComplete();\n          }\n        });\n        this.uploaders[inputEl] = uploader;\n        let entries = uploader.entries().map(entry => entry.toPreflightPayload());\n        let payload = {\n          ref: inputEl.getAttribute(PHX_UPLOAD_REF),\n          entries,\n          cid: this.targetComponentID(inputEl.form, targetCtx)\n        };\n        this.log(\"upload\", () => [\"sending preflight request\", payload]);\n        this.pushWithReply(null, \"allow_upload\", payload, resp => {\n          this.log(\"upload\", () => [\"got preflight response\", resp]);\n\n          if (resp.error) {\n            this.undoRefs(ref);\n            let [entry_ref, reason] = resp.error;\n            this.log(\"upload\", () => [`error for entry ${entry_ref}`, reason]);\n          } else {\n            let onError = callback => {\n              this.channel.onError(() => {\n                if (this.joinCount === joinCountAtUpload) {\n                  callback();\n                }\n              });\n            };\n\n            uploader.initAdapterUpload(resp, onError, this.liveSocket);\n          }\n        });\n      });\n    }\n\n    dispatchUploads(name, filesOrBlobs) {\n      let inputs = dom_default.findUploadInputs(this.el).filter(el => el.name === name);\n\n      if (inputs.length === 0) {\n        logError(`no live file inputs found matching the name \"${name}\"`);\n      } else if (inputs.length > 1) {\n        logError(`duplicate live file inputs found matching the name \"${name}\"`);\n      } else {\n        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, {\n          files: filesOrBlobs\n        });\n      }\n    }\n\n    pushFormRecovery(form, newCid, callback) {\n      this.liveSocket.withinOwners(form, (view, targetCtx) => {\n        let input = form.elements[0];\n        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding(\"change\"));\n        view.pushInput(input, targetCtx, newCid, phxEvent, input, callback);\n      });\n    }\n\n    pushLinkPatch(href, targetEl, callback) {\n      let linkRef = this.liveSocket.setPendingLink(href);\n      let refGen = targetEl ? () => this.putRef([targetEl], \"click\") : null;\n      this.pushWithReply(refGen, \"live_patch\", {\n        url: href\n      }, resp => {\n        if (resp.link_redirect) {\n          this.liveSocket.replaceMain(href, null, callback, linkRef);\n        } else {\n          if (this.liveSocket.commitPendingLink(linkRef)) {\n            this.href = href;\n          }\n\n          this.applyPendingUpdates();\n          callback && callback(linkRef);\n        }\n      }).receive(\"timeout\", () => this.liveSocket.redirect(window.location.href));\n    }\n\n    formsForRecovery(html) {\n      if (this.joinCount === 0) {\n        return [];\n      }\n\n      let phxChange = this.binding(\"change\");\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return dom_default.all(this.el, `form[${phxChange}]`).filter(form => form.id && this.ownsElement(form)).filter(form => form.elements.length > 0).filter(form => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== \"ignore\").map(form => {\n        let newForm = template.content.querySelector(`form[id=\"${form.id}\"][${phxChange}=\"${form.getAttribute(phxChange)}\"]`);\n\n        if (newForm) {\n          return [form, newForm, this.componentID(newForm)];\n        } else {\n          return [form, null, null];\n        }\n      }).filter(([form, newForm, newCid]) => newForm);\n    }\n\n    maybePushComponentsDestroyed(destroyedCIDs) {\n      let willDestroyCIDs = destroyedCIDs.filter(cid => {\n        return dom_default.findComponentNodeList(this.el, cid).length === 0;\n      });\n\n      if (willDestroyCIDs.length > 0) {\n        this.pruningCIDs.push(...willDestroyCIDs);\n        this.pushWithReply(null, \"cids_will_destroy\", {\n          cids: willDestroyCIDs\n        }, () => {\n          this.pruningCIDs = this.pruningCIDs.filter(cid => willDestroyCIDs.indexOf(cid) !== -1);\n          let completelyDestroyCIDs = willDestroyCIDs.filter(cid => {\n            return dom_default.findComponentNodeList(this.el, cid).length === 0;\n          });\n\n          if (completelyDestroyCIDs.length > 0) {\n            this.pushWithReply(null, \"cids_destroyed\", {\n              cids: completelyDestroyCIDs\n            }, resp => {\n              this.rendered.pruneCIDs(resp.cids);\n            });\n          }\n        });\n      }\n    }\n\n    ownsElement(el) {\n      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), node => node.id) === this.id;\n    }\n\n    submitForm(form, targetCtx, phxEvent) {\n      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);\n      this.liveSocket.blurActiveElement(this);\n      this.pushFormSubmit(form, targetCtx, phxEvent, () => {\n        this.liveSocket.restorePreviouslyActiveFocus();\n      });\n    }\n\n    binding(kind) {\n      return this.liveSocket.binding(kind);\n    }\n\n  }; // js/phoenix_live_view/live_socket.js\n\n  var LiveSocket = class {\n    constructor(url, phxSocket, opts = {}) {\n      this.unloaded = false;\n\n      if (!phxSocket || phxSocket.constructor.name === \"Object\") {\n        throw new Error(`\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\n\n          import {Socket} from \"phoenix\"\n          import LiveSocket from \"phoenix_live_view\"\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n      `);\n      }\n\n      this.socket = new phxSocket(url, opts);\n      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n      this.opts = opts;\n      this.params = closure(opts.params || {});\n      this.viewLogger = opts.viewLogger;\n      this.metadataCallbacks = opts.metadata || {};\n      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});\n      this.activeElement = null;\n      this.prevActive = null;\n      this.silenced = false;\n      this.main = null;\n      this.linkRef = 1;\n      this.roots = {};\n      this.href = window.location.href;\n      this.pendingLink = null;\n      this.currentLocation = clone(window.location);\n      this.hooks = opts.hooks || {};\n      this.uploaders = opts.uploaders || {};\n      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;\n      this.localStorage = opts.localStorage || window.localStorage;\n      this.sessionStorage = opts.sessionStorage || window.sessionStorage;\n      this.boundTopLevelEvents = false;\n      this.domCallbacks = Object.assign({\n        onNodeAdded: closure(),\n        onBeforeElUpdated: closure()\n      }, opts.dom || {});\n      window.addEventListener(\"pagehide\", _e => {\n        this.unloaded = true;\n      });\n      this.socket.onOpen(() => {\n        if (this.isUnloaded()) {\n          window.location.reload();\n        }\n      });\n    }\n\n    isProfileEnabled() {\n      return this.sessionStorage.getItem(PHX_LV_PROFILE) === \"true\";\n    }\n\n    isDebugEnabled() {\n      return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"true\";\n    }\n\n    enableDebug() {\n      this.sessionStorage.setItem(PHX_LV_DEBUG, \"true\");\n    }\n\n    enableProfiling() {\n      this.sessionStorage.setItem(PHX_LV_PROFILE, \"true\");\n    }\n\n    disableDebug() {\n      this.sessionStorage.removeItem(PHX_LV_DEBUG);\n    }\n\n    disableProfiling() {\n      this.sessionStorage.removeItem(PHX_LV_PROFILE);\n    }\n\n    enableLatencySim(upperBoundMs) {\n      this.enableDebug();\n      console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\");\n      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);\n    }\n\n    disableLatencySim() {\n      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);\n    }\n\n    getLatencySim() {\n      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);\n      return str ? parseInt(str) : null;\n    }\n\n    getSocket() {\n      return this.socket;\n    }\n\n    connect() {\n      let doConnect = () => {\n        if (this.joinRootViews()) {\n          this.bindTopLevelEvents();\n          this.socket.connect();\n        }\n      };\n\n      if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n        doConnect();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", () => doConnect());\n      }\n    }\n\n    disconnect(callback) {\n      this.socket.disconnect(callback);\n    }\n\n    triggerDOM(kind, args) {\n      this.domCallbacks[kind](...args);\n    }\n\n    time(name, func) {\n      if (!this.isProfileEnabled() || !console.time) {\n        return func();\n      }\n\n      console.time(name);\n      let result = func();\n      console.timeEnd(name);\n      return result;\n    }\n\n    log(view, kind, msgCallback) {\n      if (this.viewLogger) {\n        let [msg, obj] = msgCallback();\n        this.viewLogger(view, kind, msg, obj);\n      } else if (this.isDebugEnabled()) {\n        let [msg, obj] = msgCallback();\n        debug(view, kind, msg, obj);\n      }\n    }\n\n    onChannel(channel, event, cb) {\n      channel.on(event, data => {\n        let latency = this.getLatencySim();\n\n        if (!latency) {\n          cb(data);\n        } else {\n          console.log(`simulating ${latency}ms of latency from server to client`);\n          setTimeout(() => cb(data), latency);\n        }\n      });\n    }\n\n    wrapPush(view, opts, push) {\n      let latency = this.getLatencySim();\n      let oldJoinCount = view.joinCount;\n\n      if (!latency) {\n        if (opts.timeout) {\n          return push().receive(\"timeout\", () => {\n            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {\n              this.reloadWithJitter(view, () => {\n                this.log(view, \"timeout\", () => [\"received timeout while communicating with server. Falling back to hard refresh for recovery\"]);\n              });\n            }\n          });\n        } else {\n          return push();\n        }\n      }\n\n      console.log(`simulating ${latency}ms of latency from client to server`);\n      let fakePush = {\n        receives: [],\n\n        receive(kind, cb) {\n          this.receives.push([kind, cb]);\n        }\n\n      };\n      setTimeout(() => {\n        if (view.isDestroyed()) {\n          return;\n        }\n\n        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());\n      }, latency);\n      return fakePush;\n    }\n\n    reloadWithJitter(view, log) {\n      view.destroy();\n      this.disconnect();\n      let [minMs, maxMs] = RELOAD_JITTER;\n      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, count => count + 1);\n      log ? log() : this.log(view, \"join\", () => [`encountered ${tries} consecutive reloads`]);\n\n      if (tries > MAX_RELOADS) {\n        this.log(view, \"join\", () => [`exceeded ${MAX_RELOADS} consecutive reloads. Entering failsafe mode`]);\n        afterMs = FAILSAFE_JITTER;\n      }\n\n      setTimeout(() => {\n        if (this.hasPendingLink()) {\n          window.location = this.pendingLink;\n        } else {\n          window.location.reload();\n        }\n      }, afterMs);\n    }\n\n    getHookCallbacks(name) {\n      return name && name.startsWith(\"Phoenix.\") ? hooks_default[name.split(\".\")[1]] : this.hooks[name];\n    }\n\n    isUnloaded() {\n      return this.unloaded;\n    }\n\n    isConnected() {\n      return this.socket.isConnected();\n    }\n\n    getBindingPrefix() {\n      return this.bindingPrefix;\n    }\n\n    binding(kind) {\n      return `${this.getBindingPrefix()}${kind}`;\n    }\n\n    channel(topic, params) {\n      return this.socket.channel(topic, params);\n    }\n\n    joinRootViews() {\n      let rootsFound = false;\n      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, rootEl => {\n        if (!this.getRootById(rootEl.id)) {\n          let view = this.newRootView(rootEl);\n          view.setHref(this.getHref());\n          view.join();\n\n          if (rootEl.getAttribute(PHX_MAIN)) {\n            this.main = view;\n          }\n        }\n\n        rootsFound = true;\n      });\n      return rootsFound;\n    }\n\n    redirect(to, flash) {\n      this.disconnect();\n      browser_default.redirect(to, flash);\n    }\n\n    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {\n      let oldMainEl = this.main.el;\n      let newMainEl = dom_default.cloneNode(oldMainEl, \"\");\n      this.main.showLoader(this.loaderTimeout);\n      this.main.destroy();\n      this.main = this.newRootView(newMainEl, flash);\n      this.main.setRedirect(href);\n      this.main.join(joinCount => {\n        if (joinCount === 1 && this.commitPendingLink(linkRef)) {\n          oldMainEl.replaceWith(newMainEl);\n          callback && callback();\n        }\n      });\n    }\n\n    isPhxView(el) {\n      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;\n    }\n\n    newRootView(el, flash) {\n      let view = new View(el, this, null, flash);\n      this.roots[view.id] = view;\n      return view;\n    }\n\n    owner(childEl, callback) {\n      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), el => this.getViewByEl(el));\n\n      if (view) {\n        callback(view);\n      }\n    }\n\n    withinOwners(childEl, callback) {\n      this.owner(childEl, view => {\n        let phxTarget = childEl.getAttribute(this.binding(\"target\"));\n\n        if (phxTarget === null) {\n          callback(view, childEl);\n        } else {\n          view.withinTargets(phxTarget, callback);\n        }\n      });\n    }\n\n    getViewByEl(el) {\n      let rootId = el.getAttribute(PHX_ROOT_ID);\n      return maybe(this.getRootById(rootId), root => root.getDescendentByEl(el));\n    }\n\n    getRootById(id) {\n      return this.roots[id];\n    }\n\n    destroyAllViews() {\n      for (let id in this.roots) {\n        this.roots[id].destroy();\n        delete this.roots[id];\n      }\n    }\n\n    destroyViewByEl(el) {\n      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));\n\n      if (root) {\n        root.destroyDescendent(el.id);\n      }\n    }\n\n    setActiveElement(target) {\n      if (this.activeElement === target) {\n        return;\n      }\n\n      this.activeElement = target;\n\n      let cancel = () => {\n        if (target === this.activeElement) {\n          this.activeElement = null;\n        }\n\n        target.removeEventListener(\"mouseup\", this);\n        target.removeEventListener(\"touchend\", this);\n      };\n\n      target.addEventListener(\"mouseup\", cancel);\n      target.addEventListener(\"touchend\", cancel);\n    }\n\n    getActiveElement() {\n      if (document.activeElement === document.body) {\n        return this.activeElement || document.activeElement;\n      } else {\n        return document.activeElement || document.body;\n      }\n    }\n\n    dropActiveElement(view) {\n      if (this.prevActive && view.ownsElement(this.prevActive)) {\n        this.prevActive = null;\n      }\n    }\n\n    restorePreviouslyActiveFocus() {\n      if (this.prevActive && this.prevActive !== document.body) {\n        this.prevActive.focus();\n      }\n    }\n\n    blurActiveElement() {\n      this.prevActive = this.getActiveElement();\n\n      if (this.prevActive !== document.body) {\n        this.prevActive.blur();\n      }\n    }\n\n    bindTopLevelEvents() {\n      if (this.boundTopLevelEvents) {\n        return;\n      }\n\n      this.boundTopLevelEvents = true;\n      document.body.addEventListener(\"click\", function () {});\n      window.addEventListener(\"pageshow\", e => {\n        if (e.persisted) {\n          this.getSocket().disconnect();\n          this.withPageLoading({\n            to: window.location.href,\n            kind: \"redirect\"\n          });\n          window.location.reload();\n        }\n      }, true);\n      this.bindNav();\n      this.bindClicks();\n      this.bindForms();\n      this.bind({\n        keyup: \"keyup\",\n        keydown: \"keydown\"\n      }, (e, type, view, target, targetCtx, phxEvent, _phxTarget) => {\n        let matchKey = target.getAttribute(this.binding(PHX_KEY));\n        let pressedKey = e.key && e.key.toLowerCase();\n\n        if (matchKey && matchKey.toLowerCase() !== pressedKey) {\n          return;\n        }\n\n        view.pushKey(target, targetCtx, type, phxEvent, __spreadValues({\n          key: e.key\n        }, this.eventMeta(type, e, target)));\n      });\n      this.bind({\n        blur: \"focusout\",\n        focus: \"focusin\"\n      }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {\n        if (!phxTarget) {\n          view.pushEvent(type, targetEl, targetCtx, phxEvent, this.eventMeta(type, e, targetEl));\n        }\n      });\n      this.bind({\n        blur: \"blur\",\n        focus: \"focus\"\n      }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {\n        if (phxTarget && !phxTarget !== \"window\") {\n          view.pushEvent(type, targetEl, targetCtx, phxEvent, this.eventMeta(type, e, targetEl));\n        }\n      });\n      window.addEventListener(\"dragover\", e => e.preventDefault());\n      window.addEventListener(\"drop\", e => {\n        e.preventDefault();\n        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), trueTarget => {\n          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));\n        });\n        let dropTarget = dropTargetId && document.getElementById(dropTargetId);\n        let files = Array.from(e.dataTransfer.files || []);\n\n        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {\n          return;\n        }\n\n        LiveUploader.trackFiles(dropTarget, files);\n        dropTarget.dispatchEvent(new Event(\"input\", {\n          bubbles: true\n        }));\n      });\n      this.on(PHX_TRACK_UPLOADS, e => {\n        let uploadTarget = e.target;\n\n        if (!dom_default.isUploadInput(uploadTarget)) {\n          return;\n        }\n\n        let files = Array.from(e.detail.files || []).filter(f => f instanceof File || f instanceof Blob);\n        LiveUploader.trackFiles(uploadTarget, files);\n        uploadTarget.dispatchEvent(new Event(\"input\", {\n          bubbles: true\n        }));\n      });\n    }\n\n    eventMeta(eventName, e, targetEl) {\n      let callback = this.metadataCallbacks[eventName];\n      return callback ? callback(e, targetEl) : {};\n    }\n\n    setPendingLink(href) {\n      this.linkRef++;\n      this.pendingLink = href;\n      return this.linkRef;\n    }\n\n    commitPendingLink(linkRef) {\n      if (this.linkRef !== linkRef) {\n        return false;\n      } else {\n        this.href = this.pendingLink;\n        this.pendingLink = null;\n        return true;\n      }\n    }\n\n    getHref() {\n      return this.href;\n    }\n\n    hasPendingLink() {\n      return !!this.pendingLink;\n    }\n\n    bind(events, callback) {\n      for (let event in events) {\n        let browserEventName = events[event];\n        this.on(browserEventName, e => {\n          let binding = this.binding(event);\n          let windowBinding = this.binding(`window-${event}`);\n          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\n\n          if (targetPhxEvent) {\n            this.debounce(e.target, e, () => {\n              this.withinOwners(e.target, (view, targetCtx) => {\n                callback(e, event, view, e.target, targetCtx, targetPhxEvent, null);\n              });\n            });\n          } else {\n            dom_default.all(document, `[${windowBinding}]`, el => {\n              let phxEvent = el.getAttribute(windowBinding);\n              this.debounce(el, e, () => {\n                this.withinOwners(el, (view, targetCtx) => {\n                  callback(e, event, view, el, targetCtx, phxEvent, \"window\");\n                });\n              });\n            });\n          }\n        });\n      }\n    }\n\n    bindClicks() {\n      this.bindClick(\"click\", \"click\", false);\n      this.bindClick(\"mousedown\", \"capture-click\", true);\n    }\n\n    bindClick(eventName, bindingName, capture) {\n      let click = this.binding(bindingName);\n      window.addEventListener(eventName, e => {\n        if (!this.isConnected()) {\n          return;\n        }\n\n        let target = null;\n\n        if (capture) {\n          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);\n        } else {\n          target = closestPhxBinding(e.target, click);\n        }\n\n        let phxEvent = target && target.getAttribute(click);\n\n        if (!phxEvent) {\n          return;\n        }\n\n        if (target.getAttribute(\"href\") === \"#\") {\n          e.preventDefault();\n        }\n\n        this.debounce(target, e, () => {\n          this.withinOwners(target, (view, targetCtx) => {\n            view.pushEvent(\"click\", target, targetCtx, phxEvent, this.eventMeta(\"click\", e, target));\n          });\n        });\n      }, capture);\n    }\n\n    bindNav() {\n      if (!browser_default.canPushState()) {\n        return;\n      }\n\n      if (history.scrollRestoration) {\n        history.scrollRestoration = \"manual\";\n      }\n\n      let scrollTimer = null;\n      window.addEventListener(\"scroll\", _e => {\n        clearTimeout(scrollTimer);\n        scrollTimer = setTimeout(() => {\n          browser_default.updateCurrentState(state => Object.assign(state, {\n            scroll: window.scrollY\n          }));\n        }, 100);\n      });\n      window.addEventListener(\"popstate\", event => {\n        if (!this.registerNewLocation(window.location)) {\n          return;\n        }\n\n        let {\n          type,\n          id,\n          root,\n          scroll\n        } = event.state || {};\n        let href = window.location.href;\n\n        if (this.main.isConnected() && type === \"patch\" && id === this.main.id) {\n          this.main.pushLinkPatch(href, null);\n        } else {\n          this.replaceMain(href, null, () => {\n            if (root) {\n              this.replaceRootHistory();\n            }\n\n            if (typeof scroll === \"number\") {\n              setTimeout(() => {\n                window.scrollTo(0, scroll);\n              }, 0);\n            }\n          });\n        }\n      }, false);\n      window.addEventListener(\"click\", e => {\n        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);\n        let type = target && target.getAttribute(PHX_LIVE_LINK);\n        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;\n\n        if (!type || !this.isConnected() || !this.main || wantsNewTab) {\n          return;\n        }\n\n        let href = target.href;\n        let linkState = target.getAttribute(PHX_LINK_STATE);\n        e.preventDefault();\n\n        if (this.pendingLink === href) {\n          return;\n        }\n\n        if (type === \"patch\") {\n          this.pushHistoryPatch(href, linkState, target);\n        } else if (type === \"redirect\") {\n          this.historyRedirect(href, linkState);\n        } else {\n          throw new Error(`expected ${PHX_LIVE_LINK} to be \"patch\" or \"redirect\", got: ${type}`);\n        }\n      }, false);\n    }\n\n    withPageLoading(info, callback) {\n      dom_default.dispatchEvent(window, \"phx:page-loading-start\", info);\n\n      let done = () => dom_default.dispatchEvent(window, \"phx:page-loading-stop\", info);\n\n      return callback ? callback(done) : done;\n    }\n\n    pushHistoryPatch(href, linkState, targetEl) {\n      this.withPageLoading({\n        to: href,\n        kind: \"patch\"\n      }, done => {\n        this.main.pushLinkPatch(href, targetEl, linkRef => {\n          this.historyPatch(href, linkState, linkRef);\n          done();\n        });\n      });\n    }\n\n    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {\n      if (!this.commitPendingLink(linkRef)) {\n        return;\n      }\n\n      browser_default.pushState(linkState, {\n        type: \"patch\",\n        id: this.main.id\n      }, href);\n      this.registerNewLocation(window.location);\n    }\n\n    historyRedirect(href, linkState, flash) {\n      let scroll = window.scrollY;\n      this.withPageLoading({\n        to: href,\n        kind: \"redirect\"\n      }, done => {\n        this.replaceMain(href, flash, () => {\n          browser_default.pushState(linkState, {\n            type: \"redirect\",\n            id: this.main.id,\n            scroll\n          }, href);\n          this.registerNewLocation(window.location);\n          done();\n        });\n      });\n    }\n\n    replaceRootHistory() {\n      browser_default.pushState(\"replace\", {\n        root: true,\n        type: \"patch\",\n        id: this.main.id\n      });\n    }\n\n    registerNewLocation(newLocation) {\n      let {\n        pathname,\n        search\n      } = this.currentLocation;\n\n      if (pathname + search === newLocation.pathname + newLocation.search) {\n        return false;\n      } else {\n        this.currentLocation = clone(newLocation);\n        return true;\n      }\n    }\n\n    bindForms() {\n      let iterations = 0;\n      this.on(\"submit\", e => {\n        let phxEvent = e.target.getAttribute(this.binding(\"submit\"));\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.preventDefault();\n        e.target.disabled = true;\n        this.withinOwners(e.target, (view, targetCtx) => view.submitForm(e.target, targetCtx, phxEvent));\n      }, false);\n\n      for (let type of [\"change\", \"input\"]) {\n        this.on(type, e => {\n          let input = e.target;\n          let phxEvent = input.form && input.form.getAttribute(this.binding(\"change\"));\n\n          if (!phxEvent) {\n            return;\n          }\n\n          if (input.type === \"number\" && input.validity && input.validity.badInput) {\n            return;\n          }\n\n          let currentIterations = iterations;\n          iterations++;\n          let {\n            at,\n            type: lastType\n          } = dom_default.private(input, \"prev-iteration\") || {};\n\n          if (at === currentIterations - 1 && type !== lastType) {\n            return;\n          }\n\n          dom_default.putPrivate(input, \"prev-iteration\", {\n            at: currentIterations,\n            type\n          });\n          this.debounce(input, e, () => {\n            this.withinOwners(input.form, (view, targetCtx) => {\n              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);\n\n              if (!dom_default.isTextualInput(input)) {\n                this.setActiveElement(input);\n              }\n\n              view.pushInput(input, targetCtx, null, phxEvent, e.target);\n            });\n          });\n        }, false);\n      }\n    }\n\n    debounce(el, event, callback) {\n      let phxDebounce = this.binding(PHX_DEBOUNCE);\n      let phxThrottle = this.binding(PHX_THROTTLE);\n      let defaultDebounce = this.defaults.debounce.toString();\n      let defaultThrottle = this.defaults.throttle.toString();\n      dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback);\n    }\n\n    silenceEvents(callback) {\n      this.silenced = true;\n      callback();\n      this.silenced = false;\n    }\n\n    on(event, callback) {\n      window.addEventListener(event, e => {\n        if (!this.silenced) {\n          callback(e);\n        }\n      });\n    }\n\n  };\n  return phoenix_live_view_exports;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9wcml2L3N0YXRpYy9waG9lbml4X2xpdmVfdmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L3ByaXYvc3RhdGljL3Bob2VuaXhfbGl2ZV92aWV3LmpzPzJjOTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIExpdmVWaWV3ID0gKCgpID0+IHtcbiAgdmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICB2YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbiAgdmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICB2YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgdmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gICAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvaW5kZXguanNcbiAgdmFyIHBob2VuaXhfbGl2ZV92aWV3X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQocGhvZW5peF9saXZlX3ZpZXdfZXhwb3J0cywge1xuICAgIExpdmVTb2NrZXQ6ICgpID0+IExpdmVTb2NrZXRcbiAgfSk7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzXG4gIHZhciBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCI7XG4gIHZhciBNQVhfUkVMT0FEUyA9IDEwO1xuICB2YXIgUkVMT0FEX0pJVFRFUiA9IFsxZTMsIDNlM107XG4gIHZhciBGQUlMU0FGRV9KSVRURVIgPSAzZTQ7XG4gIHZhciBQSFhfRVZFTlRfQ0xBU1NFUyA9IFtcbiAgICBcInBoeC1jbGljay1sb2FkaW5nXCIsXG4gICAgXCJwaHgtY2hhbmdlLWxvYWRpbmdcIixcbiAgICBcInBoeC1zdWJtaXQtbG9hZGluZ1wiLFxuICAgIFwicGh4LWtleWRvd24tbG9hZGluZ1wiLFxuICAgIFwicGh4LWtleXVwLWxvYWRpbmdcIixcbiAgICBcInBoeC1ibHVyLWxvYWRpbmdcIixcbiAgICBcInBoeC1mb2N1cy1sb2FkaW5nXCJcbiAgXTtcbiAgdmFyIFBIWF9DT01QT05FTlQgPSBcImRhdGEtcGh4LWNvbXBvbmVudFwiO1xuICB2YXIgUEhYX0xJVkVfTElOSyA9IFwiZGF0YS1waHgtbGlua1wiO1xuICB2YXIgUEhYX1RSQUNLX1NUQVRJQyA9IFwidHJhY2stc3RhdGljXCI7XG4gIHZhciBQSFhfTElOS19TVEFURSA9IFwiZGF0YS1waHgtbGluay1zdGF0ZVwiO1xuICB2YXIgUEhYX1JFRiA9IFwiZGF0YS1waHgtcmVmXCI7XG4gIHZhciBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiO1xuICB2YXIgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIjtcbiAgdmFyIFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCI7XG4gIHZhciBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIjtcbiAgdmFyIFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIjtcbiAgdmFyIFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIjtcbiAgdmFyIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCI7XG4gIHZhciBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiO1xuICB2YXIgUEhYX1JFTU9WRSA9IFwiZGF0YS1waHgtcmVtb3ZlXCI7XG4gIHZhciBQSFhfUEFHRV9MT0FESU5HID0gXCJwYWdlLWxvYWRpbmdcIjtcbiAgdmFyIFBIWF9DT05ORUNURURfQ0xBU1MgPSBcInBoeC1jb25uZWN0ZWRcIjtcbiAgdmFyIFBIWF9ESVNDT05ORUNURURfQ0xBU1MgPSBcInBoeC1kaXNjb25uZWN0ZWRcIjtcbiAgdmFyIFBIWF9OT19GRUVEQkFDS19DTEFTUyA9IFwicGh4LW5vLWZlZWRiYWNrXCI7XG4gIHZhciBQSFhfRVJST1JfQ0xBU1MgPSBcInBoeC1lcnJvclwiO1xuICB2YXIgUEhYX1BBUkVOVF9JRCA9IFwiZGF0YS1waHgtcGFyZW50LWlkXCI7XG4gIHZhciBQSFhfTUFJTiA9IFwiZGF0YS1waHgtbWFpblwiO1xuICB2YXIgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIjtcbiAgdmFyIFBIWF9UUklHR0VSX0FDVElPTiA9IFwidHJpZ2dlci1hY3Rpb25cIjtcbiAgdmFyIFBIWF9GRUVEQkFDS19GT1IgPSBcImZlZWRiYWNrLWZvclwiO1xuICB2YXIgUEhYX0hBU19GT0NVU0VEID0gXCJwaHgtaGFzLWZvY3VzZWRcIjtcbiAgdmFyIEZPQ1VTQUJMRV9JTlBVVFMgPSBbXCJ0ZXh0XCIsIFwidGV4dGFyZWFcIiwgXCJudW1iZXJcIiwgXCJlbWFpbFwiLCBcInBhc3N3b3JkXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZGF0ZVwiLCBcInRpbWVcIl07XG4gIHZhciBDSEVDS0FCTEVfSU5QVVRTID0gW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXTtcbiAgdmFyIFBIWF9IQVNfU1VCTUlUVEVEID0gXCJwaHgtaGFzLXN1Ym1pdHRlZFwiO1xuICB2YXIgUEhYX1NFU1NJT04gPSBcImRhdGEtcGh4LXNlc3Npb25cIjtcbiAgdmFyIFBIWF9WSUVXX1NFTEVDVE9SID0gYFske1BIWF9TRVNTSU9OfV1gO1xuICB2YXIgUEhYX1NUQVRJQyA9IFwiZGF0YS1waHgtc3RhdGljXCI7XG4gIHZhciBQSFhfUkVBRE9OTFkgPSBcImRhdGEtcGh4LXJlYWRvbmx5XCI7XG4gIHZhciBQSFhfRElTQUJMRUQgPSBcImRhdGEtcGh4LWRpc2FibGVkXCI7XG4gIHZhciBQSFhfRElTQUJMRV9XSVRIID0gXCJkaXNhYmxlLXdpdGhcIjtcbiAgdmFyIFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSA9IFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIjtcbiAgdmFyIFBIWF9IT09LID0gXCJob29rXCI7XG4gIHZhciBQSFhfREVCT1VOQ0UgPSBcImRlYm91bmNlXCI7XG4gIHZhciBQSFhfVEhST1RUTEUgPSBcInRocm90dGxlXCI7XG4gIHZhciBQSFhfVVBEQVRFID0gXCJ1cGRhdGVcIjtcbiAgdmFyIFBIWF9LRVkgPSBcImtleVwiO1xuICB2YXIgUEhYX1BSSVZBVEUgPSBcInBoeFByaXZhdGVcIjtcbiAgdmFyIFBIWF9BVVRPX1JFQ09WRVIgPSBcImF1dG8tcmVjb3ZlclwiO1xuICB2YXIgUEhYX0xWX0RFQlVHID0gXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIjtcbiAgdmFyIFBIWF9MVl9QUk9GSUxFID0gXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCI7XG4gIHZhciBQSFhfTFZfTEFURU5DWV9TSU0gPSBcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiO1xuICB2YXIgUEhYX1BST0dSRVNTID0gXCJwcm9ncmVzc1wiO1xuICB2YXIgTE9BREVSX1RJTUVPVVQgPSAxO1xuICB2YXIgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCA9IDIwMDtcbiAgdmFyIEJJTkRJTkdfUFJFRklYID0gXCJwaHgtXCI7XG4gIHZhciBQVVNIX1RJTUVPVVQgPSAzZTQ7XG4gIHZhciBERUJPVU5DRV9UUklHR0VSID0gXCJkZWJvdW5jZS10cmlnZ2VyXCI7XG4gIHZhciBUSFJPVFRMRUQgPSBcInRocm90dGxlZFwiO1xuICB2YXIgREVCT1VOQ0VfUFJFVl9LRVkgPSBcImRlYm91bmNlLXByZXYta2V5XCI7XG4gIHZhciBERUZBVUxUUyA9IHtcbiAgICBkZWJvdW5jZTogMzAwLFxuICAgIHRocm90dGxlOiAzMDBcbiAgfTtcbiAgdmFyIERZTkFNSUNTID0gXCJkXCI7XG4gIHZhciBTVEFUSUMgPSBcInNcIjtcbiAgdmFyIENPTVBPTkVOVFMgPSBcImNcIjtcbiAgdmFyIEVWRU5UUyA9IFwiZVwiO1xuICB2YXIgUkVQTFkgPSBcInJcIjtcbiAgdmFyIFRJVExFID0gXCJ0XCI7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvZW50cnlfdXBsb2FkZXIuanNcbiAgdmFyIEVudHJ5VXBsb2FkZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZW50cnksIGNodW5rU2l6ZSwgbGl2ZVNvY2tldCkge1xuICAgICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldDtcbiAgICAgIHRoaXMuZW50cnkgPSBlbnRyeTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgICAgdGhpcy5jaHVua1RpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbCA9IGxpdmVTb2NrZXQuY2hhbm5lbChgbHZ1OiR7ZW50cnkucmVmfWAsIHsgdG9rZW46IGVudHJ5Lm1ldGFkYXRhKCkgfSk7XG4gICAgfVxuICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2h1bmtUaW1lcik7XG4gICAgICB0aGlzLnVwbG9hZENoYW5uZWwubGVhdmUoKTtcbiAgICAgIHRoaXMuZW50cnkuZXJyb3IocmVhc29uKTtcbiAgICB9XG4gICAgdXBsb2FkKCkge1xuICAgICAgdGhpcy51cGxvYWRDaGFubmVsLm9uRXJyb3IoKHJlYXNvbikgPT4gdGhpcy5lcnJvcihyZWFzb24pKTtcbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5qb2luKCkucmVjZWl2ZShcIm9rXCIsIChfZGF0YSkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCkpLnJlY2VpdmUoXCJlcnJvclwiLCAocmVhc29uKSA9PiB0aGlzLmVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICBpc0RvbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgPj0gdGhpcy5lbnRyeS5maWxlLnNpemU7XG4gICAgfVxuICAgIHJlYWROZXh0Q2h1bmsoKSB7XG4gICAgICBsZXQgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKCk7XG4gICAgICBsZXQgYmxvYiA9IHRoaXMuZW50cnkuZmlsZS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5jaHVua1NpemUgKyB0aGlzLm9mZnNldCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gZS50YXJnZXQucmVzdWx0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgdGhpcy5wdXNoQ2h1bmsoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbG9nRXJyb3IoXCJSZWFkIGVycm9yOiBcIiArIGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICB9XG4gICAgcHVzaENodW5rKGNodW5rKSB7XG4gICAgICBpZiAoIXRoaXMudXBsb2FkQ2hhbm5lbC5pc0pvaW5lZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5wdXNoKFwiY2h1bmtcIiwgY2h1bmspLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cnkucHJvZ3Jlc3ModGhpcy5vZmZzZXQgLyB0aGlzLmVudHJ5LmZpbGUuc2l6ZSAqIDEwMCk7XG4gICAgICAgIGlmICghdGhpcy5pc0RvbmUoKSkge1xuICAgICAgICAgIHRoaXMuY2h1bmtUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCksIHRoaXMubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCkgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy91dGlscy5qc1xuICB2YXIgbG9nRXJyb3IgPSAobXNnLCBvYmopID0+IGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtc2csIG9iaik7XG4gIHZhciBpc0NpZCA9IChjaWQpID0+IHR5cGVvZiBjaWQgPT09IFwibnVtYmVyXCI7XG4gIGZ1bmN0aW9uIGRldGVjdER1cGxpY2F0ZUlkcygpIHtcbiAgICBsZXQgaWRzID0gbmV3IFNldCgpO1xuICAgIGxldCBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpZHMuaGFzKGVsZW1zW2ldLmlkKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBNdWx0aXBsZSBJRHMgZGV0ZWN0ZWQ6ICR7ZWxlbXNbaV0uaWR9LiBFbnN1cmUgdW5pcXVlIGVsZW1lbnQgaWRzLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICAgIGlmICh2aWV3LmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKTtcbiAgICB9XG4gIH07XG4gIHZhciBjbG9zdXJlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgdmFyIGNsb25lID0gKG9iaikgPT4ge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9O1xuICB2YXIgY2xvc2VzdFBoeEJpbmRpbmcgPSAoZWwsIGJpbmRpbmcsIGJvcmRlckVsKSA9PiB7XG4gICAgZG8ge1xuICAgICAgaWYgKGVsLm1hdGNoZXMoYFske2JpbmRpbmd9XWApKSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxICYmICEoYm9yZGVyRWwgJiYgYm9yZGVyRWwuaXNTYW1lTm9kZShlbCkgfHwgZWwubWF0Y2hlcyhQSFhfVklFV19TRUxFQ1RPUikpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgdmFyIGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KTtcbiAgfTtcbiAgdmFyIGlzRXF1YWxPYmogPSAob2JqMSwgb2JqMikgPT4gSlNPTi5zdHJpbmdpZnkob2JqMSkgPT09IEpTT04uc3RyaW5naWZ5KG9iajIpO1xuICB2YXIgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgICBmb3IgKGxldCB4IGluIG9iaikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgdmFyIG1heWJlID0gKGVsLCBjYWxsYmFjaykgPT4gZWwgJiYgY2FsbGJhY2soZWwpO1xuICB2YXIgY2hhbm5lbFVwbG9hZGVyID0gZnVuY3Rpb24oZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCkge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGxldCBlbnRyeVVwbG9hZGVyID0gbmV3IEVudHJ5VXBsb2FkZXIoZW50cnksIHJlc3AuY29uZmlnLmNodW5rX3NpemUsIGxpdmVTb2NrZXQpO1xuICAgICAgZW50cnlVcGxvYWRlci51cGxvYWQoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9icm93c2VyLmpzXG4gIHZhciBCcm93c2VyID0ge1xuICAgIGNhblB1c2hTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaGlzdG9yeS5wdXNoU3RhdGUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgfSxcbiAgICBkcm9wTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKTtcbiAgICB9LFxuICAgIHVwZGF0ZUxvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXksIGluaXRpYWwsIGZ1bmMpIHtcbiAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KTtcbiAgICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KTtcbiAgICAgIGxldCBuZXdWYWwgPSBjdXJyZW50ID09PSBudWxsID8gaW5pdGlhbCA6IGZ1bmMoY3VycmVudCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld1ZhbCkpO1xuICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICB9LFxuICAgIGdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIH0sXG4gICAgcHVzaFN0YXRlKGtpbmQsIG1ldGEsIHRvKSB7XG4gICAgICBpZiAodGhpcy5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICBpZiAodG8gIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgICAgaWYgKG1ldGEudHlwZSA9PSBcInJlZGlyZWN0XCIgJiYgbWV0YS5zY3JvbGwpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgICAgICAgICAgY3VycmVudFN0YXRlLnNjcm9sbCA9IG1ldGEuc2Nyb2xsO1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBtZXRhLnNjcm9sbDtcbiAgICAgICAgICBoaXN0b3J5W2tpbmQgKyBcIlN0YXRlXCJdKG1ldGEsIFwiXCIsIHRvIHx8IG51bGwpO1xuICAgICAgICAgIGxldCBoYXNoRWwgPSB0aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaCk7XG4gICAgICAgICAgaWYgKGhhc2hFbCkge1xuICAgICAgICAgICAgaGFzaEVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtZXRhLnR5cGUgPT09IFwicmVkaXJlY3RcIikge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVkaXJlY3QodG8pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0Q29va2llKG5hbWUsIHZhbHVlKSB7XG4gICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfWA7XG4gICAgfSxcbiAgICBnZXRDb29raWUobmFtZSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7cyopJHtuYW1lfXMqPXMqKFteO10qKS4qJCl8Xi4qJGApLCBcIiQxXCIpO1xuICAgIH0sXG4gICAgcmVkaXJlY3QodG9VUkwsIGZsYXNoKSB7XG4gICAgICBpZiAoZmxhc2gpIHtcbiAgICAgICAgQnJvd3Nlci5zZXRDb29raWUoXCJfX3Bob2VuaXhfZmxhc2hfX1wiLCBmbGFzaCArIFwiOyBtYXgtYWdlPTYwMDAwOyBwYXRoPS9cIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cubG9jYXRpb24gPSB0b1VSTDtcbiAgICB9LFxuICAgIGxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSB7XG4gICAgICByZXR1cm4gYCR7bmFtZXNwYWNlfS0ke3N1YmtleX1gO1xuICAgIH0sXG4gICAgZ2V0SGFzaFRhcmdldEVsKG1heWJlSGFzaCkge1xuICAgICAgbGV0IGhhc2ggPSBtYXliZUhhc2gudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAoaGFzaCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgYVtuYW1lPVwiJHtoYXNofVwiXWApO1xuICAgIH1cbiAgfTtcbiAgdmFyIGJyb3dzZXJfZGVmYXVsdCA9IEJyb3dzZXI7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzXG4gIHZhciBET00gPSB7XG4gICAgYnlJZChpZCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSB8fCBsb2dFcnJvcihgbm8gaWQgZm91bmQgZm9yICR7aWR9YCk7XG4gICAgfSxcbiAgICByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICBpZiAoZWwuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFsbChub2RlLCBxdWVyeSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBsZXQgYXJyYXkgPSBBcnJheS5mcm9tKG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrID8gYXJyYXkuZm9yRWFjaChjYWxsYmFjaykgOiBhcnJheTtcbiAgICB9LFxuICAgIGNoaWxkTm9kZUxlbmd0aChodG1sKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGRFbGVtZW50Q291bnQ7XG4gICAgfSxcbiAgICBpc1VwbG9hZElucHV0KGVsKSB7XG4gICAgICByZXR1cm4gZWwudHlwZSA9PT0gXCJmaWxlXCIgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSAhPT0gbnVsbDtcbiAgICB9LFxuICAgIGZpbmRVcGxvYWRJbnB1dHMobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWxsKG5vZGUsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1gKTtcbiAgICB9LFxuICAgIGZpbmRDb21wb25lbnROb2RlTGlzdChub2RlLCBjaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSk7XG4gICAgfSxcbiAgICBpc1BoeERlc3Ryb3llZChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pZCAmJiBET00ucHJpdmF0ZShub2RlLCBcImRlc3Ryb3llZFwiKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIG1hcmtQaHhDaGlsZERlc3Ryb3llZChlbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBcIlwiKTtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSk7XG4gICAgfSxcbiAgICBmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHBhcmVudElkKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKTtcbiAgICB9LFxuICAgIGlzSWdub3JlZChlbCwgcGh4VXBkYXRlKSB7XG4gICAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpIHx8IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXVwZGF0ZVwiKSkgPT09IFwiaWdub3JlXCI7XG4gICAgfSxcbiAgICBpc1BoeFVwZGF0ZShlbCwgcGh4VXBkYXRlLCB1cGRhdGVUeXBlcykge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwO1xuICAgIH0sXG4gICAgZmluZFBoeENoaWxkcmVuKGVsLCBwYXJlbnRJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgJHtQSFhfVklFV19TRUxFQ1RPUn1bJHtQSFhfUEFSRU5UX0lEfT1cIiR7cGFyZW50SWR9XCJdYCk7XG4gICAgfSxcbiAgICBmaW5kUGFyZW50Q0lEcyhub2RlLCBjaWRzKSB7XG4gICAgICBsZXQgaW5pdGlhbCA9IG5ldyBTZXQoY2lkcyk7XG4gICAgICByZXR1cm4gY2lkcy5yZWR1Y2UoKGFjYywgY2lkKSA9PiB7XG4gICAgICAgIGxldCBzZWxlY3RvciA9IGBbJHtQSFhfQ09NUE9ORU5UfT1cIiR7Y2lkfVwiXSBbJHtQSFhfQ09NUE9ORU5UfV1gO1xuICAgICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBzZWxlY3RvciksIG5vZGUpLm1hcCgoZWwpID0+IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSkpLmZvckVhY2goKGNoaWxkQ0lEKSA9PiBhY2MuZGVsZXRlKGNoaWxkQ0lEKSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBpbml0aWFsKTtcbiAgICB9LFxuICAgIGZpbHRlcldpdGhpblNhbWVMaXZlVmlldyhub2RlcywgcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnF1ZXJ5U2VsZWN0b3IoUEhYX1ZJRVdfU0VMRUNUT1IpKSB7XG4gICAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKGVsKSA9PiB0aGlzLndpdGhpblNhbWVMaXZlVmlldyhlbCwgcGFyZW50KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9XG4gICAgfSxcbiAgICB3aXRoaW5TYW1lTGl2ZVZpZXcobm9kZSwgcGFyZW50KSB7XG4gICAgICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pc1NhbWVOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcml2YXRlKGVsLCBrZXkpIHtcbiAgICAgIHJldHVybiBlbFtQSFhfUFJJVkFURV0gJiYgZWxbUEhYX1BSSVZBVEVdW2tleV07XG4gICAgfSxcbiAgICBkZWxldGVQcml2YXRlKGVsLCBrZXkpIHtcbiAgICAgIGVsW1BIWF9QUklWQVRFXSAmJiBkZWxldGUgZWxbUEhYX1BSSVZBVEVdW2tleV07XG4gICAgfSxcbiAgICBwdXRQcml2YXRlKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWVsW1BIWF9QUklWQVRFXSkge1xuICAgICAgICBlbFtQSFhfUFJJVkFURV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGVsW1BIWF9QUklWQVRFXVtrZXldID0gdmFsdWU7XG4gICAgfSxcbiAgICBjb3B5UHJpdmF0ZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2VbUEhYX1BSSVZBVEVdKSB7XG4gICAgICAgIHRhcmdldFtQSFhfUFJJVkFURV0gPSBjbG9uZShzb3VyY2VbUEhYX1BSSVZBVEVdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHB1dFRpdGxlKHN0cikge1xuICAgICAgbGV0IHRpdGxlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGl0bGVcIik7XG4gICAgICBsZXQgeyBwcmVmaXgsIHN1ZmZpeCB9ID0gdGl0bGVFbC5kYXRhc2V0O1xuICAgICAgZG9jdW1lbnQudGl0bGUgPSBgJHtwcmVmaXggfHwgXCJcIn0ke3N0cn0ke3N1ZmZpeCB8fCBcIlwifWA7XG4gICAgfSxcbiAgICBkZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgZGVib3VuY2UgPSBlbC5nZXRBdHRyaWJ1dGUocGh4RGVib3VuY2UpO1xuICAgICAgbGV0IHRocm90dGxlID0gZWwuZ2V0QXR0cmlidXRlKHBoeFRocm90dGxlKTtcbiAgICAgIGlmIChkZWJvdW5jZSA9PT0gXCJcIikge1xuICAgICAgICBkZWJvdW5jZSA9IGRlZmF1bHREZWJvdW5jZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aHJvdHRsZSA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdHRsZSA9IGRlZmF1bHRUaHJvdHRsZTtcbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZSA9IGRlYm91bmNlIHx8IHRocm90dGxlO1xuICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICAgICAgaWYgKHRoaXMub25jZShlbCwgXCJkZWJvdW5jZS1ibHVyXCIpKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB0aW1lb3V0ID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgIGxldCB0cmlnZ2VyID0gKCkgPT4gdGhyb3R0bGUgPyB0aGlzLmRlbGV0ZVByaXZhdGUoZWwsIFRIUk9UVExFRCkgOiBjYWxsYmFjaygpO1xuICAgICAgICAgIGxldCBjdXJyZW50Q3ljbGUgPSB0aGlzLmluY0N5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCB0cmlnZ2VyKTtcbiAgICAgICAgICBpZiAoaXNOYU4odGltZW91dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dFcnJvcihgaW52YWxpZCB0aHJvdHRsZS9kZWJvdW5jZSB2YWx1ZTogJHt2YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRocm90dGxlKSB7XG4gICAgICAgICAgICBsZXQgbmV3S2V5RG93biA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiKSB7XG4gICAgICAgICAgICAgIGxldCBwcmV2S2V5ID0gdGhpcy5wcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSk7XG4gICAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVksIGV2ZW50LmtleSk7XG4gICAgICAgICAgICAgIG5ld0tleURvd24gPSBwcmV2S2V5ICE9PSBldmVudC5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgVEhST1RUTEVELCB0cnVlKTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpLCB0aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtO1xuICAgICAgICAgIGlmIChmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIEFycmF5LmZyb20obmV3IEZvcm1EYXRhKGZvcm0pLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSkge1xuICAgICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSk7XG4gICAgICBpZiAoIWN1cnJlbnRDeWNsZSkge1xuICAgICAgICBjdXJyZW50Q3ljbGUgPSBjeWNsZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50Q3ljbGUgPT09IGN5Y2xlKSB7XG4gICAgICAgIHRoaXMuaW5jQ3ljbGUoZWwsIGtleSk7XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uY2UoZWwsIGtleSkge1xuICAgICAgaWYgKHRoaXMucHJpdmF0ZShlbCwga2V5KSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdO1xuICAgICAgY3VycmVudEN5Y2xlKys7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pO1xuICAgICAgcmV0dXJuIGN1cnJlbnRDeWNsZTtcbiAgICB9LFxuICAgIGRpc2NhcmRFcnJvcihjb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcikge1xuICAgICAgbGV0IGZpZWxkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhGZWVkYmFja0Zvcik7XG4gICAgICBsZXQgaW5wdXQgPSBmaWVsZCAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtmaWVsZH1cIl0sIFtuYW1lPVwiJHtmaWVsZH1cIl1gKTtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5wcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpIHx8IHRoaXMucHJpdmF0ZShpbnB1dC5mb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCkpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoUEhYX05PX0ZFRURCQUNLX0NMQVNTKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dFcnJvcihpbnB1dEVsLCBwaHhGZWVkYmFja0Zvcikge1xuICAgICAgaWYgKGlucHV0RWwuaWQgfHwgaW5wdXRFbC5uYW1lKSB7XG4gICAgICAgIHRoaXMuYWxsKGlucHV0RWwuZm9ybSwgYFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5pZH1cIl0sIFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5uYW1lfVwiXWAsIChlbCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoZWwsIFBIWF9OT19GRUVEQkFDS19DTEFTUyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNQaHhDaGlsZChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCk7XG4gICAgfSxcbiAgICBkaXNwYXRjaEV2ZW50KHRhcmdldCwgZXZlbnRTdHJpbmcsIGRldGFpbCA9IHt9KSB7XG4gICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnRTdHJpbmcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgZGV0YWlsIH0pO1xuICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG4gICAgY2xvbmVOb2RlKG5vZGUsIGh0bWwpIHtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY2xvbmVkID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBjbG9uZWQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIG9wdHMgPSB7fSkge1xuICAgICAgbGV0IGV4Y2x1ZGUgPSBvcHRzLmV4Y2x1ZGUgfHwgW107XG4gICAgICBsZXQgaXNJZ25vcmVkID0gb3B0cy5pc0lnbm9yZWQ7XG4gICAgICBsZXQgc291cmNlQXR0cnMgPSBzb3VyY2UuYXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSBzb3VyY2VBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgbmFtZSA9IHNvdXJjZUF0dHJzW2ldLm5hbWU7XG4gICAgICAgIGlmIChleGNsdWRlLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHRhcmdldEF0dHJzID0gdGFyZ2V0LmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpID0gdGFyZ2V0QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0YXJnZXRBdHRyc1tpXS5uYW1lO1xuICAgICAgICBpZiAoaXNJZ25vcmVkKSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXNvdXJjZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXJnZUZvY3VzZWRJbnB1dCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKSB7XG4gICAgICAgIERPTS5tZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCB7IGV4Y2VwdDogW1widmFsdWVcIl0gfSk7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLnJlYWRPbmx5KSB7XG4gICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJyZWFkb25seVwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc1NlbGVjdGlvblJhbmdlKGVsKSB7XG4gICAgICByZXR1cm4gZWwuc2V0U2VsZWN0aW9uUmFuZ2UgJiYgKGVsLnR5cGUgPT09IFwidGV4dFwiIHx8IGVsLnR5cGUgPT09IFwidGV4dGFyZWFcIik7XG4gICAgfSxcbiAgICByZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkge1xuICAgICAgaWYgKCFET00uaXNUZXh0dWFsSW5wdXQoZm9jdXNlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHdhc0ZvY3VzZWQgPSBmb2N1c2VkLm1hdGNoZXMoXCI6Zm9jdXNcIik7XG4gICAgICBpZiAoZm9jdXNlZC5yZWFkT25seSkge1xuICAgICAgICBmb2N1c2VkLmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICghd2FzRm9jdXNlZCkge1xuICAgICAgICBmb2N1c2VkLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSkge1xuICAgICAgICBmb2N1c2VkLnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNGb3JtSW5wdXQoZWwpIHtcbiAgICAgIHJldHVybiAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdChlbC50YWdOYW1lKSAmJiBlbC50eXBlICE9PSBcImJ1dHRvblwiO1xuICAgIH0sXG4gICAgc3luY0F0dHJzVG9Qcm9wcyhlbCkge1xuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBlbC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpICE9PSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3luY1Byb3BzVG9BdHRycyhlbCkge1xuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkSXRlbSA9IGVsLm9wdGlvbnMuaXRlbShlbC5zZWxlY3RlZEluZGV4KTtcbiAgICAgICAgaWYgKHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW0uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIikgPT09IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3RlZEl0ZW0uc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlzVGV4dHVhbElucHV0KGVsKSB7XG4gICAgICByZXR1cm4gRk9DVVNBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDA7XG4gICAgfSxcbiAgICBpc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4VHJpZ2dlckV4dGVybmFsKSAhPT0gbnVsbDtcbiAgICB9LFxuICAgIHN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpIHtcbiAgICAgIGxldCByZWYgPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUYpO1xuICAgICAgaWYgKHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChET00uaXNGb3JtSW5wdXQoZnJvbUVsKSB8fCBmcm9tRWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoRE9NLmlzVXBsb2FkSW5wdXQoZnJvbUVsKSkge1xuICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwgeyBpc0lnbm9yZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGLCB0b0VsKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgZnJvbUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpICYmIHRvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRiwgcmVmKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhbkNoaWxkTm9kZXMoY29udGFpbmVyLCBwaHhVcGRhdGUpIHtcbiAgICAgIGlmIChET00uaXNQaHhVcGRhdGUoY29udGFpbmVyLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKSB7XG4gICAgICAgIGxldCB0b1JlbW92ZSA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBpZiAoIWNoaWxkTm9kZS5pZCkge1xuICAgICAgICAgICAgbGV0IGlzRW1wdHlUZXh0Tm9kZSA9IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGROb2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IFwiXCI7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICBsb2dFcnJvcihgb25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cblxucmVtb3ZpbmcgaWxsZWdhbCBub2RlOiBcIiR7KGNoaWxkTm9kZS5vdXRlckhUTUwgfHwgY2hpbGROb2RlLm5vZGVWYWx1ZSkudHJpbSgpfVwiXG5cbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9SZW1vdmUucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRvUmVtb3ZlLmZvckVhY2goKGNoaWxkTm9kZSkgPT4gY2hpbGROb2RlLnJlbW92ZSgpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2VSb290Q29udGFpbmVyKGNvbnRhaW5lciwgdGFnTmFtZSwgYXR0cnMpIHtcbiAgICAgIGxldCByZXRhaW5lZEF0dHJzID0gbmV3IFNldChbXCJpZFwiLCBQSFhfU0VTU0lPTiwgUEhYX1NUQVRJQywgUEhYX01BSU5dKTtcbiAgICAgIGlmIChjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgQXJyYXkuZnJvbShjb250YWluZXIuYXR0cmlidXRlcykuZmlsdGVyKChhdHRyKSA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKS5mb3JFYWNoKChhdHRyKSA9PiBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSkpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZmlsdGVyKChuYW1lKSA9PiAhcmV0YWluZWRBdHRycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkuZm9yRWFjaCgoYXR0cikgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG5ld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChhdHRyKSA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSk7XG4gICAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaCgoYXR0cikgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSk7XG4gICAgICAgIG5ld0NvbnRhaW5lci5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgICAgICBjb250YWluZXIucmVwbGFjZVdpdGgobmV3Q29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkb21fZGVmYXVsdCA9IERPTTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy91cGxvYWRfZW50cnkuanNcbiAgdmFyIFVwbG9hZEVudHJ5ID0gY2xhc3Mge1xuICAgIHN0YXRpYyBpc0FjdGl2ZShmaWxlRWwsIGZpbGUpIHtcbiAgICAgIGxldCBpc05ldyA9IGZpbGUuX3BoeFJlZiA9PT0gdm9pZCAwO1xuICAgICAgbGV0IGFjdGl2ZVJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpO1xuICAgICAgbGV0IGlzQWN0aXZlID0gYWN0aXZlUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwO1xuICAgICAgcmV0dXJuIGZpbGUuc2l6ZSA+IDAgJiYgKGlzTmV3IHx8IGlzQWN0aXZlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKSB7XG4gICAgICBsZXQgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykuc3BsaXQoXCIsXCIpO1xuICAgICAgbGV0IGlzUHJlZmxpZ2h0ZWQgPSBwcmVmbGlnaHRlZFJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMDtcbiAgICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmlsZUVsLCBmaWxlLCB2aWV3KSB7XG4gICAgICB0aGlzLnJlZiA9IExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpO1xuICAgICAgdGhpcy5maWxlRWwgPSBmaWxlRWw7XG4gICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgIHRoaXMubWV0YSA9IG51bGw7XG4gICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNEb25lID0gZmFsc2U7XG4gICAgICB0aGlzLl9wcm9ncmVzcyA9IDA7XG4gICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gLTE7XG4gICAgICB0aGlzLl9vbkRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgICB0aGlzLl9vbkVsVXBkYXRlZCA9IHRoaXMub25FbFVwZGF0ZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuZmlsZUVsLmFkZEV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZCk7XG4gICAgfVxuICAgIG1ldGFkYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWV0YTtcbiAgICB9XG4gICAgcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzID0gTWF0aC5mbG9vcihwcm9ncmVzcyk7XG4gICAgICBpZiAodGhpcy5fcHJvZ3Jlc3MgPiB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzcyA+PSAxMDApIHtcbiAgICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMDtcbiAgICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gMTAwO1xuICAgICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICAgIExpdmVVcGxvYWRlci51bnRyYWNrRmlsZSh0aGlzLmZpbGVFbCwgdGhpcy5maWxlKTtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSB0aGlzLl9wcm9ncmVzcztcbiAgICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHRoaXMuX3Byb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICB0aGlzLl9pc0RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fb25Eb25lKCk7XG4gICAgfVxuICAgIGlzRG9uZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0RvbmU7XG4gICAgfVxuICAgIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgeyBlcnJvcjogcmVhc29uIH0pO1xuICAgICAgTGl2ZVVwbG9hZGVyLmNsZWFyRmlsZXModGhpcy5maWxlRWwpO1xuICAgIH1cbiAgICBvbkRvbmUoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX29uRG9uZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5maWxlRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH07XG4gICAgfVxuICAgIG9uRWxVcGRhdGVkKCkge1xuICAgICAgbGV0IGFjdGl2ZVJlZnMgPSB0aGlzLmZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKS5zcGxpdChcIixcIik7XG4gICAgICBpZiAoYWN0aXZlUmVmcy5pbmRleE9mKHRoaXMucmVmKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9QcmVmbGlnaHRQYXlsb2FkKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFzdF9tb2RpZmllZDogdGhpcy5maWxlLmxhc3RNb2RpZmllZCxcbiAgICAgICAgbmFtZTogdGhpcy5maWxlLm5hbWUsXG4gICAgICAgIHNpemU6IHRoaXMuZmlsZS5zaXplLFxuICAgICAgICB0eXBlOiB0aGlzLmZpbGUudHlwZSxcbiAgICAgICAgcmVmOiB0aGlzLnJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgdXBsb2FkZXIodXBsb2FkZXJzKSB7XG4gICAgICBpZiAodGhpcy5tZXRhLnVwbG9hZGVyKSB7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IHVwbG9hZGVyc1t0aGlzLm1ldGEudXBsb2FkZXJdIHx8IGxvZ0Vycm9yKGBubyB1cGxvYWRlciBjb25maWd1cmVkIGZvciAke3RoaXMubWV0YS51cGxvYWRlcn1gKTtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogdGhpcy5tZXRhLnVwbG9hZGVyLCBjYWxsYmFjayB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJjaGFubmVsXCIsIGNhbGxiYWNrOiBjaGFubmVsVXBsb2FkZXIgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgemlwUG9zdEZsaWdodChyZXNwKSB7XG4gICAgICB0aGlzLm1ldGEgPSByZXNwLmVudHJpZXNbdGhpcy5yZWZdO1xuICAgICAgaWYgKCF0aGlzLm1ldGEpIHtcbiAgICAgICAgbG9nRXJyb3IoYG5vIHByZWZsaWdodCB1cGxvYWQgcmVzcG9uc2UgcmV0dXJuZWQgd2l0aCByZWYgJHt0aGlzLnJlZn1gLCB7IGlucHV0OiB0aGlzLmZpbGVFbCwgcmVzcG9uc2U6IHJlc3AgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfdXBsb2FkZXIuanNcbiAgdmFyIGxpdmVVcGxvYWRlckZpbGVSZWYgPSAwO1xuICB2YXIgTGl2ZVVwbG9hZGVyID0gY2xhc3Mge1xuICAgIHN0YXRpYyBnZW5GaWxlUmVmKGZpbGUpIHtcbiAgICAgIGxldCByZWYgPSBmaWxlLl9waHhSZWY7XG4gICAgICBpZiAocmVmICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGUuX3BoeFJlZiA9IChsaXZlVXBsb2FkZXJGaWxlUmVmKyspLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBmaWxlLl9waHhSZWY7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRFbnRyeURhdGFVUkwoaW5wdXRFbCwgcmVmLCBjYWxsYmFjaykge1xuICAgICAgbGV0IGZpbGUgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmZpbmQoKGZpbGUyKSA9PiB0aGlzLmdlbkZpbGVSZWYoZmlsZTIpID09PSByZWYpO1xuICAgICAgY2FsbGJhY2soVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKSk7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpIHtcbiAgICAgIGxldCBhY3RpdmUgPSAwO1xuICAgICAgZG9tX2RlZmF1bHQuZmluZFVwbG9hZElucHV0cyhmb3JtRWwpLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpICE9PSBpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX0RPTkVfUkVGUykpIHtcbiAgICAgICAgICBhY3RpdmUrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWN0aXZlID4gMDtcbiAgICB9XG4gICAgc3RhdGljIHNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbCkge1xuICAgICAgbGV0IGZpbGVzID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKTtcbiAgICAgIGxldCBmaWxlRGF0YSA9IHt9O1xuICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICBsZXQgZW50cnkgPSB7IHBhdGg6IGlucHV0RWwubmFtZSB9O1xuICAgICAgICBsZXQgdXBsb2FkUmVmID0gaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpO1xuICAgICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdID0gZmlsZURhdGFbdXBsb2FkUmVmXSB8fCBbXTtcbiAgICAgICAgZW50cnkucmVmID0gdGhpcy5nZW5GaWxlUmVmKGZpbGUpO1xuICAgICAgICBlbnRyeS5uYW1lID0gZmlsZS5uYW1lIHx8IGVudHJ5LnJlZjtcbiAgICAgICAgZW50cnkudHlwZSA9IGZpbGUudHlwZTtcbiAgICAgICAgZW50cnkuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXS5wdXNoKGVudHJ5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbGVEYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgY2xlYXJGaWxlcyhpbnB1dEVsKSB7XG4gICAgICBpbnB1dEVsLnZhbHVlID0gbnVsbDtcbiAgICAgIGlucHV0RWwucmVtb3ZlQXR0cmlidXRlKFBIWF9VUExPQURfUkVGKTtcbiAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBbXSk7XG4gICAgfVxuICAgIHN0YXRpYyB1bnRyYWNrRmlsZShpbnB1dEVsLCBmaWxlKSB7XG4gICAgICBkb21fZGVmYXVsdC5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZG9tX2RlZmF1bHQucHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIpLmZpbHRlcigoZikgPT4gIU9iamVjdC5pcyhmLCBmaWxlKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgdHJhY2tGaWxlcyhpbnB1dEVsLCBmaWxlcykge1xuICAgICAgaWYgKGlucHV0RWwuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IG5ld0ZpbGVzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiAhdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKChmKSA9PiBPYmplY3QuaXMoZiwgZmlsZSkpKTtcbiAgICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuY29uY2F0KG5ld0ZpbGVzKSk7XG4gICAgICAgIGlucHV0RWwudmFsdWUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIGZpbGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKSB7XG4gICAgICBsZXQgZmlsZUlucHV0cyA9IGRvbV9kZWZhdWx0LmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcigoZWwpID0+IGVsLmZpbGVzICYmIHRoaXMuYWN0aXZlRmlsZXMoZWwpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBzdGF0aWMgYWN0aXZlRmlsZXMoaW5wdXQpIHtcbiAgICAgIHJldHVybiAoZG9tX2RlZmF1bHQucHJpdmF0ZShpbnB1dCwgXCJmaWxlc1wiKSB8fCBbXSkuZmlsdGVyKChmKSA9PiBVcGxvYWRFbnRyeS5pc0FjdGl2ZShpbnB1dCwgZikpO1xuICAgIH1cbiAgICBzdGF0aWMgaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKSB7XG4gICAgICBsZXQgZmlsZUlucHV0cyA9IGRvbV9kZWZhdWx0LmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcigoaW5wdXQpID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIHN0YXRpYyBmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKChmKSA9PiAhVXBsb2FkRW50cnkuaXNQcmVmbGlnaHRlZChpbnB1dCwgZikpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dEVsLCB2aWV3LCBvbkNvbXBsZXRlKSB7XG4gICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICAgIHRoaXMuX2VudHJpZXMgPSBBcnJheS5mcm9tKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpIHx8IFtdKS5tYXAoKGZpbGUpID0+IG5ldyBVcGxvYWRFbnRyeShpbnB1dEVsLCBmaWxlLCB2aWV3KSk7XG4gICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID0gdGhpcy5fZW50cmllcy5sZW5ndGg7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW50cmllcztcbiAgICB9XG4gICAgaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgbGl2ZVNvY2tldCkge1xuICAgICAgdGhpcy5fZW50cmllcyA9IHRoaXMuX2VudHJpZXMubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICBlbnRyeS56aXBQb3N0RmxpZ2h0KHJlc3ApO1xuICAgICAgICBlbnRyeS5vbkRvbmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MtLTtcbiAgICAgICAgICBpZiAodGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSk7XG4gICAgICBsZXQgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgICBsZXQgeyBuYW1lLCBjYWxsYmFjayB9ID0gZW50cnkudXBsb2FkZXIobGl2ZVNvY2tldC51cGxvYWRlcnMpO1xuICAgICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwgeyBjYWxsYmFjaywgZW50cmllczogW10gfTtcbiAgICAgICAgYWNjW25hbWVdLmVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgICBmb3IgKGxldCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKSB7XG4gICAgICAgIGxldCB7IGNhbGxiYWNrLCBlbnRyaWVzIH0gPSBncm91cGVkRW50cmllc1tuYW1lXTtcbiAgICAgICAgY2FsbGJhY2soZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2hvb2tzLmpzXG4gIHZhciBIb29rcyA9IHtcbiAgICBMaXZlRmlsZVVwbG9hZDoge1xuICAgICAgYWN0aXZlUmVmcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUyk7XG4gICAgICB9LFxuICAgICAgcHJlZmxpZ2h0ZWRSZWZzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpO1xuICAgICAgfSxcbiAgICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZWQoKSB7XG4gICAgICAgIGxldCBuZXdQcmVmbGlnaHRzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKTtcbiAgICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0ZWRXYXMgIT09IG5ld1ByZWZsaWdodHMpIHtcbiAgICAgICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gbmV3UHJlZmxpZ2h0cztcbiAgICAgICAgICBpZiAobmV3UHJlZmxpZ2h0cyA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy5fX3ZpZXcuY2FuY2VsU3VibWl0KHRoaXMuZWwuZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVJlZnMoKSA9PT0gXCJcIikge1xuICAgICAgICAgIHRoaXMuZWwudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoUEhYX0xJVkVfRklMRV9VUERBVEVEKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBMaXZlSW1nUHJldmlldzoge1xuICAgICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKTtcbiAgICAgICAgdGhpcy5pbnB1dEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpKTtcbiAgICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCAodXJsKSA9PiB7XG4gICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgICAgdGhpcy5lbC5zcmMgPSB1cmw7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3llZCgpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgaG9va3NfZGVmYXVsdCA9IEhvb2tzO1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyLmpzXG4gIHZhciBET01Qb3N0TW9ycGhSZXN0b3JlciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJCZWZvcmUsIGNvbnRhaW5lckFmdGVyLCB1cGRhdGVUeXBlKSB7XG4gICAgICBsZXQgaWRzQmVmb3JlID0gbmV3IFNldCgpO1xuICAgICAgbGV0IGlkc0FmdGVyID0gbmV3IFNldChbLi4uY29udGFpbmVyQWZ0ZXIuY2hpbGRyZW5dLm1hcCgoY2hpbGQpID0+IGNoaWxkLmlkKSk7XG4gICAgICBsZXQgZWxlbWVudHNUb01vZGlmeSA9IFtdO1xuICAgICAgQXJyYXkuZnJvbShjb250YWluZXJCZWZvcmUuY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5pZCkge1xuICAgICAgICAgIGlkc0JlZm9yZS5hZGQoY2hpbGQuaWQpO1xuICAgICAgICAgIGlmIChpZHNBZnRlci5oYXMoY2hpbGQuaWQpKSB7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNFbGVtZW50SWQgPSBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQ7XG4gICAgICAgICAgICBlbGVtZW50c1RvTW9kaWZ5LnB1c2goeyBlbGVtZW50SWQ6IGNoaWxkLmlkLCBwcmV2aW91c0VsZW1lbnRJZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXJJZCA9IGNvbnRhaW5lckFmdGVyLmlkO1xuICAgICAgdGhpcy51cGRhdGVUeXBlID0gdXBkYXRlVHlwZTtcbiAgICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeSA9IGVsZW1lbnRzVG9Nb2RpZnk7XG4gICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZCA9IFsuLi5pZHNBZnRlcl0uZmlsdGVyKChpZCkgPT4gIWlkc0JlZm9yZS5oYXMoaWQpKTtcbiAgICB9XG4gICAgcGVyZm9ybSgpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSBkb21fZGVmYXVsdC5ieUlkKHRoaXMuY29udGFpbmVySWQpO1xuICAgICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5LmZvckVhY2goKGVsZW1lbnRUb01vZGlmeSkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSB7XG4gICAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSwgKHByZXZpb3VzRWxlbSkgPT4ge1xuICAgICAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LmVsZW1lbnRJZCksIChlbGVtKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQgPT0gcHJldmlvdXNFbGVtLmlkO1xuICAgICAgICAgICAgICBpZiAoIWlzSW5SaWdodFBsYWNlKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNFbGVtLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgKGVsZW0pID0+IHtcbiAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyA9PSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpc0luUmlnaHRQbGFjZSkge1xuICAgICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy51cGRhdGVUeXBlID09IFwicHJlcGVuZFwiKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudElkc1RvQWRkLnJldmVyc2UoKS5mb3JFYWNoKChlbGVtSWQpID0+IHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtSWQpLCAoZWxlbSkgPT4gY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gbm9kZV9tb2R1bGVzL21vcnBoZG9tL2Rpc3QvbW9ycGhkb20tZXNtLmpzXG4gIHZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG4gIGZ1bmN0aW9uIG1vcnBoQXR0cnMoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHZhciB0b05vZGVBdHRycyA9IHRvTm9kZS5hdHRyaWJ1dGVzO1xuICAgIHZhciBhdHRyO1xuICAgIHZhciBhdHRyTmFtZTtcbiAgICB2YXIgYXR0ck5hbWVzcGFjZVVSSTtcbiAgICB2YXIgYXR0clZhbHVlO1xuICAgIHZhciBmcm9tVmFsdWU7XG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gdG9Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG4gICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBkID0gZnJvbU5vZGVBdHRycy5sZW5ndGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgYXR0ciA9IGZyb21Ob2RlQXR0cnNbZF07XG4gICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG4gICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKSkge1xuICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0b05vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJhbmdlO1xuICB2YXIgTlNfWEhUTUwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgdmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IGRvY3VtZW50O1xuICB2YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiBcImNvbnRlbnRcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICB2YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgXCJjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnRcIiBpbiBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2Rlc1swXTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShkb2MuYm9keSk7XG4gICAgfVxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO1xuICAgIGZyYWdtZW50LmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbiAgfVxuICBmdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21UZW1wbGF0ZShzdHIpO1xuICAgIH0gZWxzZSBpZiAoSEFTX1JBTkdFX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlTmFtZXMoZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGZyb21Ob2RlTmFtZSA9IGZyb21FbC5ub2RlTmFtZTtcbiAgICB2YXIgdG9Ob2RlTmFtZSA9IHRvRWwubm9kZU5hbWU7XG4gICAgdmFyIGZyb21Db2RlU3RhcnQsIHRvQ29kZVN0YXJ0O1xuICAgIGlmIChmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmcm9tQ29kZVN0YXJ0ID0gZnJvbU5vZGVOYW1lLmNoYXJDb2RlQXQoMCk7XG4gICAgdG9Db2RlU3RhcnQgPSB0b05vZGVOYW1lLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGZyb21Db2RlU3RhcnQgPD0gOTAgJiYgdG9Db2RlU3RhcnQgPj0gOTcpIHtcbiAgICAgIHJldHVybiBmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRvQ29kZVN0YXJ0IDw9IDkwICYmIGZyb21Db2RlU3RhcnQgPj0gOTcpIHtcbiAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/IGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmVDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgY3VyQ2hpbGQgPSBuZXh0Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB0b0VsO1xuICB9XG4gIGZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgZnJvbUVsW25hbWVdID0gdG9FbFtuYW1lXTtcbiAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBmcm9tRWwucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnROYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gXCJPUFRHUk9VUFwiKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBwYXJlbnROYW1lID0gcGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09IFwiU0VMRUNUXCIgJiYgIXBhcmVudE5vZGUuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikpIHtcbiAgICAgICAgICBpZiAoZnJvbUVsLmhhc0F0dHJpYnV0ZShcInNlbGVjdGVkXCIpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBcInNlbGVjdGVkXCIpO1xuICAgIH0sXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIFwiY2hlY2tlZFwiKTtcbiAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBcImRpc2FibGVkXCIpO1xuICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gdG9FbC52YWx1ZSkge1xuICAgICAgICBmcm9tRWwudmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpKSB7XG4gICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBmcm9tRWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBmaXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgaWYgKG9sZFZhbHVlID09IG5ld1ZhbHVlIHx8ICFuZXdWYWx1ZSAmJiBvbGRWYWx1ZSA9PSBmcm9tRWwucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIG9wdGdyb3VwO1xuICAgICAgICB2YXIgbm9kZU5hbWU7XG4gICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgIG5vZGVOYW1lID0gY3VyQ2hpbGQubm9kZU5hbWUgJiYgY3VyQ2hpbGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAobm9kZU5hbWUgPT09IFwiT1BUR1JPVVBcIikge1xuICAgICAgICAgICAgb3B0Z3JvdXAgPSBjdXJDaGlsZDtcbiAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSBcIk9QVElPTlwiKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJDaGlsZC5oYXNBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIWN1ckNoaWxkICYmIG9wdGdyb3VwKSB7XG4gICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIG9wdGdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIEVMRU1FTlRfTk9ERSA9IDE7XG4gIHZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEgPSAxMTtcbiAgdmFyIFRFWFRfTk9ERSA9IDM7XG4gIHZhciBDT01NRU5UX05PREUgPSA4O1xuICBmdW5jdGlvbiBub29wKCkge1xuICB9XG4gIGZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIikgfHwgbm9kZS5pZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tMihmcm9tTm9kZSwgdG9Ob2RlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0b05vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGZyb21Ob2RlLm5vZGVOYW1lID09PSBcIiNkb2N1bWVudFwiIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSBcIkhUTUxcIiB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gXCJCT0RZXCIpIHtcbiAgICAgICAgICB2YXIgdG9Ob2RlSHRtbCA9IHRvTm9kZTtcbiAgICAgICAgICB0b05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChcImh0bWxcIik7XG4gICAgICAgICAgdG9Ob2RlLmlubmVySFRNTCA9IHRvTm9kZUh0bWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBnZXROb2RlS2V5ID0gb3B0aW9ucy5nZXROb2RlS2V5IHx8IGRlZmF1bHRHZXROb2RlS2V5O1xuICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uQmVmb3JlRWxVcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uRWxVcGRhdGVkID0gb3B0aW9ucy5vbkVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICB2YXIgb25Ob2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbk5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICAgIHZhciBvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkIHx8IG5vb3A7XG4gICAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG4gICAgICB2YXIgZnJvbU5vZGVzTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBrZXllZFJlbW92YWxMaXN0ID0gW107XG4gICAgICBmdW5jdGlvbiBhZGRLZXllZFJlbW92YWwoa2V5KSB7XG4gICAgICAgIGtleWVkUmVtb3ZhbExpc3QucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoc2tpcEtleWVkTm9kZXMgJiYgKGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpKSkge1xuICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgIGlmIChjdXJDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMoY3VyQ2hpbGQsIHNraXBLZXllZE5vZGVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSwgcGFyZW50Tm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIG9uTm9kZURpc2NhcmRlZChub2RlKTtcbiAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleFRyZWUoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZGV4VHJlZShmcm9tTm9kZSk7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVOb2RlQWRkZWQoZWwpIHtcbiAgICAgICAgb25Ob2RlQWRkZWQoZWwpO1xuICAgICAgICB2YXIgY3VyQ2hpbGQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgICAgaWYgKHVubWF0Y2hlZEZyb21FbCAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckNoaWxkLCB1bm1hdGNoZWRGcm9tRWwpKSB7XG4gICAgICAgICAgICAgIGN1ckNoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgdmFyIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3JwaEVsKGZyb21FbCwgdG9FbCwgY2hpbGRyZW5Pbmx5Mikge1xuICAgICAgICB2YXIgdG9FbEtleSA9IGdldE5vZGVLZXkodG9FbCk7XG4gICAgICAgIGlmICh0b0VsS2V5KSB7XG4gICAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkcmVuT25seTIpIHtcbiAgICAgICAgICBpZiAob25CZWZvcmVFbFVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9ycGhBdHRyczIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuICAgICAgICAgIGlmIChvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tRWwubm9kZU5hbWUgIT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVycy5URVhUQVJFQShmcm9tRWwsIHRvRWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgY3VyVG9Ob2RlQ2hpbGQgPSB0b0VsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICAgIHZhciBjdXJGcm9tTm9kZUtleTtcbiAgICAgICAgdmFyIGZyb21OZXh0U2libGluZztcbiAgICAgICAgdmFyIHRvTmV4dFNpYmxpbmc7XG4gICAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgd2hpbGUgKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICB0b05leHRTaWJsaW5nID0gY3VyVG9Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJUb05vZGVLZXkgPSBnZXROb2RlS2V5KGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlICYmIGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuICAgICAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBjdXJUb05vZGVDaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICE9PSBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbU5leHRTaWJsaW5nID09PSBtYXRjaGluZ0Zyb21FbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vcnBoRWwoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSAhPT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgJiYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pICYmIGNvbXBhcmVOb2RlTmFtZXMobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQobWF0Y2hpbmdGcm9tRWwpO1xuICAgICAgICAgICAgICBtb3JwaEVsKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgPSBvbkJlZm9yZU5vZGVBZGRlZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gb25CZWZvcmVOb2RlQWRkZWRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLm5vZGVOYW1lXTtcbiAgICAgICAgaWYgKHNwZWNpYWxFbEhhbmRsZXIpIHtcbiAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVyKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgICAgdmFyIG1vcnBoZWROb2RlVHlwZSA9IG1vcnBoZWROb2RlLm5vZGVUeXBlO1xuICAgICAgdmFyIHRvTm9kZVR5cGUgPSB0b05vZGUubm9kZVR5cGU7XG4gICAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVOb2RlTmFtZXMoZnJvbU5vZGUsIHRvTm9kZSkpIHtcbiAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3ZlQ2hpbGRyZW4oZnJvbU5vZGUsIGNyZWF0ZUVsZW1lbnROUyh0b05vZGUubm9kZU5hbWUsIHRvTm9kZS5uYW1lc3BhY2VVUkkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IG1vcnBoZWROb2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgICAgaWYgKG1vcnBoZWROb2RlLm5vZGVWYWx1ZSAhPT0gdG9Ob2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtb3JwaGVkTm9kZSA9PT0gdG9Ob2RlKSB7XG4gICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vcnBoRWwobW9ycGhlZE5vZGUsIHRvTm9kZSwgY2hpbGRyZW5Pbmx5KTtcbiAgICAgICAgaWYgKGtleWVkUmVtb3ZhbExpc3QpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5ZWRSZW1vdmFsTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5ZWRSZW1vdmFsTGlzdFtpXV07XG4gICAgICAgICAgICBpZiAoZWxUb1JlbW92ZSkge1xuICAgICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjaGlsZHJlbk9ubHkgJiYgbW9ycGhlZE5vZGUgIT09IGZyb21Ob2RlICYmIGZyb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKG1vcnBoZWROb2RlLmFjdHVhbGl6ZSkge1xuICAgICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgfVxuICAgICAgICBmcm9tTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkTm9kZSwgZnJvbU5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgIH07XG4gIH1cbiAgdmFyIG1vcnBoZG9tID0gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpO1xuICB2YXIgbW9ycGhkb21fZXNtX2RlZmF1bHQgPSBtb3JwaGRvbTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9kb21fcGF0Y2guanNcbiAgdmFyIERPTVBhdGNoID0gY2xhc3Mge1xuICAgIHN0YXRpYyBwYXRjaEVsKGZyb21FbCwgdG9FbCwgYWN0aXZlRWxlbWVudCkge1xuICAgICAgbW9ycGhkb21fZXNtX2RlZmF1bHQoZnJvbUVsLCB0b0VsLCB7XG4gICAgICAgIGNoaWxkcmVuT25seTogZmFsc2UsXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsMiwgdG9FbDIpID0+IHtcbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LmlzU2FtZU5vZGUoZnJvbUVsMikgJiYgZG9tX2RlZmF1bHQuaXNGb3JtSW5wdXQoZnJvbUVsMikpIHtcbiAgICAgICAgICAgIGRvbV9kZWZhdWx0Lm1lcmdlRm9jdXNlZElucHV0KGZyb21FbDIsIHRvRWwyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb250YWluZXIsIGlkLCBodG1sLCB0YXJnZXRDSUQpIHtcbiAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXQ7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgIHRoaXMucm9vdElEID0gdmlldy5yb290LmlkO1xuICAgICAgdGhpcy5odG1sID0gaHRtbDtcbiAgICAgIHRoaXMudGFyZ2V0Q0lEID0gdGFyZ2V0Q0lEO1xuICAgICAgdGhpcy5jaWRQYXRjaCA9IGlzQ2lkKHRoaXMudGFyZ2V0Q0lEKTtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgICBiZWZvcmVhZGRlZDogW10sXG4gICAgICAgIGJlZm9yZXVwZGF0ZWQ6IFtdLFxuICAgICAgICBiZWZvcmVwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgICAgYWZ0ZXJhZGRlZDogW10sXG4gICAgICAgIGFmdGVydXBkYXRlZDogW10sXG4gICAgICAgIGFmdGVyZGlzY2FyZGVkOiBbXSxcbiAgICAgICAgYWZ0ZXJwaHhDaGlsZEFkZGVkOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgYmVmb3JlKGtpbmQsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBhZnRlcihraW5kLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgfVxuICAgIHRyYWNrQWZ0ZXIoa2luZCwgLi4uYXJncykge1xuICAgICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgfVxuICAgIG1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCkge1xuICAgICAgZG9tX2RlZmF1bHQuYWxsKHRoaXMuY29udGFpbmVyLCBcIltwaHgtdXBkYXRlPWFwcGVuZF0gPiAqLCBbcGh4LXVwZGF0ZT1wcmVwZW5kXSA+ICpcIiwgKGVsKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVNT1ZFLCBcIlwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtKCkge1xuICAgICAgbGV0IHsgdmlldywgbGl2ZVNvY2tldCwgY29udGFpbmVyLCBodG1sIH0gPSB0aGlzO1xuICAgICAgbGV0IHRhcmdldENvbnRhaW5lciA9IHRoaXMuaXNDSURQYXRjaCgpID8gdGhpcy50YXJnZXRDSURDb250YWluZXIoaHRtbCkgOiBjb250YWluZXI7XG4gICAgICBpZiAodGhpcy5pc0NJRFBhdGNoKCkgJiYgIXRhcmdldENvbnRhaW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZm9jdXNlZCA9IGxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgICAgbGV0IHsgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCB9ID0gZm9jdXNlZCAmJiBkb21fZGVmYXVsdC5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSA/IGZvY3VzZWQgOiB7fTtcbiAgICAgIGxldCBwaHhVcGRhdGUgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSk7XG4gICAgICBsZXQgcGh4RmVlZGJhY2tGb3IgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUik7XG4gICAgICBsZXQgZGlzYWJsZVdpdGggPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSCk7XG4gICAgICBsZXQgcGh4VHJpZ2dlckV4dGVybmFsID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9UUklHR0VSX0FDVElPTik7XG4gICAgICBsZXQgYWRkZWQgPSBbXTtcbiAgICAgIGxldCB1cGRhdGVzID0gW107XG4gICAgICBsZXQgYXBwZW5kUHJlcGVuZFVwZGF0ZXMgPSBbXTtcbiAgICAgIGxldCBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBudWxsO1xuICAgICAgbGV0IGRpZmZIVE1MID0gbGl2ZVNvY2tldC50aW1lKFwicHJlbW9ycGggY29udGFpbmVyIHByZXBcIiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIiwgY29udGFpbmVyKTtcbiAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGNvbnRhaW5lciwgY29udGFpbmVyKTtcbiAgICAgIGxpdmVTb2NrZXQudGltZShcIm1vcnBoZG9tXCIsICgpID0+IHtcbiAgICAgICAgbW9ycGhkb21fZXNtX2RlZmF1bHQodGFyZ2V0Q29udGFpbmVyLCBkaWZmSFRNTCwge1xuICAgICAgICAgIGNoaWxkcmVuT25seTogdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gbnVsbCxcbiAgICAgICAgICBnZXROb2RlS2V5OiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbV9kZWZhdWx0LmlzUGh4RGVzdHJveWVkKG5vZGUpID8gbnVsbCA6IG5vZGUuaWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkJlZm9yZU5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIiwgZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSkge1xuICAgICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbV9kZWZhdWx0LmRpc2NhcmRFcnJvcih0YXJnZXRDb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcik7XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNQaHhDaGlsZChlbCkgJiYgdmlldy5vd25zRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRlZC5wdXNoKGVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNQaHhDaGlsZChlbCkpIHtcbiAgICAgICAgICAgICAgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsIGVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUkVNT1ZFKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlICE9PSBudWxsICYmIGRvbV9kZWZhdWx0LmlzUGh4VXBkYXRlKGVsLnBhcmVudE5vZGUsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkgJiYgZWwuaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FbFVwZGF0ZWQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSkge1xuICAgICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChlbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgICAgZG9tX2RlZmF1bHQuY2xlYW5DaGlsZE5vZGVzKHRvRWwsIHBoeFVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwQ0lEU2libGluZyh0b0VsKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSkge1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwgeyBpc0lnbm9yZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUVsLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGZyb21FbC52YWxpZGl0eSAmJiBmcm9tRWwudmFsaWRpdHkuYmFkSW5wdXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZG9tX2RlZmF1bHQuc3luY1BlbmRpbmdSZWYoZnJvbUVsLCB0b0VsLCBkaXNhYmxlV2l0aCkpIHtcbiAgICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzVXBsb2FkSW5wdXQoZnJvbUVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzUGh4Q2hpbGQodG9FbCkpIHtcbiAgICAgICAgICAgICAgbGV0IHByZXZTZXNzaW9uID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTik7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0Lm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7IGV4Y2x1ZGU6IFtQSFhfU1RBVElDXSB9KTtcbiAgICAgICAgICAgICAgaWYgKHByZXZTZXNzaW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgcHJldlNlc3Npb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdElEKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tX2RlZmF1bHQuY29weVByaXZhdGVzKHRvRWwsIGZyb21FbCk7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5kaXNjYXJkRXJyb3IodGFyZ2V0Q29udGFpbmVyLCB0b0VsLCBwaHhGZWVkYmFja0Zvcik7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5zeW5jUHJvcHNUb0F0dHJzKHRvRWwpO1xuICAgICAgICAgICAgbGV0IGlzRm9jdXNlZEZvcm1FbCA9IGZvY3VzZWQgJiYgZnJvbUVsLmlzU2FtZU5vZGUoZm9jdXNlZCkgJiYgZG9tX2RlZmF1bHQuaXNGb3JtSW5wdXQoZnJvbUVsKTtcbiAgICAgICAgICAgIGlmIChpc0ZvY3VzZWRGb3JtRWwgJiYgIXRoaXMuZm9yY2VGb2N1c2VkU2VsZWN0VXBkYXRlKGZyb21FbCwgdG9FbCkpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgZG9tX2RlZmF1bHQubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgZG9tX2RlZmF1bHQuc3luY0F0dHJzVG9Qcm9wcyhmcm9tRWwpO1xuICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzUGh4VXBkYXRlKHRvRWwsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5wdXNoKG5ldyBET01Qb3N0TW9ycGhSZXN0b3Jlcihmcm9tRWwsIHRvRWwsIHRvRWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5zeW5jQXR0cnNUb1Byb3BzKHRvRWwpO1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAobGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgIGRldGVjdER1cGxpY2F0ZUlkcygpO1xuICAgICAgfVxuICAgICAgaWYgKGFwcGVuZFByZXBlbmRVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGl2ZVNvY2tldC50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLCAoKSA9PiB7XG4gICAgICAgICAgYXBwZW5kUHJlcGVuZFVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlKSA9PiB1cGRhdGUucGVyZm9ybSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsaXZlU29ja2V0LnNpbGVuY2VFdmVudHMoKCkgPT4gZG9tX2RlZmF1bHQucmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpKTtcbiAgICAgIGRvbV9kZWZhdWx0LmRpc3BhdGNoRXZlbnQoZG9jdW1lbnQsIFwicGh4OnVwZGF0ZVwiKTtcbiAgICAgIGFkZGVkLmZvckVhY2goKGVsKSA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJhZGRlZFwiLCBlbCkpO1xuICAgICAgdXBkYXRlcy5mb3JFYWNoKChlbCkgPT4gdGhpcy50cmFja0FmdGVyKFwidXBkYXRlZFwiLCBlbCkpO1xuICAgICAgaWYgKGV4dGVybmFsRm9ybVRyaWdnZXJlZCkge1xuICAgICAgICBsaXZlU29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkLnN1Ym1pdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvcmNlRm9jdXNlZFNlbGVjdFVwZGF0ZShmcm9tRWwsIHRvRWwpIHtcbiAgICAgIGxldCBpc1NlbGVjdCA9IFtcInNlbGVjdFwiLCBcInNlbGVjdC1vbmVcIiwgXCJzZWxlY3QtbXVsdGlwbGVcIl0uZmluZCgodCkgPT4gdCA9PT0gZnJvbUVsLnR5cGUpO1xuICAgICAgcmV0dXJuIGZyb21FbC5tdWx0aXBsZSA9PT0gdHJ1ZSB8fCBpc1NlbGVjdCAmJiBmcm9tRWwuaW5uZXJIVE1MICE9IHRvRWwuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBpc0NJRFBhdGNoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2lkUGF0Y2g7XG4gICAgfVxuICAgIHNraXBDSURTaWJsaW5nKGVsKSB7XG4gICAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfU0tJUCkgIT09IG51bGw7XG4gICAgfVxuICAgIHRhcmdldENJRENvbnRhaW5lcihodG1sKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDSURQYXRjaCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gZG9tX2RlZmF1bHQuZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnRhcmdldENJRCk7XG4gICAgICBpZiAocmVzdC5sZW5ndGggPT09IDAgJiYgZG9tX2RlZmF1bHQuY2hpbGROb2RlTGVuZ3RoKGh0bWwpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBidWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpIHtcbiAgICAgIGxldCBpc0NJRFBhdGNoID0gdGhpcy5pc0NJRFBhdGNoKCk7XG4gICAgICBsZXQgaXNDSURXaXRoU2luZ2xlUm9vdCA9IGlzQ0lEUGF0Y2ggJiYgdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gdGhpcy50YXJnZXRDSUQudG9TdHJpbmcoKTtcbiAgICAgIGlmICghaXNDSURQYXRjaCB8fCBpc0NJRFdpdGhTaW5nbGVSb290KSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRpZmZDb250YWluZXIgPSBudWxsO1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICAgIGRpZmZDb250YWluZXIgPSBkb21fZGVmYXVsdC5jbG9uZU5vZGUodGFyZ2V0Q29udGFpbmVyKTtcbiAgICAgICAgbGV0IFtmaXJzdENvbXBvbmVudCwgLi4ucmVzdF0gPSBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QoZGlmZkNvbnRhaW5lciwgdGhpcy50YXJnZXRDSUQpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXN0LmZvckVhY2goKGVsKSA9PiBlbC5yZW1vdmUoKSk7XG4gICAgICAgIEFycmF5LmZyb20oZGlmZkNvbnRhaW5lci5jaGlsZE5vZGVzKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZC5pZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpICE9PSB0aGlzLnRhcmdldENJRC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpO1xuICAgICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBBcnJheS5mcm9tKHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2RlcykuZm9yRWFjaCgoZWwpID0+IGRpZmZDb250YWluZXIuaW5zZXJ0QmVmb3JlKGVsLCBmaXJzdENvbXBvbmVudCkpO1xuICAgICAgICBmaXJzdENvbXBvbmVudC5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIGRpZmZDb250YWluZXIub3V0ZXJIVE1MO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9yZW5kZXJlZC5qc1xuICB2YXIgUmVuZGVyZWQgPSBjbGFzcyB7XG4gICAgc3RhdGljIGV4dHJhY3QoZGlmZikge1xuICAgICAgbGV0IHsgW1JFUExZXTogcmVwbHksIFtFVkVOVFNdOiBldmVudHMsIFtUSVRMRV06IHRpdGxlIH0gPSBkaWZmO1xuICAgICAgZGVsZXRlIGRpZmZbUkVQTFldO1xuICAgICAgZGVsZXRlIGRpZmZbRVZFTlRTXTtcbiAgICAgIGRlbGV0ZSBkaWZmW1RJVExFXTtcbiAgICAgIHJldHVybiB7IGRpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW10gfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlld0lkLCByZW5kZXJlZCkge1xuICAgICAgdGhpcy52aWV3SWQgPSB2aWV3SWQ7XG4gICAgICB0aGlzLnJlbmRlcmVkID0ge307XG4gICAgICB0aGlzLm1lcmdlRGlmZihyZW5kZXJlZCk7XG4gICAgfVxuICAgIHBhcmVudFZpZXdJZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdJZDtcbiAgICB9XG4gICAgdG9TdHJpbmcob25seUNpZHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKHRoaXMucmVuZGVyZWQsIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzKTtcbiAgICB9XG4gICAgcmVjdXJzaXZlVG9TdHJpbmcocmVuZGVyZWQsIGNvbXBvbmVudHMgPSByZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpIHtcbiAgICAgIG9ubHlDaWRzID0gb25seUNpZHMgPyBuZXcgU2V0KG9ubHlDaWRzKSA6IG51bGw7XG4gICAgICBsZXQgb3V0cHV0ID0geyBidWZmZXI6IFwiXCIsIGNvbXBvbmVudHMsIG9ubHlDaWRzIH07XG4gICAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCBvdXRwdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dC5idWZmZXI7XG4gICAgfVxuICAgIGNvbXBvbmVudENJRHMoZGlmZikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmZbQ09NUE9ORU5UU10gfHwge30pLm1hcCgoaSkgPT4gcGFyc2VJbnQoaSkpO1xuICAgIH1cbiAgICBpc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZltDT01QT05FTlRTXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoID09PSAxO1xuICAgIH1cbiAgICBnZXRDb21wb25lbnQoZGlmZiwgY2lkKSB7XG4gICAgICByZXR1cm4gZGlmZltDT01QT05FTlRTXVtjaWRdO1xuICAgIH1cbiAgICBtZXJnZURpZmYoZGlmZikge1xuICAgICAgbGV0IG5ld2MgPSBkaWZmW0NPTVBPTkVOVFNdO1xuICAgICAgbGV0IGNhY2hlID0ge307XG4gICAgICBkZWxldGUgZGlmZltDT01QT05FTlRTXTtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSB0aGlzLm11dGFibGVNZXJnZSh0aGlzLnJlbmRlcmVkLCBkaWZmKTtcbiAgICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdIHx8IHt9O1xuICAgICAgaWYgKG5ld2MpIHtcbiAgICAgICAgbGV0IG9sZGMgPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdO1xuICAgICAgICBmb3IgKGxldCBjaWQgaW4gbmV3Yykge1xuICAgICAgICAgIG5ld2NbY2lkXSA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChjaWQsIG5ld2NbY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdjKSB7XG4gICAgICAgICAgb2xkY1trZXldID0gbmV3Y1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZbQ09NUE9ORU5UU10gPSBuZXdjO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgY2RpZmYsIG9sZGMsIG5ld2MsIGNhY2hlKSB7XG4gICAgICBpZiAoY2FjaGVbY2lkXSkge1xuICAgICAgICByZXR1cm4gY2FjaGVbY2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBuZGlmZiwgc3RhdCwgc2NpZCA9IGNkaWZmW1NUQVRJQ107XG4gICAgICAgIGlmIChpc0NpZChzY2lkKSkge1xuICAgICAgICAgIGxldCB0ZGlmZjtcbiAgICAgICAgICBpZiAoc2NpZCA+IDApIHtcbiAgICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGRpZmYgPSBvbGRjWy1zY2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdCA9IHRkaWZmW1NUQVRJQ107XG4gICAgICAgICAgbmRpZmYgPSB0aGlzLmNsb25lTWVyZ2UodGRpZmYsIGNkaWZmKTtcbiAgICAgICAgICBuZGlmZltTVEFUSUNdID0gc3RhdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZGlmZiA9IGNkaWZmW1NUQVRJQ10gIT09IHZvaWQgMCA/IGNkaWZmIDogdGhpcy5jbG9uZU1lcmdlKG9sZGNbY2lkXSB8fCB7fSwgY2RpZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2NpZF0gPSBuZGlmZjtcbiAgICAgICAgcmV0dXJuIG5kaWZmO1xuICAgICAgfVxuICAgIH1cbiAgICBtdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2VbU1RBVElDXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gICAgZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldO1xuICAgICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB2b2lkIDAgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSkge1xuICAgICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0VmFsLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGxldCBtZXJnZWQgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGFyZ2V0KSwgc291cmNlKTtcbiAgICAgIGZvciAobGV0IGtleSBpbiBtZXJnZWQpIHtcbiAgICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldO1xuICAgICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB2b2lkIDAgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSkge1xuICAgICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgY29tcG9uZW50VG9TdHJpbmcoY2lkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyh0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBjaWQpO1xuICAgIH1cbiAgICBwcnVuZUNJRHMoY2lkcykge1xuICAgICAgY2lkcy5mb3JFYWNoKChjaWQpID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZDtcbiAgICB9XG4gICAgaXNOZXdGaW5nZXJwcmludChkaWZmID0ge30pIHtcbiAgICAgIHJldHVybiAhIWRpZmZbU1RBVElDXTtcbiAgICB9XG4gICAgdG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIG91dHB1dCkge1xuICAgICAgaWYgKHJlbmRlcmVkW0RZTkFNSUNTXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIG91dHB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgeyBbU1RBVElDXTogc3RhdGljcyB9ID0gcmVuZGVyZWQ7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF07XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIocmVuZGVyZWRbaSAtIDFdLCBvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgb3V0cHV0KSB7XG4gICAgICBsZXQgeyBbRFlOQU1JQ1NdOiBkeW5hbWljcywgW1NUQVRJQ106IHN0YXRpY3MgfSA9IHJlbmRlcmVkO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKykge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdO1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBvdXRwdXQpO1xuICAgICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkeW5hbWljVG9CdWZmZXIocmVuZGVyZWQsIG91dHB1dCkge1xuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcob3V0cHV0LmNvbXBvbmVudHMsIHJlbmRlcmVkLCBvdXRwdXQub25seUNpZHMpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChyZW5kZXJlZCkpIHtcbiAgICAgICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgb3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJlY3Vyc2l2ZUNJRFRvU3RyaW5nKGNvbXBvbmVudHMsIGNpZCwgb25seUNpZHMpIHtcbiAgICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2NpZF0gfHwgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3IgQ0lEICR7Y2lkfWAsIGNvbXBvbmVudHMpO1xuICAgICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGhpcy5yZWN1cnNpdmVUb1N0cmluZyhjb21wb25lbnQsIGNvbXBvbmVudHMsIG9ubHlDaWRzKTtcbiAgICAgIGxldCBjb250YWluZXIgPSB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgbGV0IHNraXAgPSBvbmx5Q2lkcyAmJiAhb25seUNpZHMuaGFzKGNpZCk7XG4gICAgICBsZXQgW2hhc0NoaWxkTm9kZXMsIGhhc0NoaWxkQ29tcG9uZW50c10gPSBBcnJheS5mcm9tKGNvbnRhaW5lci5jaGlsZE5vZGVzKS5yZWR1Y2UoKFtoYXNOb2RlcywgaGFzQ29tcG9uZW50c10sIGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBpZiAoY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCB0cnVlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQsIGNpZCk7XG4gICAgICAgICAgaWYgKCFjaGlsZC5pZCkge1xuICAgICAgICAgICAgY2hpbGQuaWQgPSBgJHt0aGlzLnBhcmVudFZpZXdJZCgpfS0ke2NpZH0tJHtpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpO1xuICAgICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVZhbHVlLnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgbG9nRXJyb3IoYG9ubHkgSFRNTCBlbGVtZW50IHRhZ3MgYXJlIGFsbG93ZWQgYXQgdGhlIHJvb3Qgb2YgY29tcG9uZW50cy5cblxuZ290OiBcIiR7Y2hpbGQubm9kZVZhbHVlLnRyaW0oKX1cIlxuXG53aXRoaW46XG5gLCB0ZW1wbGF0ZS5pbm5lckhUTUwudHJpbSgpKTtcbiAgICAgICAgICAgIGNoaWxkLnJlcGxhY2VXaXRoKHRoaXMuY3JlYXRlU3BhbihjaGlsZC5ub2RlVmFsdWUsIGNpZCkpO1xuICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCBoYXNDb21wb25lbnRzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIFtmYWxzZSwgZmFsc2VdKTtcbiAgICAgIGlmICghaGFzQ2hpbGROb2RlcyAmJiAhaGFzQ2hpbGRDb21wb25lbnRzKSB7XG4gICAgICAgIGxvZ0Vycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgdGhlIGNvbXBvbmVudCBpcyBlbXB0eTpcXG5cIiwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNwYW4oXCJcIiwgY2lkKS5vdXRlckhUTUw7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNDaGlsZE5vZGVzICYmIGhhc0NoaWxkQ29tcG9uZW50cykge1xuICAgICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGRpcmVjdGx5IGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IG9ubHkgc3ViY29tcG9uZW50cyB3ZXJlIGZvdW5kLiBBIGNvbXBvbmVudCBtdXN0IHJlbmRlciBhdCBsZWFzdCBvbmUgSFRNTCB0YWcgZGlyZWN0bHkgaW5zaWRlIGl0c2VsZi5cIiwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVTcGFuKHRleHQsIGNpZCkge1xuICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4uaW5uZXJUZXh0ID0gdGV4dDtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQsIGNpZCk7XG4gICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvdmlld19ob29rLmpzXG4gIHZhciB2aWV3SG9va0lEID0gMTtcbiAgdmFyIFZpZXdIb29rID0gY2xhc3Mge1xuICAgIHN0YXRpYyBtYWtlSUQoKSB7XG4gICAgICByZXR1cm4gdmlld0hvb2tJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZWxlbWVudElEKGVsKSB7XG4gICAgICByZXR1cm4gZWwucGh4SG9va0lkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBlbCwgY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLl9fdmlldyA9IHZpZXc7XG4gICAgICB0aGlzLl9fbGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldDtcbiAgICAgIHRoaXMuX19jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICB0aGlzLl9fbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVsID0gZWw7XG4gICAgICB0aGlzLmVsLnBoeEhvb2tJZCA9IHRoaXMuY29uc3RydWN0b3IubWFrZUlEKCk7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fX2NhbGxiYWNrcykge1xuICAgICAgICB0aGlzW2tleV0gPSB0aGlzLl9fY2FsbGJhY2tzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIF9fbW91bnRlZCgpIHtcbiAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLm1vdW50ZWQoKTtcbiAgICB9XG4gICAgX191cGRhdGVkKCkge1xuICAgICAgdGhpcy51cGRhdGVkICYmIHRoaXMudXBkYXRlZCgpO1xuICAgIH1cbiAgICBfX2JlZm9yZVVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuYmVmb3JlVXBkYXRlICYmIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG4gICAgfVxuICAgIF9fZGVzdHJveWVkKCkge1xuICAgICAgdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5kZXN0cm95ZWQoKTtcbiAgICB9XG4gICAgX19yZWNvbm5lY3RlZCgpIHtcbiAgICAgIGlmICh0aGlzLl9faXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0ZWQgJiYgdGhpcy5yZWNvbm5lY3RlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX2Rpc2Nvbm5lY3RlZCgpIHtcbiAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RlZCAmJiB0aGlzLmRpc2Nvbm5lY3RlZCgpO1xuICAgIH1cbiAgICBwdXNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uKCkge1xuICAgIH0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KTtcbiAgICB9XG4gICAgcHVzaEV2ZW50VG8ocGh4VGFyZ2V0LCBldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgcmV0dXJuIHRoaXMuX192aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgIHJldHVybiB2aWV3LnB1c2hIb29rRXZlbnQodGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgY2FsbGJhY2tSZWYgPSAoY3VzdG9tRXZlbnQsIGJ5cGFzcykgPT4gYnlwYXNzID8gZXZlbnQgOiBjYWxsYmFjayhjdXN0b21FdmVudC5kZXRhaWwpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYHBoeDpob29rOiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpO1xuICAgICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrUmVmO1xuICAgIH1cbiAgICByZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikge1xuICAgICAgbGV0IGV2ZW50ID0gY2FsbGJhY2tSZWYobnVsbCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihgcGh4Omhvb2s6JHtldmVudH1gLCBjYWxsYmFja1JlZik7XG4gICAgICB0aGlzLl9fbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFja1JlZik7XG4gICAgfVxuICAgIHVwbG9hZChuYW1lLCBmaWxlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX192aWV3LmRpc3BhdGNoVXBsb2FkcyhuYW1lLCBmaWxlcyk7XG4gICAgfVxuICAgIHVwbG9hZFRvKHBoeFRhcmdldCwgbmFtZSwgZmlsZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcpID0+IHZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKSk7XG4gICAgfVxuICAgIF9fY2xlYW51cF9fKCkge1xuICAgICAgdGhpcy5fX2xpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFja1JlZikgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy92aWV3LmpzXG4gIHZhciBzZXJpYWxpemVGb3JtID0gKGZvcm0sIG1ldGEgPSB7fSkgPT4ge1xuICAgIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKTtcbiAgICBsZXQgdG9SZW1vdmUgPSBbXTtcbiAgICBmb3JtRGF0YS5mb3JFYWNoKCh2YWwsIGtleSwgX2luZGV4KSA9PiB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICB0b1JlbW92ZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9SZW1vdmUuZm9yRWFjaCgoa2V5KSA9PiBmb3JtRGF0YS5kZWxldGUoa2V5KSk7XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgICAgcGFyYW1zLmFwcGVuZChrZXksIHZhbCk7XG4gICAgfVxuICAgIGZvciAobGV0IG1ldGFLZXkgaW4gbWV0YSkge1xuICAgICAgcGFyYW1zLmFwcGVuZChtZXRhS2V5LCBtZXRhW21ldGFLZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy50b1N0cmluZygpO1xuICB9O1xuICB2YXIgVmlldyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgbGl2ZVNvY2tldCwgcGFyZW50VmlldywgZmxhc2gpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXQ7XG4gICAgICB0aGlzLmZsYXNoID0gZmxhc2g7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFZpZXc7XG4gICAgICB0aGlzLnJvb3QgPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5yb290IDogdGhpcztcbiAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLmVsLmlkO1xuICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgdGhpcy5jaGlsZEpvaW5zID0gMDtcbiAgICAgIHRoaXMubG9hZGVyVGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICAgIHRoaXMucHJ1bmluZ0NJRHMgPSBbXTtcbiAgICAgIHRoaXMucmVkaXJlY3QgPSBmYWxzZTtcbiAgICAgIHRoaXMuaHJlZiA9IG51bGw7XG4gICAgICB0aGlzLmpvaW5Db3VudCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuam9pbkNvdW50IC0gMSA6IDA7XG4gICAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICB0aGlzLmpvaW5DYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IHRoaXMucGFyZW50ID8gbnVsbCA6IFtdO1xuICAgICAgdGhpcy52aWV3SG9va3MgPSB7fTtcbiAgICAgIHRoaXMudXBsb2FkZXJzID0ge307XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzID0gW107XG4gICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5wYXJlbnQgPyBudWxsIDoge307XG4gICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gPSB7fTtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IHRoaXMubGl2ZVNvY2tldC5jaGFubmVsKGBsdjoke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0ID8gdGhpcy5ocmVmIDogdm9pZCAwLFxuICAgICAgICAgIHVybDogdGhpcy5yZWRpcmVjdCA/IHZvaWQgMCA6IHRoaXMuaHJlZiB8fCB2b2lkIDAsXG4gICAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMoKSxcbiAgICAgICAgICBzZXNzaW9uOiB0aGlzLmdldFNlc3Npb24oKSxcbiAgICAgICAgICBzdGF0aWM6IHRoaXMuZ2V0U3RhdGljKCksXG4gICAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2hcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaG93TG9hZGVyKHRoaXMubGl2ZVNvY2tldC5sb2FkZXJUaW1lb3V0KTtcbiAgICAgIHRoaXMuYmluZENoYW5uZWwoKTtcbiAgICB9XG4gICAgc2V0SHJlZihocmVmKSB7XG4gICAgICB0aGlzLmhyZWYgPSBocmVmO1xuICAgIH1cbiAgICBzZXRSZWRpcmVjdChocmVmKSB7XG4gICAgICB0aGlzLnJlZGlyZWN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIGlzTWFpbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQubWFpbiA9PT0gdGhpcztcbiAgICB9XG4gICAgY29ubmVjdFBhcmFtcygpIHtcbiAgICAgIGxldCBwYXJhbXMgPSB0aGlzLmxpdmVTb2NrZXQucGFyYW1zKHRoaXMuZWwpO1xuICAgICAgbGV0IG1hbmlmZXN0ID0gZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9UUkFDS19TVEFUSUMpfV1gKS5tYXAoKG5vZGUpID0+IG5vZGUuc3JjIHx8IG5vZGUuaHJlZikuZmlsdGVyKCh1cmwpID0+IHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpO1xuICAgICAgaWYgKG1hbmlmZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFyYW1zW1wiX3RyYWNrX3N0YXRpY1wiXSA9IG1hbmlmZXN0O1xuICAgICAgfVxuICAgICAgcGFyYW1zW1wiX21vdW50c1wiXSA9IHRoaXMuam9pbkNvdW50O1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNhblB1c2goKTtcbiAgICB9XG4gICAgZ2V0U2Vzc2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTik7XG4gICAgfVxuICAgIGdldFN0YXRpYygpIHtcbiAgICAgIGxldCB2YWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKTtcbiAgICAgIHJldHVybiB2YWwgPT09IFwiXCIgPyBudWxsIDogdmFsO1xuICAgIH1cbiAgICBkZXN0cm95KGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKTtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF07XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLnBhcmVudC5pZF1bdGhpcy5pZF07XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7XG4gICAgICBsZXQgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpIHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3lIb29rKHRoaXMudmlld0hvb2tzW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkb21fZGVmYXVsdC5tYXJrUGh4Q2hpbGREZXN0cm95ZWQodGhpcy5lbCk7XG4gICAgICB0aGlzLmxvZyhcImRlc3Ryb3llZFwiLCAoKSA9PiBbXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl0pO1xuICAgICAgdGhpcy5jaGFubmVsLmxlYXZlKCkucmVjZWl2ZShcIm9rXCIsIG9uRmluaXNoZWQpLnJlY2VpdmUoXCJlcnJvclwiLCBvbkZpbmlzaGVkKS5yZWNlaXZlKFwidGltZW91dFwiLCBvbkZpbmlzaGVkKTtcbiAgICB9XG4gICAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKSB7XG4gICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoUEhYX0NPTk5FQ1RFRF9DTEFTUywgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUywgUEhYX0VSUk9SX0NMQVNTKTtcbiAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcbiAgICB9XG4gICAgaXNMb2FkaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFBIWF9ESVNDT05ORUNURURfQ0xBU1MpO1xuICAgIH1cbiAgICBzaG93TG9hZGVyKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKTtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMubG9hZGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2hvd0xvYWRlcigpLCB0aW1lb3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKSB7XG4gICAgICAgICAgdGhpcy52aWV3SG9va3NbaWRdLl9fZGlzY29ubmVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9ESVNDT05ORUNURURfQ0xBU1MpO1xuICAgICAgfVxuICAgIH1cbiAgICBoaWRlTG9hZGVyKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpO1xuICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9DT05ORUNURURfQ0xBU1MpO1xuICAgIH1cbiAgICB0cmlnZ2VyUmVjb25uZWN0ZWQoKSB7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcykge1xuICAgICAgICB0aGlzLnZpZXdIb29rc1tpZF0uX19yZWNvbm5lY3RlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2coa2luZCwgbXNnQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5sb2codGhpcywga2luZCwgbXNnQ2FsbGJhY2spO1xuICAgIH1cbiAgICB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChwaHhUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHBoeFRhcmdldCwgKHZpZXcpID0+IGNhbGxiYWNrKHZpZXcsIHBoeFRhcmdldCkpO1xuICAgICAgfVxuICAgICAgaWYgKC9eKDB8WzEtOV1cXGQqKSQvLnRlc3QocGh4VGFyZ2V0KSkge1xuICAgICAgICBsZXQgdGFyZ2V0cyA9IGRvbV9kZWZhdWx0LmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBwaHhUYXJnZXQpO1xuICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvdW5kIG1hdGNoaW5nIHBoeC10YXJnZXQgb2YgJHtwaHhUYXJnZXR9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sodGhpcywgdGFyZ2V0c1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0YXJnZXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBoeFRhcmdldCkpO1xuICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm90aGluZyBmb3VuZCBtYXRjaGluZyB0aGUgcGh4LXRhcmdldCBzZWxlY3RvciBcIiR7cGh4VGFyZ2V0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IHRoaXMubGl2ZVNvY2tldC5vd25lcih0YXJnZXQsICh2aWV3KSA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGx5RGlmZih0eXBlLCByYXdEaWZmLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5sb2codHlwZSwgKCkgPT4gW1wiXCIsIGNsb25lKHJhd0RpZmYpXSk7XG4gICAgICBsZXQgeyBkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZSB9ID0gUmVuZGVyZWQuZXh0cmFjdChyYXdEaWZmKTtcbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBkb21fZGVmYXVsdC5wdXRUaXRsZSh0aXRsZSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh7IGRpZmYsIHJlcGx5LCBldmVudHMgfSk7XG4gICAgICByZXR1cm4gcmVwbHk7XG4gICAgfVxuICAgIG9uSm9pbihyZXNwKSB7XG4gICAgICBsZXQgeyByZW5kZXJlZCwgY29udGFpbmVyIH0gPSByZXNwO1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmVsID0gZG9tX2RlZmF1bHQucmVwbGFjZVJvb3RDb250YWluZXIodGhpcy5lbCwgdGFnLCBhdHRycyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkSm9pbnMgPSAwO1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWU7XG4gICAgICB0aGlzLmZsYXNoID0gbnVsbDtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5kcm9wTG9jYWwodGhpcy5saXZlU29ja2V0LmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTKTtcbiAgICAgIHRoaXMuYXBwbHlEaWZmKFwibW91bnRcIiwgcmVuZGVyZWQsICh7IGRpZmYsIGV2ZW50cyB9KSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBuZXcgUmVuZGVyZWQodGhpcy5pZCwgZGlmZik7XG4gICAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJDb250YWluZXIobnVsbCwgXCJqb2luXCIpO1xuICAgICAgICB0aGlzLmRyb3BQZW5kaW5nUmVmcygpO1xuICAgICAgICBsZXQgZm9ybXMgPSB0aGlzLmZvcm1zRm9yUmVjb3ZlcnkoaHRtbCk7XG4gICAgICAgIHRoaXMuam9pbkNvdW50Kys7XG4gICAgICAgIGlmIChmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9ybXMuZm9yRWFjaCgoW2Zvcm0sIG5ld0Zvcm0sIG5ld0NpZF0sIGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIChyZXNwMikgPT4ge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gZm9ybXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcDIsIGh0bWwsIGV2ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgZXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGRyb3BQZW5kaW5nUmVmcygpIHtcbiAgICAgIGRvbV9kZWZhdWx0LmFsbCh0aGlzLmVsLCBgWyR7UEhYX1JFRn1dYCwgKGVsKSA9PiBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRikpO1xuICAgIH1cbiAgICBvbkpvaW5Db21wbGV0ZSh7IGxpdmVfcGF0Y2ggfSwgaHRtbCwgZXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPiAxIHx8IHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5pc0pvaW5QZW5kaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdDaGlsZHJlbiA9IGRvbV9kZWZhdWx0LmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKCh0b0VsKSA9PiB7XG4gICAgICAgIGxldCBmcm9tRWwgPSB0b0VsLmlkICYmIHRoaXMuZWwucXVlcnlTZWxlY3RvcihgW2lkPVwiJHt0b0VsLmlkfVwiXWApO1xuICAgICAgICBsZXQgcGh4U3RhdGljID0gZnJvbUVsICYmIGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQyk7XG4gICAgICAgIGlmIChwaHhTdGF0aWMpIHtcbiAgICAgICAgICB0b0VsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCBwaHhTdGF0aWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5DaGlsZCh0b0VsKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSk7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCk7XG4gICAgICAgICAgdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRydWVEb2NFbCgpIHtcbiAgICAgIHRoaXMuZWwgPSBkb21fZGVmYXVsdC5ieUlkKHRoaXMuaWQpO1xuICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZCk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXZlbnRzKGV2ZW50cykge1xuICAgICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHtcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGBwaHg6aG9vazoke2V2ZW50fWAsIHsgZGV0YWlsOiBwYXlsb2FkIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpIHtcbiAgICAgIHRoaXMuYXR0YWNoVHJ1ZURvY0VsKCk7XG4gICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgbnVsbCk7XG4gICAgICBwYXRjaC5tYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpO1xuICAgICAgdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIGZhbHNlKTtcbiAgICAgIHRoaXMuam9pbk5ld0NoaWxkcmVuKCk7XG4gICAgICBkb21fZGVmYXVsdC5hbGwodGhpcy5lbCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIChob29rRWwpID0+IHtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLmFkZEhvb2soaG9va0VsKTtcbiAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICBob29rLl9fbW91bnRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKTtcbiAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpO1xuICAgICAgaWYgKGxpdmVfcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsga2luZCwgdG8gfSA9IGxpdmVfcGF0Y2g7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRlTG9hZGVyKCk7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPiAxKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3BDYWxsYmFjaygpO1xuICAgIH1cbiAgICB0cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25CZWZvcmVFbFVwZGF0ZWRcIiwgW2Zyb21FbCwgdG9FbF0pO1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soZnJvbUVsKTtcbiAgICAgIGxldCBpc0lnbm9yZWQgPSBob29rICYmIGRvbV9kZWZhdWx0LmlzSWdub3JlZChmcm9tRWwsIHRoaXMuYmluZGluZyhQSFhfVVBEQVRFKSk7XG4gICAgICBpZiAoaG9vayAmJiAhZnJvbUVsLmlzRXF1YWxOb2RlKHRvRWwpICYmICEoaXNJZ25vcmVkICYmIGlzRXF1YWxPYmooZnJvbUVsLmRhdGFzZXQsIHRvRWwuZGF0YXNldCkpKSB7XG4gICAgICAgIGhvb2suX19iZWZvcmVVcGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIGhvb2s7XG4gICAgICB9XG4gICAgfVxuICAgIHBlcmZvcm1QYXRjaChwYXRjaCwgcHJ1bmVDaWRzKSB7XG4gICAgICBsZXQgZGVzdHJveWVkQ0lEcyA9IFtdO1xuICAgICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZTtcbiAgICAgIGxldCB1cGRhdGVkSG9va0lkcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBhdGNoLmFmdGVyKFwiYWRkZWRcIiwgKGVsKSA9PiB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25Ob2RlQWRkZWRcIiwgW2VsXSk7XG4gICAgICAgIGxldCBuZXdIb29rID0gdGhpcy5hZGRIb29rKGVsKTtcbiAgICAgICAgaWYgKG5ld0hvb2spIHtcbiAgICAgICAgICBuZXdIb29rLl9fbW91bnRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBhdGNoLmFmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCAoX2VsKSA9PiBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZSk7XG4gICAgICBwYXRjaC5iZWZvcmUoXCJ1cGRhdGVkXCIsIChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIGlmIChob29rKSB7XG4gICAgICAgICAgdXBkYXRlZEhvb2tJZHMuYWRkKGZyb21FbC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGF0Y2guYWZ0ZXIoXCJ1cGRhdGVkXCIsIChlbCkgPT4ge1xuICAgICAgICBpZiAodXBkYXRlZEhvb2tJZHMuaGFzKGVsLmlkKSkge1xuICAgICAgICAgIHRoaXMuZ2V0SG9vayhlbCkuX191cGRhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGF0Y2guYWZ0ZXIoXCJkaXNjYXJkZWRcIiwgKGVsKSA9PiB7XG4gICAgICAgIGxldCBjaWQgPSB0aGlzLmNvbXBvbmVudElEKGVsKTtcbiAgICAgICAgaWYgKGlzQ2lkKGNpZCkgJiYgZGVzdHJveWVkQ0lEcy5pbmRleE9mKGNpZCkgPT09IC0xKSB7XG4gICAgICAgICAgZGVzdHJveWVkQ0lEcy5wdXNoKGNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soZWwpO1xuICAgICAgICBob29rICYmIHRoaXMuZGVzdHJveUhvb2soaG9vayk7XG4gICAgICB9KTtcbiAgICAgIHBhdGNoLnBlcmZvcm0oKTtcbiAgICAgIGlmIChwcnVuZUNpZHMpIHtcbiAgICAgICAgdGhpcy5tYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBoeENoaWxkcmVuQWRkZWQ7XG4gICAgfVxuICAgIGpvaW5OZXdDaGlsZHJlbigpIHtcbiAgICAgIGRvbV9kZWZhdWx0LmZpbmRQaHhDaGlsZHJlbih0aGlzLmVsLCB0aGlzLmlkKS5mb3JFYWNoKChlbCkgPT4gdGhpcy5qb2luQ2hpbGQoZWwpKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRCeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW2lkXTtcbiAgICB9XG4gICAgZ2V0RGVzY2VuZGVudEJ5RWwoZWwpIHtcbiAgICAgIGlmIChlbC5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2VsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKV1bZWwuaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95RGVzY2VuZGVudChpZCkge1xuICAgICAgZm9yIChsZXQgcGFyZW50SWQgaW4gdGhpcy5yb290LmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkSWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXSkge1xuICAgICAgICAgIGlmIChjaGlsZElkID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF1bY2hpbGRJZF0uZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBqb2luQ2hpbGQoZWwpIHtcbiAgICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRCeUlkKGVsLmlkKTtcbiAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcy5saXZlU29ja2V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW3ZpZXcuaWRdID0gdmlldztcbiAgICAgICAgdmlldy5qb2luKCk7XG4gICAgICAgIHRoaXMuY2hpbGRKb2lucysrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXNKb2luUGVuZGluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmpvaW5QZW5kaW5nO1xuICAgIH1cbiAgICBhY2tKb2luKF9jaGlsZCkge1xuICAgICAgdGhpcy5jaGlsZEpvaW5zLS07XG4gICAgICBpZiAodGhpcy5jaGlsZEpvaW5zID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCkge1xuICAgICAgdGhpcy5qb2luQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICBpZiAoIXZpZXcuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICAgIG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IFtdO1xuICAgIH1cbiAgICB1cGRhdGUoZGlmZiwgZXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5pc0pvaW5QZW5kaW5nKCkgfHwgdGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goeyBkaWZmLCBldmVudHMgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKTtcbiAgICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgICBsZXQgcGFyZW50Q2lkcyA9IGRvbV9kZWZhdWx0LmZpbmRQYXJlbnRDSURzKHRoaXMuZWwsIHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKSk7XG4gICAgICAgICAgcGFyZW50Q2lkcy5mb3JFYWNoKChwYXJlbnRDSUQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFBhdGNoKHRoaXMucmVuZGVyZWQuZ2V0Q29tcG9uZW50KGRpZmYsIHBhcmVudENJRCksIHBhcmVudENJRCkpIHtcbiAgICAgICAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghaXNFbXB0eShkaWZmKSkge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJDb250YWluZXIoZGlmZiwgXCJ1cGRhdGVcIik7XG4gICAgICAgICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIHRoaXMuZWwsIHRoaXMuaWQsIGh0bWwsIG51bGwpO1xuICAgICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50cyhldmVudHMpO1xuICAgICAgaWYgKHBoeENoaWxkcmVuQWRkZWQpIHtcbiAgICAgICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQ29udGFpbmVyKGRpZmYsIGtpbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQudGltZShgdG9TdHJpbmcgZGlmZiAoJHtraW5kfSlgLCAoKSA9PiB7XG4gICAgICAgIGxldCB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgICAgIGxldCBjaWRzID0gZGlmZiA/IHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKS5jb25jYXQodGhpcy5wcnVuaW5nQ0lEcykgOiBudWxsO1xuICAgICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQudG9TdHJpbmcoY2lkcyk7XG4gICAgICAgIHJldHVybiBgPCR7dGFnfT4ke2h0bWx9PC8ke3RhZ30+YDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb25lbnRQYXRjaChkaWZmLCBjaWQpIHtcbiAgICAgIGlmIChpc0VtcHR5KGRpZmYpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKTtcbiAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBjaWQpO1xuICAgICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gY2hpbGRyZW5BZGRlZDtcbiAgICB9XG4gICAgZ2V0SG9vayhlbCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChlbCldO1xuICAgIH1cbiAgICBhZGRIb29rKGVsKSB7XG4gICAgICBpZiAoVmlld0hvb2suZWxlbWVudElEKGVsKSB8fCAhZWwuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBob29rTmFtZSA9IGVsLmdldEF0dHJpYnV0ZShgZGF0YS1waHgtJHtQSFhfSE9PS31gKSB8fCBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9IT09LKSk7XG4gICAgICBpZiAoaG9va05hbWUgJiYgIXRoaXMub3duc0VsZW1lbnQoZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLmxpdmVTb2NrZXQuZ2V0SG9va0NhbGxiYWNrcyhob29rTmFtZSk7XG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghZWwuaWQpIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm8gRE9NIElEIGZvciBob29rIFwiJHtob29rTmFtZX1cIi4gSG9va3MgcmVxdWlyZSBhIHVuaXF1ZSBJRCBvbiBlYWNoIGVsZW1lbnQuYCwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBob29rID0gbmV3IFZpZXdIb29rKHRoaXMsIGVsLCBjYWxsYmFja3MpO1xuICAgICAgICB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldID0gaG9vaztcbiAgICAgICAgcmV0dXJuIGhvb2s7XG4gICAgICB9IGVsc2UgaWYgKGhvb2tOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveUhvb2soaG9vaykge1xuICAgICAgaG9vay5fX2Rlc3Ryb3llZCgpO1xuICAgICAgaG9vay5fX2NsZWFudXBfXygpO1xuICAgICAgZGVsZXRlIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV07XG4gICAgfVxuICAgIGFwcGx5UGVuZGluZ1VwZGF0ZXMoKSB7XG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKCh7IGRpZmYsIGV2ZW50cyB9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKTtcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgfVxuICAgIG9uQ2hhbm5lbChldmVudCwgY2IpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBldmVudCwgKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNKb2luUGVuZGluZygpKSB7XG4gICAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IocmVzcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBiaW5kQ2hhbm5lbCgpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBcImRpZmZcIiwgKHJhd0RpZmYpID0+IHtcbiAgICAgICAgdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmF3RGlmZiwgKHsgZGlmZiwgZXZlbnRzIH0pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uQ2hhbm5lbChcInJlZGlyZWN0XCIsICh7IHRvLCBmbGFzaCB9KSA9PiB0aGlzLm9uUmVkaXJlY3QoeyB0bywgZmxhc2ggfSkpO1xuICAgICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpO1xuICAgICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKHJlYXNvbikgPT4gdGhpcy5vbkVycm9yKHJlYXNvbikpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uQ2xvc2UoKHJlYXNvbikgPT4gdGhpcy5vbkNsb3NlKHJlYXNvbikpO1xuICAgIH1cbiAgICBkZXN0cm95QWxsQ2hpbGRyZW4oKSB7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0pIHtcbiAgICAgICAgdGhpcy5nZXRDaGlsZEJ5SWQoaWQpLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25MaXZlUmVkaXJlY3QocmVkaXIpIHtcbiAgICAgIGxldCB7IHRvLCBraW5kLCBmbGFzaCB9ID0gcmVkaXI7XG4gICAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pO1xuICAgICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdCh1cmwsIGtpbmQsIGZsYXNoKTtcbiAgICB9XG4gICAgb25MaXZlUGF0Y2gocmVkaXIpIHtcbiAgICAgIGxldCB7IHRvLCBraW5kIH0gPSByZWRpcjtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMuZXhwYW5kVVJMKHRvKTtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpO1xuICAgIH1cbiAgICBleHBhbmRVUkwodG8pIHtcbiAgICAgIHJldHVybiB0by5zdGFydHNXaXRoKFwiL1wiKSA/IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9JHt0b31gIDogdG87XG4gICAgfVxuICAgIG9uUmVkaXJlY3QoeyB0bywgZmxhc2ggfSkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCk7XG4gICAgfVxuICAgIGlzRGVzdHJveWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveWVkO1xuICAgIH1cbiAgICBqb2luKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7IHRvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiaW5pdGlhbFwiIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5qb2luQ2FsbGJhY2sgPSAoKSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzLmpvaW5Db3VudCk7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywgeyB0aW1lb3V0OiBmYWxzZSB9LCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwuam9pbigpLnJlY2VpdmUoXCJva1wiLCAoZGF0YSkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbihkYXRhKSkucmVjZWl2ZShcImVycm9yXCIsIChyZXNwKSA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3IocmVzcCkpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgdGhpcy5vbkpvaW5FcnJvcih7IHJlYXNvbjogXCJ0aW1lb3V0XCIgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIG9uSm9pbkVycm9yKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLnJlYXNvbiA9PT0gXCJ1bmF1dGhvcml6ZWRcIiB8fCByZXNwLnJlYXNvbiA9PT0gXCJzdGFsZVwiKSB7XG4gICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hdXRob3JpemVkIGxpdmVfcmVkaXJlY3QuIEZhbGxpbmcgYmFjayB0byBwYWdlIHJlcXVlc3RcIiwgcmVzcF0pO1xuICAgICAgICByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHsgdG86IHRoaXMuaHJlZiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwLnJlZGlyZWN0IHx8IHJlc3AubGl2ZV9yZWRpcmVjdCkge1xuICAgICAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3AucmVkaXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwLmxpdmVfcmVkaXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hYmxlIHRvIGpvaW5cIiwgcmVzcF0pO1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpO1xuICAgIH1cbiAgICBvbkNsb3NlKHJlYXNvbikge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0pvaW5QZW5kaW5nKCkgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiIHx8IHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpICYmIHJlYXNvbiAhPT0gXCJsZWF2ZVwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKCk7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZHJvcEFjdGl2ZUVsZW1lbnQodGhpcyk7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKSB7XG4gICAgICAgIHRoaXMuc2hvd0xvYWRlcihCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25FcnJvcihyZWFzb24pIHtcbiAgICAgIHRoaXMub25DbG9zZShyZWFzb24pO1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ2aWV3IGNyYXNoZWRcIiwgcmVhc29uXSk7XG4gICAgICBpZiAoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGxheUVycm9yKCkge1xuICAgICAgaWYgKHRoaXMuaXNNYWluKCkpIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7IHRvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIiB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hvd0xvYWRlcigpO1xuICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9ESVNDT05ORUNURURfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUyk7XG4gICAgfVxuICAgIHB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSA9IGZ1bmN0aW9uKCkge1xuICAgIH0pIHtcbiAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBbcmVmLCBbZWxdXSA9IHJlZkdlbmVyYXRvciA/IHJlZkdlbmVyYXRvcigpIDogW251bGwsIFtdXTtcbiAgICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgaWYgKGVsICYmIGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX1BBR0VfTE9BRElORykpICE9PSBudWxsKSB7XG4gICAgICAgIG9uTG9hZGluZ0RvbmUgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHsga2luZDogXCJlbGVtZW50XCIsIHRhcmdldDogZWwgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQuY2lkICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGRlbGV0ZSBwYXlsb2FkLmNpZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywgeyB0aW1lb3V0OiB0cnVlIH0sICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5wdXNoKGV2ZW50LCBwYXlsb2FkLCBQVVNIX1RJTUVPVVQpLnJlY2VpdmUoXCJva1wiLCAocmVzcCkgPT4ge1xuICAgICAgICAgIGxldCBob29rUmVwbHkgPSBudWxsO1xuICAgICAgICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3AuZGlmZikge1xuICAgICAgICAgICAgaG9va1JlcGx5ID0gdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmVzcC5kaWZmLCAoeyBkaWZmLCBldmVudHMgfSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNwLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNwLmxpdmVfcGF0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMub25MaXZlUGF0Y2gocmVzcC5saXZlX3BhdGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3AubGl2ZV9yZWRpcmVjdCkge1xuICAgICAgICAgICAgdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbkxvYWRpbmdEb25lKCk7XG4gICAgICAgICAgb25SZXBseShyZXNwLCBob29rUmVwbHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB1bmRvUmVmcyhyZWYpIHtcbiAgICAgIGRvbV9kZWZhdWx0LmFsbCh0aGlzLmVsLCBgWyR7UEhYX1JFRn09XCIke3JlZn1cIl1gLCAoZWwpID0+IHtcbiAgICAgICAgbGV0IGRpc2FibGVkVmFsID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCk7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGKTtcbiAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpICE9PSBudWxsKSB7XG4gICAgICAgICAgZWwucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZWRWYWwgIT09IG51bGwpIHtcbiAgICAgICAgICBlbC5kaXNhYmxlZCA9IGRpc2FibGVkVmFsID09PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVEKTtcbiAgICAgICAgfVxuICAgICAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKChjbGFzc05hbWUpID0+IGRvbV9kZWZhdWx0LnJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpKTtcbiAgICAgICAgbGV0IGRpc2FibGVSZXN0b3JlID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSk7XG4gICAgICAgIGlmIChkaXNhYmxlUmVzdG9yZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVsLmlubmVyVGV4dCA9IGRpc2FibGVSZXN0b3JlO1xuICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VsID0gZG9tX2RlZmF1bHQucHJpdmF0ZShlbCwgUEhYX1JFRik7XG4gICAgICAgIGlmICh0b0VsKSB7XG4gICAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGVsLCB0b0VsKTtcbiAgICAgICAgICBET01QYXRjaC5wYXRjaEVsKGVsLCB0b0VsLCB0aGlzLmxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpKTtcbiAgICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgaG9vay5fX3VwZGF0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tX2RlZmF1bHQuZGVsZXRlUHJpdmF0ZShlbCwgUEhYX1JFRik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXRSZWYoZWxlbWVudHMsIGV2ZW50KSB7XG4gICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYrKztcbiAgICAgIGxldCBkaXNhYmxlV2l0aCA9IHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKTtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50fS1sb2FkaW5nYCk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGLCBuZXdSZWYpO1xuICAgICAgICBsZXQgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpO1xuICAgICAgICBpZiAoZGlzYWJsZVRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLCBlbC5pbm5lclRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC5pbm5lclRleHQgPSBkaXNhYmxlVGV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW25ld1JlZiwgZWxlbWVudHNdO1xuICAgIH1cbiAgICBjb21wb25lbnRJRChlbCkge1xuICAgICAgbGV0IGNpZCA9IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCk7XG4gICAgICByZXR1cm4gY2lkID8gcGFyc2VJbnQoY2lkKSA6IG51bGw7XG4gICAgfVxuICAgIHRhcmdldENvbXBvbmVudElEKHRhcmdldCwgdGFyZ2V0Q3R4KSB7XG4gICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJ0YXJnZXRcIikpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpIHtcbiAgICAgIGlmICh0YXJnZXRDdHgpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlKHRhcmdldEN0eC5jbG9zZXN0KGBbJHtQSFhfQ09NUE9ORU5UfV1gKSwgKGVsKSA9PiB0aGlzLm93bnNFbGVtZW50KGVsKSAmJiB0aGlzLmNvbXBvbmVudElEKGVsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVzaEhvb2tFdmVudCh0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLmxvZyhcImhvb2tcIiwgKCkgPT4gW1widW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiLCBldmVudCwgcGF5bG9hZF0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHRoaXMucHV0UmVmKFtdLCBcImhvb2tcIik7XG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkoKCkgPT4gW3JlZiwgZWxzXSwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGU6IFwiaG9va1wiLFxuICAgICAgICBldmVudCxcbiAgICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICAgIGNpZDogdGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KVxuICAgICAgfSwgKHJlc3AsIHJlcGx5KSA9PiBvblJlcGx5KHJlcGx5LCByZWYpKTtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIGV4dHJhY3RNZXRhKGVsLCBtZXRhKSB7XG4gICAgICBsZXQgcHJlZml4ID0gdGhpcy5iaW5kaW5nKFwidmFsdWUtXCIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuYW1lID0gZWwuYXR0cmlidXRlc1tpXS5uYW1lO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICBtZXRhW25hbWUucmVwbGFjZShwcmVmaXgsIFwiXCIpXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsLnZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWV0YS52YWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwICYmICFlbC5jaGVja2VkKSB7XG4gICAgICAgICAgZGVsZXRlIG1ldGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cbiAgICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEpIHtcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiB0aGlzLnB1dFJlZihbZWxdLCB0eXBlKSwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IHRoaXMuZXh0cmFjdE1ldGEoZWwsIG1ldGEpLFxuICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXNoS2V5KGtleUVsZW1lbnQsIHRhcmdldEN0eCwga2luZCwgcGh4RXZlbnQsIG1ldGEpIHtcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiB0aGlzLnB1dFJlZihba2V5RWxlbWVudF0sIGtpbmQpLCBcImV2ZW50XCIsIHtcbiAgICAgICAgdHlwZToga2luZCxcbiAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShrZXlFbGVtZW50LCBtZXRhKSxcbiAgICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGtleUVsZW1lbnQsIHRhcmdldEN0eClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXNoRmlsZVByb2dyZXNzKGZpbGVFbCwgZW50cnlSZWYsIHByb2dyZXNzLCBvblJlcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmaWxlRWwuZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgICB2aWV3LnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgICAgZXZlbnQ6IGZpbGVFbC5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFBIWF9QUk9HUkVTUykpLFxuICAgICAgICAgIHJlZjogZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgICBjaWQ6IHZpZXcudGFyZ2V0Q29tcG9uZW50SUQoZmlsZUVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgICAgfSwgb25SZXBseSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHVzaElucHV0KGlucHV0RWwsIHRhcmdldEN0eCwgZm9yY2VDaWQsIHBoeEV2ZW50LCBldmVudFRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCB1cGxvYWRzO1xuICAgICAgbGV0IGNpZCA9IGlzQ2lkKGZvcmNlQ2lkKSA/IGZvcmNlQ2lkIDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eCk7XG4gICAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5wdXRSZWYoW2lucHV0RWwsIGlucHV0RWwuZm9ybV0sIFwiY2hhbmdlXCIpO1xuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHsgX3RhcmdldDogZXZlbnRUYXJnZXQubmFtZSB9KTtcbiAgICAgIGlmIChpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKTtcbiAgICAgIH1cbiAgICAgIHVwbG9hZHMgPSBMaXZlVXBsb2FkZXIuc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKTtcbiAgICAgIGxldCBldmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICB1cGxvYWRzLFxuICAgICAgICBjaWRcbiAgICAgIH07XG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIGV2ZW50LCAocmVzcCkgPT4ge1xuICAgICAgICBkb21fZGVmYXVsdC5zaG93RXJyb3IoaW5wdXRFbCwgdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUikpO1xuICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpO1xuICAgICAgICAgICAgdGhpcy51cGxvYWRGaWxlcyhpbnB1dEVsLmZvcm0sIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQXdhaXRpbmdTdWJtaXQoaW5wdXRFbC5mb3JtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyaWdnZXJBd2FpdGluZ1N1Ym1pdChmb3JtRWwpIHtcbiAgICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCk7XG4gICAgICBpZiAoYXdhaXRpbmdTdWJtaXQpIHtcbiAgICAgICAgbGV0IFtfZWwsIF9yZWYsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0O1xuICAgICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtU3VibWl0cy5maW5kKChbZWwsIF9jYWxsYmFja10pID0+IGVsLmlzU2FtZU5vZGUoZm9ybUVsKSk7XG4gICAgfVxuICAgIHNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzLnB1c2goW2Zvcm1FbCwgcmVmLCBjYWxsYmFja10pO1xuICAgIH1cbiAgICBjYW5jZWxTdWJtaXQoZm9ybUVsKSB7XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzID0gdGhpcy5mb3JtU3VibWl0cy5maWx0ZXIoKFtlbCwgcmVmLCBfY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgIGlmIChlbC5pc1NhbWVOb2RlKGZvcm1FbCkpIHtcbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvblJlcGx5KSB7XG4gICAgICBsZXQgZmlsdGVySWdub3JlZCA9IChlbCkgPT4ge1xuICAgICAgICBsZXQgdXNlcklnbm9yZWQgPSBjbG9zZXN0UGh4QmluZGluZyhlbCwgYCR7dGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpfT1pZ25vcmVgLCBlbC5mb3JtKTtcbiAgICAgICAgcmV0dXJuICEodXNlcklnbm9yZWQgfHwgY2xvc2VzdFBoeEJpbmRpbmcoZWwsIFwiZGF0YS1waHgtdXBkYXRlPWlnbm9yZVwiLCBlbC5mb3JtKSk7XG4gICAgICB9O1xuICAgICAgbGV0IGZpbHRlckRpc2FibGVzID0gKGVsKSA9PiB7XG4gICAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpKTtcbiAgICAgIH07XG4gICAgICBsZXQgZmlsdGVyQnV0dG9uID0gKGVsKSA9PiBlbC50YWdOYW1lID09IFwiQlVUVE9OXCI7XG4gICAgICBsZXQgZmlsdGVySW5wdXQgPSAoZWwpID0+IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl0uaW5jbHVkZXMoZWwudGFnTmFtZSk7XG4gICAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4ge1xuICAgICAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpO1xuICAgICAgICBsZXQgZGlzYWJsZXMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckRpc2FibGVzKTtcbiAgICAgICAgbGV0IGJ1dHRvbnMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckJ1dHRvbikuZmlsdGVyKGZpbHRlcklnbm9yZWQpO1xuICAgICAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpO1xuICAgICAgICBidXR0b25zLmZvckVhY2goKGJ1dHRvbikgPT4ge1xuICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpO1xuICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSk7XG4gICAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgIGlmIChpbnB1dC5maWxlcykge1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCwgaW5wdXQuZGlzYWJsZWQpO1xuICAgICAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm1FbC5zZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0UmVmKFtmb3JtRWxdLmNvbmNhdChkaXNhYmxlcykuY29uY2F0KGJ1dHRvbnMpLmNvbmNhdChpbnB1dHMpLCBcInN1Ym1pdFwiKTtcbiAgICAgIH07XG4gICAgICBsZXQgY2lkID0gdGhpcy50YXJnZXRDb21wb25lbnRJRChmb3JtRWwsIHRhcmdldEN0eCk7XG4gICAgICBpZiAoTGl2ZVVwbG9hZGVyLmhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCkpIHtcbiAgICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCAoKSA9PiB0aGlzLnB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb25SZXBseSkpO1xuICAgICAgfSBlbHNlIGlmIChMaXZlVXBsb2FkZXIuaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBbcmVmLCBlbHNdID0gcmVmR2VuZXJhdG9yKCk7XG4gICAgICAgIGxldCBwcm94eVJlZkdlbiA9ICgpID0+IFtyZWYsIGVsc107XG4gICAgICAgIHRoaXMudXBsb2FkRmlsZXMoZm9ybUVsLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCAoX3VwbG9hZHMpID0+IHtcbiAgICAgICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwge30pO1xuICAgICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShwcm94eVJlZkdlbiwgXCJldmVudFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICAgIGNpZFxuICAgICAgICAgIH0sIG9uUmVwbHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsKTtcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICBjaWRcbiAgICAgICAgfSwgb25SZXBseSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgb25Db21wbGV0ZSkge1xuICAgICAgbGV0IGpvaW5Db3VudEF0VXBsb2FkID0gdGhpcy5qb2luQ291bnQ7XG4gICAgICBsZXQgaW5wdXRFbHMgPSBMaXZlVXBsb2FkZXIuYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpO1xuICAgICAgbGV0IG51bUZpbGVJbnB1dHNJblByb2dyZXNzID0gaW5wdXRFbHMubGVuZ3RoO1xuICAgICAgaW5wdXRFbHMuZm9yRWFjaCgoaW5wdXRFbCkgPT4ge1xuICAgICAgICBsZXQgdXBsb2FkZXIgPSBuZXcgTGl2ZVVwbG9hZGVyKGlucHV0RWwsIHRoaXMsICgpID0+IHtcbiAgICAgICAgICBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcy0tO1xuICAgICAgICAgIGlmIChudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9PT0gMCkge1xuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBsb2FkZXJzW2lucHV0RWxdID0gdXBsb2FkZXI7XG4gICAgICAgIGxldCBlbnRyaWVzID0gdXBsb2FkZXIuZW50cmllcygpLm1hcCgoZW50cnkpID0+IGVudHJ5LnRvUHJlZmxpZ2h0UGF5bG9hZCgpKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgICAgcmVmOiBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcInNlbmRpbmcgcHJlZmxpZ2h0IHJlcXVlc3RcIiwgcGF5bG9hZF0pO1xuICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJhbGxvd191cGxvYWRcIiwgcGF5bG9hZCwgKHJlc3ApID0+IHtcbiAgICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJnb3QgcHJlZmxpZ2h0IHJlc3BvbnNlXCIsIHJlc3BdKTtcbiAgICAgICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpO1xuICAgICAgICAgICAgbGV0IFtlbnRyeV9yZWYsIHJlYXNvbl0gPSByZXNwLmVycm9yO1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHtlbnRyeV9yZWZ9YCwgcmVhc29uXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvbkVycm9yID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5vbkVycm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5qb2luQ291bnQgPT09IGpvaW5Db3VudEF0VXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXBsb2FkZXIuaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgdGhpcy5saXZlU29ja2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoVXBsb2FkcyhuYW1lLCBmaWxlc09yQmxvYnMpIHtcbiAgICAgIGxldCBpbnB1dHMgPSBkb21fZGVmYXVsdC5maW5kVXBsb2FkSW5wdXRzKHRoaXMuZWwpLmZpbHRlcigoZWwpID0+IGVsLm5hbWUgPT09IG5hbWUpO1xuICAgICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nRXJyb3IoYG5vIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbG9nRXJyb3IoYGR1cGxpY2F0ZSBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KGlucHV0c1swXSwgUEhYX1RSQUNLX1VQTE9BRFMsIHsgZmlsZXM6IGZpbGVzT3JCbG9icyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgICAgbGV0IGlucHV0ID0gZm9ybS5lbGVtZW50c1swXTtcbiAgICAgICAgbGV0IHBoeEV2ZW50ID0gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpO1xuICAgICAgICB2aWV3LnB1c2hJbnB1dChpbnB1dCwgdGFyZ2V0Q3R4LCBuZXdDaWQsIHBoeEV2ZW50LCBpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKTtcbiAgICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt0YXJnZXRFbF0sIFwiY2xpY2tcIikgOiBudWxsO1xuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbiwgXCJsaXZlX3BhdGNoXCIsIHsgdXJsOiBocmVmIH0sIChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwLmxpbmtfcmVkaXJlY3QpIHtcbiAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgY2FsbGJhY2ssIGxpbmtSZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpIHtcbiAgICAgICAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGxpbmtSZWYpO1xuICAgICAgICB9XG4gICAgICB9KS5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKTtcbiAgICB9XG4gICAgZm9ybXNGb3JSZWNvdmVyeShodG1sKSB7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKTtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICByZXR1cm4gZG9tX2RlZmF1bHQuYWxsKHRoaXMuZWwsIGBmb3JtWyR7cGh4Q2hhbmdlfV1gKS5maWx0ZXIoKGZvcm0pID0+IGZvcm0uaWQgJiYgdGhpcy5vd25zRWxlbWVudChmb3JtKSkuZmlsdGVyKChmb3JtKSA9PiBmb3JtLmVsZW1lbnRzLmxlbmd0aCA+IDApLmZpbHRlcigoZm9ybSkgPT4gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIikubWFwKChmb3JtKSA9PiB7XG4gICAgICAgIGxldCBuZXdGb3JtID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKGBmb3JtW2lkPVwiJHtmb3JtLmlkfVwiXVske3BoeENoYW5nZX09XCIke2Zvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSl9XCJdYCk7XG4gICAgICAgIGlmIChuZXdGb3JtKSB7XG4gICAgICAgICAgcmV0dXJuIFtmb3JtLCBuZXdGb3JtLCB0aGlzLmNvbXBvbmVudElEKG5ld0Zvcm0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2Zvcm0sIG51bGwsIG51bGxdO1xuICAgICAgICB9XG4gICAgICB9KS5maWx0ZXIoKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdKSA9PiBuZXdGb3JtKTtcbiAgICB9XG4gICAgbWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKSB7XG4gICAgICBsZXQgd2lsbERlc3Ryb3lDSURzID0gZGVzdHJveWVkQ0lEcy5maWx0ZXIoKGNpZCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9tX2RlZmF1bHQuZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIGNpZCkubGVuZ3RoID09PSAwO1xuICAgICAgfSk7XG4gICAgICBpZiAod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wcnVuaW5nQ0lEcy5wdXNoKC4uLndpbGxEZXN0cm95Q0lEcyk7XG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfd2lsbF9kZXN0cm95XCIsIHsgY2lkczogd2lsbERlc3Ryb3lDSURzIH0sICgpID0+IHtcbiAgICAgICAgICB0aGlzLnBydW5pbmdDSURzID0gdGhpcy5wcnVuaW5nQ0lEcy5maWx0ZXIoKGNpZCkgPT4gd2lsbERlc3Ryb3lDSURzLmluZGV4T2YoY2lkKSAhPT0gLTEpO1xuICAgICAgICAgIGxldCBjb21wbGV0ZWx5RGVzdHJveUNJRHMgPSB3aWxsRGVzdHJveUNJRHMuZmlsdGVyKChjaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNvbXBsZXRlbHlEZXN0cm95Q0lEcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX2Rlc3Ryb3llZFwiLCB7IGNpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyB9LCAocmVzcCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3duc0VsZW1lbnQoZWwpIHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCkgPT09IHRoaXMuaWQgfHwgbWF5YmUoZWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIChub2RlKSA9PiBub2RlLmlkKSA9PT0gdGhpcy5pZDtcbiAgICB9XG4gICAgc3VibWl0Rm9ybShmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50KSB7XG4gICAgICBkb21fZGVmYXVsdC5wdXRQcml2YXRlKGZvcm0sIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKTtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5ibHVyQWN0aXZlRWxlbWVudCh0aGlzKTtcbiAgICAgIHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgKCkgPT4ge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmRpbmcoa2luZCkge1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKGtpbmQpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3NvY2tldC5qc1xuICB2YXIgTGl2ZVNvY2tldCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHBoeFNvY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgICB0aGlzLnVubG9hZGVkID0gZmFsc2U7XG4gICAgICBpZiAoIXBoeFNvY2tldCB8fCBwaHhTb2NrZXQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgYSBwaG9lbml4IFNvY2tldCBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExpdmVTb2NrZXQgY29uc3RydWN0b3IuIEZvciBleGFtcGxlOlxuXG4gICAgICAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAgICAgICAgICBpbXBvcnQgTGl2ZVNvY2tldCBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldCA9IG5ldyBwaHhTb2NrZXQodXJsLCBvcHRzKTtcbiAgICAgIHRoaXMuYmluZGluZ1ByZWZpeCA9IG9wdHMuYmluZGluZ1ByZWZpeCB8fCBCSU5ESU5HX1BSRUZJWDtcbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pO1xuICAgICAgdGhpcy52aWV3TG9nZ2VyID0gb3B0cy52aWV3TG9nZ2VyO1xuICAgICAgdGhpcy5tZXRhZGF0YUNhbGxiYWNrcyA9IG9wdHMubWV0YWRhdGEgfHwge307XG4gICAgICB0aGlzLmRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihjbG9uZShERUZBVUxUUyksIG9wdHMuZGVmYXVsdHMgfHwge30pO1xuICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMucHJldkFjdGl2ZSA9IG51bGw7XG4gICAgICB0aGlzLnNpbGVuY2VkID0gZmFsc2U7XG4gICAgICB0aGlzLm1haW4gPSBudWxsO1xuICAgICAgdGhpcy5saW5rUmVmID0gMTtcbiAgICAgIHRoaXMucm9vdHMgPSB7fTtcbiAgICAgIHRoaXMuaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKHdpbmRvdy5sb2NhdGlvbik7XG4gICAgICB0aGlzLmhvb2tzID0gb3B0cy5ob29rcyB8fCB7fTtcbiAgICAgIHRoaXMudXBsb2FkZXJzID0gb3B0cy51cGxvYWRlcnMgfHwge307XG4gICAgICB0aGlzLmxvYWRlclRpbWVvdXQgPSBvcHRzLmxvYWRlclRpbWVvdXQgfHwgTE9BREVSX1RJTUVPVVQ7XG4gICAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG9wdHMubG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlID0gb3B0cy5zZXNzaW9uU3RvcmFnZSB8fCB3aW5kb3cuc2Vzc2lvblN0b3JhZ2U7XG4gICAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9tQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7IG9uTm9kZUFkZGVkOiBjbG9zdXJlKCksIG9uQmVmb3JlRWxVcGRhdGVkOiBjbG9zdXJlKCkgfSwgb3B0cy5kb20gfHwge30pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCAoX2UpID0+IHtcbiAgICAgICAgdGhpcy51bmxvYWRlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5sb2FkZWQoKSkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzUHJvZmlsZUVuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9QUk9GSUxFKSA9PT0gXCJ0cnVlXCI7XG4gICAgfVxuICAgIGlzRGVidWdFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcInRydWVcIjtcbiAgICB9XG4gICAgZW5hYmxlRGVidWcoKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0RFQlVHLCBcInRydWVcIik7XG4gICAgfVxuICAgIGVuYWJsZVByb2ZpbGluZygpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfUFJPRklMRSwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBkaXNhYmxlRGVidWcoKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX0RFQlVHKTtcbiAgICB9XG4gICAgZGlzYWJsZVByb2ZpbGluZygpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfUFJPRklMRSk7XG4gICAgfVxuICAgIGVuYWJsZUxhdGVuY3lTaW0odXBwZXJCb3VuZE1zKSB7XG4gICAgICB0aGlzLmVuYWJsZURlYnVnKCk7XG4gICAgICBjb25zb2xlLmxvZyhcImxhdGVuY3kgc2ltdWxhdG9yIGVuYWJsZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGlzIGJyb3dzZXIgc2Vzc2lvbi4gQ2FsbCBkaXNhYmxlTGF0ZW5jeVNpbSgpIHRvIGRpc2FibGVcIik7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNLCB1cHBlckJvdW5kTXMpO1xuICAgIH1cbiAgICBkaXNhYmxlTGF0ZW5jeVNpbSgpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pO1xuICAgIH1cbiAgICBnZXRMYXRlbmN5U2ltKCkge1xuICAgICAgbGV0IHN0ciA9IHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0pO1xuICAgICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiBudWxsO1xuICAgIH1cbiAgICBnZXRTb2NrZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb2NrZXQ7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICBsZXQgZG9Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5qb2luUm9vdFZpZXdzKCkpIHtcbiAgICAgICAgICB0aGlzLmJpbmRUb3BMZXZlbEV2ZW50cygpO1xuICAgICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChbXCJjb21wbGV0ZVwiLCBcImxvYWRlZFwiLCBcImludGVyYWN0aXZlXCJdLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPj0gMCkge1xuICAgICAgICBkb0Nvbm5lY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IGRvQ29ubmVjdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdChjYWxsYmFjaykge1xuICAgICAgdGhpcy5zb2NrZXQuZGlzY29ubmVjdChjYWxsYmFjayk7XG4gICAgfVxuICAgIHRyaWdnZXJET00oa2luZCwgYXJncykge1xuICAgICAgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncyk7XG4gICAgfVxuICAgIHRpbWUobmFtZSwgZnVuYykge1xuICAgICAgaWYgKCF0aGlzLmlzUHJvZmlsZUVuYWJsZWQoKSB8fCAhY29uc29sZS50aW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLnRpbWUobmFtZSk7XG4gICAgICBsZXQgcmVzdWx0ID0gZnVuYygpO1xuICAgICAgY29uc29sZS50aW1lRW5kKG5hbWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy52aWV3TG9nZ2VyKSB7XG4gICAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy52aWV3TG9nZ2VyKHZpZXcsIGtpbmQsIG1zZywgb2JqKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKTtcbiAgICAgICAgZGVidWcodmlldywga2luZCwgbXNnLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkNoYW5uZWwoY2hhbm5lbCwgZXZlbnQsIGNiKSB7XG4gICAgICBjaGFubmVsLm9uKGV2ZW50LCAoZGF0YSkgPT4ge1xuICAgICAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpO1xuICAgICAgICBpZiAoIWxhdGVuY3kpIHtcbiAgICAgICAgICBjYihkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIHNlcnZlciB0byBjbGllbnRgKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNiKGRhdGEpLCBsYXRlbmN5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHdyYXBQdXNoKHZpZXcsIG9wdHMsIHB1c2gpIHtcbiAgICAgIGxldCBsYXRlbmN5ID0gdGhpcy5nZXRMYXRlbmN5U2ltKCk7XG4gICAgICBsZXQgb2xkSm9pbkNvdW50ID0gdmlldy5qb2luQ291bnQ7XG4gICAgICBpZiAoIWxhdGVuY3kpIHtcbiAgICAgICAgaWYgKG9wdHMudGltZW91dCkge1xuICAgICAgICAgIHJldHVybiBwdXNoKCkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuam9pbkNvdW50ID09PSBvbGRKb2luQ291bnQgJiYgIXZpZXcuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKHZpZXcsIFwidGltZW91dFwiLCAoKSA9PiBbXCJyZWNlaXZlZCB0aW1lb3V0IHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCBzZXJ2ZXIuIEZhbGxpbmcgYmFjayB0byBoYXJkIHJlZnJlc2ggZm9yIHJlY292ZXJ5XCJdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHB1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYHNpbXVsYXRpbmcgJHtsYXRlbmN5fW1zIG9mIGxhdGVuY3kgZnJvbSBjbGllbnQgdG8gc2VydmVyYCk7XG4gICAgICBsZXQgZmFrZVB1c2ggPSB7XG4gICAgICAgIHJlY2VpdmVzOiBbXSxcbiAgICAgICAgcmVjZWl2ZShraW5kLCBjYikge1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXMucHVzaChba2luZCwgY2JdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZha2VQdXNoLnJlY2VpdmVzLnJlZHVjZSgoYWNjLCBba2luZCwgY2JdKSA9PiBhY2MucmVjZWl2ZShraW5kLCBjYiksIHB1c2goKSk7XG4gICAgICB9LCBsYXRlbmN5KTtcbiAgICAgIHJldHVybiBmYWtlUHVzaDtcbiAgICB9XG4gICAgcmVsb2FkV2l0aEppdHRlcih2aWV3LCBsb2cpIHtcbiAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBsZXQgW21pbk1zLCBtYXhNc10gPSBSRUxPQURfSklUVEVSO1xuICAgICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zO1xuICAgICAgbGV0IHRyaWVzID0gYnJvd3Nlcl9kZWZhdWx0LnVwZGF0ZUxvY2FsKHRoaXMubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMsIDAsIChjb3VudCkgPT4gY291bnQgKyAxKTtcbiAgICAgIGxvZyA/IGxvZygpIDogdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZW5jb3VudGVyZWQgJHt0cmllc30gY29uc2VjdXRpdmUgcmVsb2Fkc2BdKTtcbiAgICAgIGlmICh0cmllcyA+IE1BWF9SRUxPQURTKSB7XG4gICAgICAgIHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGV4Y2VlZGVkICR7TUFYX1JFTE9BRFN9IGNvbnNlY3V0aXZlIHJlbG9hZHMuIEVudGVyaW5nIGZhaWxzYWZlIG1vZGVgXSk7XG4gICAgICAgIGFmdGVyTXMgPSBGQUlMU0FGRV9KSVRURVI7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucGVuZGluZ0xpbms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LCBhZnRlck1zKTtcbiAgICB9XG4gICAgZ2V0SG9va0NhbGxiYWNrcyhuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAmJiBuYW1lLnN0YXJ0c1dpdGgoXCJQaG9lbml4LlwiKSA/IGhvb2tzX2RlZmF1bHRbbmFtZS5zcGxpdChcIi5cIilbMV1dIDogdGhpcy5ob29rc1tuYW1lXTtcbiAgICB9XG4gICAgaXNVbmxvYWRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVubG9hZGVkO1xuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpO1xuICAgIH1cbiAgICBnZXRCaW5kaW5nUHJlZml4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeDtcbiAgICB9XG4gICAgYmluZGluZyhraW5kKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5nZXRCaW5kaW5nUHJlZml4KCl9JHtraW5kfWA7XG4gICAgfVxuICAgIGNoYW5uZWwodG9waWMsIHBhcmFtcykge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmNoYW5uZWwodG9waWMsIHBhcmFtcyk7XG4gICAgfVxuICAgIGpvaW5Sb290Vmlld3MoKSB7XG4gICAgICBsZXQgcm9vdHNGb3VuZCA9IGZhbHNlO1xuICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCAocm9vdEVsKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5nZXRSb290QnlJZChyb290RWwuaWQpKSB7XG4gICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KHJvb3RFbCk7XG4gICAgICAgICAgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKTtcbiAgICAgICAgICB2aWV3LmpvaW4oKTtcbiAgICAgICAgICBpZiAocm9vdEVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbiA9IHZpZXc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJvb3RzRm91bmQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcm9vdHNGb3VuZDtcbiAgICB9XG4gICAgcmVkaXJlY3QodG8sIGZsYXNoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5yZWRpcmVjdCh0bywgZmxhc2gpO1xuICAgIH1cbiAgICByZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgY2FsbGJhY2sgPSBudWxsLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSkge1xuICAgICAgbGV0IG9sZE1haW5FbCA9IHRoaXMubWFpbi5lbDtcbiAgICAgIGxldCBuZXdNYWluRWwgPSBkb21fZGVmYXVsdC5jbG9uZU5vZGUob2xkTWFpbkVsLCBcIlwiKTtcbiAgICAgIHRoaXMubWFpbi5zaG93TG9hZGVyKHRoaXMubG9hZGVyVGltZW91dCk7XG4gICAgICB0aGlzLm1haW4uZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYWluID0gdGhpcy5uZXdSb290VmlldyhuZXdNYWluRWwsIGZsYXNoKTtcbiAgICAgIHRoaXMubWFpbi5zZXRSZWRpcmVjdChocmVmKTtcbiAgICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQpID0+IHtcbiAgICAgICAgaWYgKGpvaW5Db3VudCA9PT0gMSAmJiB0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKSB7XG4gICAgICAgICAgb2xkTWFpbkVsLnJlcGxhY2VXaXRoKG5ld01haW5FbCk7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzUGh4VmlldyhlbCkge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsO1xuICAgIH1cbiAgICBuZXdSb290VmlldyhlbCwgZmxhc2gpIHtcbiAgICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMsIG51bGwsIGZsYXNoKTtcbiAgICAgIHRoaXMucm9vdHNbdmlldy5pZF0gPSB2aWV3O1xuICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxuICAgIG93bmVyKGNoaWxkRWwsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgdmlldyA9IG1heWJlKGNoaWxkRWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIChlbCkgPT4gdGhpcy5nZXRWaWV3QnlFbChlbCkpO1xuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgY2FsbGJhY2sodmlldyk7XG4gICAgICB9XG4gICAgfVxuICAgIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5vd25lcihjaGlsZEVsLCAodmlldykgPT4ge1xuICAgICAgICBsZXQgcGh4VGFyZ2V0ID0gY2hpbGRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKTtcbiAgICAgICAgaWYgKHBoeFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGdldFZpZXdCeUVsKGVsKSB7XG4gICAgICBsZXQgcm9vdElkID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKTtcbiAgICAgIHJldHVybiBtYXliZSh0aGlzLmdldFJvb3RCeUlkKHJvb3RJZCksIChyb290KSA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSk7XG4gICAgfVxuICAgIGdldFJvb3RCeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290c1tpZF07XG4gICAgfVxuICAgIGRlc3Ryb3lBbGxWaWV3cygpIHtcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucm9vdHMpIHtcbiAgICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5yb290c1tpZF07XG4gICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lWaWV3QnlFbChlbCkge1xuICAgICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3RCeUlkKGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCkpO1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEFjdGl2ZUVsZW1lbnQodGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICAgICAgbGV0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcyk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcyk7XG4gICAgICB9O1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGNhbmNlbCk7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGNhbmNlbCk7XG4gICAgfVxuICAgIGdldEFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgfVxuICAgIH1cbiAgICBkcm9wQWN0aXZlRWxlbWVudCh2aWV3KSB7XG4gICAgICBpZiAodGhpcy5wcmV2QWN0aXZlICYmIHZpZXcub3duc0VsZW1lbnQodGhpcy5wcmV2QWN0aXZlKSkge1xuICAgICAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCkge1xuICAgICAgaWYgKHRoaXMucHJldkFjdGl2ZSAmJiB0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhpcy5wcmV2QWN0aXZlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGJsdXJBY3RpdmVFbGVtZW50KCkge1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRoaXMucHJldkFjdGl2ZS5ibHVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGJpbmRUb3BMZXZlbEV2ZW50cygpIHtcbiAgICAgIGlmICh0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnBlcnNpc3RlZCkge1xuICAgICAgICAgIHRoaXMuZ2V0U29ja2V0KCkuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHsgdG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCIgfSk7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHRoaXMuYmluZE5hdigpO1xuICAgICAgdGhpcy5iaW5kQ2xpY2tzKCk7XG4gICAgICB0aGlzLmJpbmRGb3JtcygpO1xuICAgICAgdGhpcy5iaW5kKHsga2V5dXA6IFwia2V5dXBcIiwga2V5ZG93bjogXCJrZXlkb3duXCIgfSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgX3BoeFRhcmdldCkgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hLZXkgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfS0VZKSk7XG4gICAgICAgIGxldCBwcmVzc2VkS2V5ID0gZS5rZXkgJiYgZS5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5wdXNoS2V5KHRhcmdldCwgdGFyZ2V0Q3R4LCB0eXBlLCBwaHhFdmVudCwgX19zcHJlYWRWYWx1ZXMoeyBrZXk6IGUua2V5IH0sIHRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldCkpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iaW5kKHsgYmx1cjogXCJmb2N1c291dFwiLCBmb2N1czogXCJmb2N1c2luXCIgfSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgICAgaWYgKCFwaHhUYXJnZXQpIHtcbiAgICAgICAgICB2aWV3LnB1c2hFdmVudCh0eXBlLCB0YXJnZXRFbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJpbmQoeyBibHVyOiBcImJsdXJcIiwgZm9jdXM6IFwiZm9jdXNcIiB9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIHBoeFRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGh4VGFyZ2V0ICYmICFwaHhUYXJnZXQgIT09IFwid2luZG93XCIpIHtcbiAgICAgICAgICB2aWV3LnB1c2hFdmVudCh0eXBlLCB0YXJnZXRFbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGRyb3BUYXJnZXRJZCA9IG1heWJlKGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSksICh0cnVlVGFyZ2V0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRydWVUYXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkcm9wVGFyZ2V0ID0gZHJvcFRhcmdldElkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyb3BUYXJnZXRJZCk7XG4gICAgICAgIGxldCBmaWxlcyA9IEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuZmlsZXMgfHwgW10pO1xuICAgICAgICBpZiAoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGRyb3BUYXJnZXQsIGZpbGVzKTtcbiAgICAgICAgZHJvcFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIChlKSA9PiB7XG4gICAgICAgIGxldCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKCFkb21fZGVmYXVsdC5pc1VwbG9hZElucHV0KHVwbG9hZFRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRldGFpbC5maWxlcyB8fCBbXSkuZmlsdGVyKChmKSA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYik7XG4gICAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpO1xuICAgICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGV2ZW50TWV0YShldmVudE5hbWUsIGUsIHRhcmdldEVsKSB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzW2V2ZW50TmFtZV07XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhlLCB0YXJnZXRFbCkgOiB7fTtcbiAgICB9XG4gICAgc2V0UGVuZGluZ0xpbmsoaHJlZikge1xuICAgICAgdGhpcy5saW5rUmVmKys7XG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gaHJlZjtcbiAgICAgIHJldHVybiB0aGlzLmxpbmtSZWY7XG4gICAgfVxuICAgIGNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpIHtcbiAgICAgIGlmICh0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5wZW5kaW5nTGluaztcbiAgICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRIcmVmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgICB9XG4gICAgaGFzUGVuZGluZ0xpbmsoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnBlbmRpbmdMaW5rO1xuICAgIH1cbiAgICBiaW5kKGV2ZW50cywgY2FsbGJhY2spIHtcbiAgICAgIGZvciAobGV0IGV2ZW50IGluIGV2ZW50cykge1xuICAgICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF07XG4gICAgICAgIHRoaXMub24oYnJvd3NlckV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgICBsZXQgYmluZGluZyA9IHRoaXMuYmluZGluZyhldmVudCk7XG4gICAgICAgICAgbGV0IHdpbmRvd0JpbmRpbmcgPSB0aGlzLmJpbmRpbmcoYHdpbmRvdy0ke2V2ZW50fWApO1xuICAgICAgICAgIGxldCB0YXJnZXRQaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoYmluZGluZyk7XG4gICAgICAgICAgaWYgKHRhcmdldFBoeEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGUudGFyZ2V0LCB0YXJnZXRDdHgsIHRhcmdldFBoeEV2ZW50LCBudWxsKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgWyR7d2luZG93QmluZGluZ31dYCwgKGVsKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZSh3aW5kb3dCaW5kaW5nKTtcbiAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZShlbCwgZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIFwid2luZG93XCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJpbmRDbGlja3MoKSB7XG4gICAgICB0aGlzLmJpbmRDbGljayhcImNsaWNrXCIsIFwiY2xpY2tcIiwgZmFsc2UpO1xuICAgICAgdGhpcy5iaW5kQ2xpY2soXCJtb3VzZWRvd25cIiwgXCJjYXB0dXJlLWNsaWNrXCIsIHRydWUpO1xuICAgIH1cbiAgICBiaW5kQ2xpY2soZXZlbnROYW1lLCBiaW5kaW5nTmFtZSwgY2FwdHVyZSkge1xuICAgICAgbGV0IGNsaWNrID0gdGhpcy5iaW5kaW5nKGJpbmRpbmdOYW1lKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldCA9IG51bGw7XG4gICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZS50YXJnZXQubWF0Y2hlcyhgWyR7Y2xpY2t9XWApID8gZS50YXJnZXQgOiBlLnRhcmdldC5xdWVyeVNlbGVjdG9yKGBbJHtjbGlja31dYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIGNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGh4RXZlbnQgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShjbGljayk7XG4gICAgICAgIGlmICghcGh4RXZlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYm91bmNlKHRhcmdldCwgZSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKHRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgICAgICAgdmlldy5wdXNoRXZlbnQoXCJjbGlja1wiLCB0YXJnZXQsIHRhcmdldEN0eCwgcGh4RXZlbnQsIHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgdGFyZ2V0KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgY2FwdHVyZSk7XG4gICAgfVxuICAgIGJpbmROYXYoKSB7XG4gICAgICBpZiAoIWJyb3dzZXJfZGVmYXVsdC5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICAgIH1cbiAgICAgIGxldCBzY3JvbGxUaW1lciA9IG51bGw7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoX2UpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKTtcbiAgICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBicm93c2VyX2RlZmF1bHQudXBkYXRlQ3VycmVudFN0YXRlKChzdGF0ZSkgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwgeyBzY3JvbGw6IHdpbmRvdy5zY3JvbGxZIH0pKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyB0eXBlLCBpZCwgcm9vdCwgc2Nyb2xsIH0gPSBldmVudC5zdGF0ZSB8fCB7fTtcbiAgICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5pc0Nvbm5lY3RlZCgpICYmICh0eXBlID09PSBcInBhdGNoXCIgJiYgaWQgPT09IHRoaXMubWFpbi5pZCkpIHtcbiAgICAgICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZVJvb3RIaXN0b3J5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKTtcbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgbGV0IHRhcmdldCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCBQSFhfTElWRV9MSU5LKTtcbiAgICAgICAgbGV0IHR5cGUgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElWRV9MSU5LKTtcbiAgICAgICAgbGV0IHdhbnRzTmV3VGFiID0gZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLmJ1dHRvbiA9PT0gMTtcbiAgICAgICAgaWYgKCF0eXBlIHx8ICF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbiB8fCB3YW50c05ld1RhYikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaHJlZiA9IHRhcmdldC5ocmVmO1xuICAgICAgICBsZXQgbGlua1N0YXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElOS19TVEFURSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xpbmsgPT09IGhyZWYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwicGF0Y2hcIikge1xuICAgICAgICAgIHRoaXMucHVzaEhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyZWRpcmVjdFwiKSB7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgd2l0aFBhZ2VMb2FkaW5nKGluZm8sIGNhbGxiYWNrKSB7XG4gICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8pO1xuICAgICAgbGV0IGRvbmUgPSAoKSA9PiBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgaW5mbyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhkb25lKSA6IGRvbmU7XG4gICAgfVxuICAgIHB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCkge1xuICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoeyB0bzogaHJlZiwga2luZDogXCJwYXRjaFwiIH0sIChkb25lKSA9PiB7XG4gICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIHRhcmdldEVsLCAobGlua1JlZikgPT4ge1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZik7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5wdXNoU3RhdGUobGlua1N0YXRlLCB7IHR5cGU6IFwicGF0Y2hcIiwgaWQ6IHRoaXMubWFpbi5pZCB9LCBocmVmKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pO1xuICAgIH1cbiAgICBoaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlLCBmbGFzaCkge1xuICAgICAgbGV0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoeyB0bzogaHJlZiwga2luZDogXCJyZWRpcmVjdFwiIH0sIChkb25lKSA9PiB7XG4gICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsICgpID0+IHtcbiAgICAgICAgICBicm93c2VyX2RlZmF1bHQucHVzaFN0YXRlKGxpbmtTdGF0ZSwgeyB0eXBlOiBcInJlZGlyZWN0XCIsIGlkOiB0aGlzLm1haW4uaWQsIHNjcm9sbCB9LCBocmVmKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcGxhY2VSb290SGlzdG9yeSgpIHtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5wdXNoU3RhdGUoXCJyZXBsYWNlXCIsIHsgcm9vdDogdHJ1ZSwgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkIH0pO1xuICAgIH1cbiAgICByZWdpc3Rlck5ld0xvY2F0aW9uKG5ld0xvY2F0aW9uKSB7XG4gICAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoIH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvbjtcbiAgICAgIGlmIChwYXRobmFtZSArIHNlYXJjaCA9PT0gbmV3TG9jYXRpb24ucGF0aG5hbWUgKyBuZXdMb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBiaW5kRm9ybXMoKSB7XG4gICAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB0aGlzLm9uKFwic3VibWl0XCIsIChlKSA9PiB7XG4gICAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpO1xuICAgICAgICBpZiAoIXBoeEV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS50YXJnZXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4gdmlldy5zdWJtaXRGb3JtKGUudGFyZ2V0LCB0YXJnZXRDdHgsIHBoeEV2ZW50KSk7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgICBmb3IgKGxldCB0eXBlIG9mIFtcImNoYW5nZVwiLCBcImlucHV0XCJdKSB7XG4gICAgICAgIHRoaXMub24odHlwZSwgKGUpID0+IHtcbiAgICAgICAgICBsZXQgaW5wdXQgPSBlLnRhcmdldDtcbiAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBpbnB1dC5mb3JtICYmIGlucHV0LmZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSk7XG4gICAgICAgICAgaWYgKCFwaHhFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbnB1dC52YWxpZGl0eSAmJiBpbnB1dC52YWxpZGl0eS5iYWRJbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICBsZXQgeyBhdCwgdHlwZTogbGFzdFR5cGUgfSA9IGRvbV9kZWZhdWx0LnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge307XG4gICAgICAgICAgaWYgKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSAhPT0gbGFzdFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiLCB7IGF0OiBjdXJyZW50SXRlcmF0aW9ucywgdHlwZSB9KTtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGlucHV0LCBlLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhpbnB1dC5mb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmICghZG9tX2RlZmF1bHQuaXNUZXh0dWFsSW5wdXQoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVFbGVtZW50KGlucHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2aWV3LnB1c2hJbnB1dChpbnB1dCwgdGFyZ2V0Q3R4LCBudWxsLCBwaHhFdmVudCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVib3VuY2UoZWwsIGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgbGV0IHBoeERlYm91bmNlID0gdGhpcy5iaW5kaW5nKFBIWF9ERUJPVU5DRSk7XG4gICAgICBsZXQgcGh4VGhyb3R0bGUgPSB0aGlzLmJpbmRpbmcoUEhYX1RIUk9UVExFKTtcbiAgICAgIGxldCBkZWZhdWx0RGVib3VuY2UgPSB0aGlzLmRlZmF1bHRzLmRlYm91bmNlLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgZGVmYXVsdFRocm90dGxlID0gdGhpcy5kZWZhdWx0cy50aHJvdHRsZS50b1N0cmluZygpO1xuICAgICAgZG9tX2RlZmF1bHQuZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHNpbGVuY2VFdmVudHMoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuc2lsZW5jZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKGUpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnNpbGVuY2VkKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHBob2VuaXhfbGl2ZV92aWV3X2V4cG9ydHM7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdDQTtBQUNBO0FBK0NBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQWxFQTtBQW1FQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE3Q0E7QUE4Q0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwVkE7QUFxVkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBOUZBO0FBQ0E7QUFnR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwR0E7QUFDQTtBQXNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBdkJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQXpCQTtBQXVDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5Q0E7QUFDQTtBQWdEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXhFQTtBQTBFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0ZBO0FBNkZBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsT0E7QUFDQTtBQW9PQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBek1BO0FBQ0E7QUEyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUF2RUE7QUFDQTtBQXlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBeDRCQTtBQUNBO0FBMDRCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUFBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNWxCQTtBQTZsQkE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../deps/phoenix_live_view/priv/static/phoenix_live_view.js\n");

/***/ }),

/***/ "./css/app.scss":
/*!**********************!*\
  !*** ./css/app.scss ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jc3MvYXBwLnNjc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvYXBwLnNjc3M/OGQ2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/app.scss\n");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.scss */ \"./css/app.scss\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(phoenix__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nprogress */ \"./node_modules/nprogress/nprogress.js\");\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(nprogress__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! phoenix_live_view */ \"../deps/phoenix_live_view/priv/static/phoenix_live_view.js\");\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash.throttle */ \"./node_modules/lodash.throttle/index.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _jscolor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./jscolor.js */ \"./js/jscolor.js\");\n/* harmony import */ var _jscolor_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jscolor_js__WEBPACK_IMPORTED_MODULE_6__);\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import deps with the dep name or local files with a relative path, for example:\n//\n//     import {Socket} from \"phoenix\"\n//     import socket from \"./socket\"\n//\n\n\n\n\n\n\n\nvar throttleMs = 100;\nvar Hooks = {};\nHooks.ColorSelector = {\n  mounted: function mounted() {\n    var _this = this;\n\n    this.el.addEventListener(\"build\", lodash_throttle__WEBPACK_IMPORTED_MODULE_5___default()(function (e) {\n      var ev = e.detail;\n      var hex = ev.toHEXString();\n\n      _this.pushEvent(\"color\", {\n        hex: hex\n      });\n    }, throttleMs));\n  }\n};\nHooks.BrightnessSlider = {\n  mounted: function mounted() {\n    var _this2 = this;\n\n    this.el.addEventListener(\"input\", lodash_throttle__WEBPACK_IMPORTED_MODULE_5___default()(function (e) {\n      var value = parseInt(e.target.value);\n\n      _this2.pushEvent(\"brightness\", {\n        value: value\n      });\n    }, throttleMs));\n  }\n};\nHooks.WhiteSlider = {\n  mounted: function mounted() {\n    var _this3 = this;\n\n    this.el.addEventListener(\"input\", lodash_throttle__WEBPACK_IMPORTED_MODULE_5___default()(function (e) {\n      var value = parseInt(e.target.value);\n\n      _this3.pushEvent(\"white-slider\", {\n        value: value\n      });\n    }, throttleMs));\n  }\n};\n\nwindow.update = function (colorEvent) {\n  var event = new CustomEvent('build', {\n    detail: colorEvent\n  });\n  colorEvent.previewElement.dispatchEvent(event);\n};\n\nvar csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\");\nvar liveSocket = new phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__[\"LiveSocket\"](\"/live\", phoenix__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"], {\n  hooks: Hooks,\n  params: {\n    _csrf_token: csrfToken\n  }\n}); // Show progress bar on live navigation and form submits\n\nwindow.addEventListener(\"phx:page-loading-start\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_3___default.a.start();\n});\nwindow.addEventListener(\"phx:page-loading-stop\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_3___default.a.done();\n}); // connect if there are any LiveViews on the page\n\nliveSocket.connect(); // expose liveSocket on window for web console debug logs and latency simulation:\n// >> liveSocket.enableDebug()\n// >> liveSocket.enableLatencySim(1000)  // enabled for duration of browser session\n// >> liveSocket.disableLatencySim()\n\nwindow.liveSocket = liveSocket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9hcHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hcHAuanM/NzQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSBuZWVkIHRvIGltcG9ydCB0aGUgQ1NTIHNvIHRoYXQgd2VicGFjayB3aWxsIGxvYWQgaXQuXG4vLyBUaGUgTWluaUNzc0V4dHJhY3RQbHVnaW4gaXMgdXNlZCB0byBzZXBhcmF0ZSBpdCBvdXQgaW50b1xuLy8gaXRzIG93biBDU1MgZmlsZS5cbmltcG9ydCBcIi4uL2Nzcy9hcHAuc2Nzc1wiXG5cbi8vIHdlYnBhY2sgYXV0b21hdGljYWxseSBidW5kbGVzIGFsbCBtb2R1bGVzIGluIHlvdXJcbi8vIGVudHJ5IHBvaW50cy4gVGhvc2UgZW50cnkgcG9pbnRzIGNhbiBiZSBjb25maWd1cmVkXG4vLyBpbiBcIndlYnBhY2suY29uZmlnLmpzXCIuXG4vL1xuLy8gSW1wb3J0IGRlcHMgd2l0aCB0aGUgZGVwIG5hbWUgb3IgbG9jYWwgZmlsZXMgd2l0aCBhIHJlbGF0aXZlIHBhdGgsIGZvciBleGFtcGxlOlxuLy9cbi8vICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuLy8gICAgIGltcG9ydCBzb2NrZXQgZnJvbSBcIi4vc29ja2V0XCJcbi8vXG5pbXBvcnQgXCJwaG9lbml4X2h0bWxcIlxuaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbmltcG9ydCBOUHJvZ3Jlc3MgZnJvbSBcIm5wcm9ncmVzc1wiXG5pbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoLnRocm90dGxlJ1xuaW1wb3J0IFwiLi9qc2NvbG9yLmpzXCJcblxubGV0IHRocm90dGxlTXMgPSAxMDA7XG5sZXQgSG9va3MgPSB7fVxuXG5Ib29rcy5Db2xvclNlbGVjdG9yID0ge1xuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJ1aWxkXCIsIHRocm90dGxlKGUgPT4ge1xuICAgICAgY29uc3QgZXYgPSBlLmRldGFpbFxuICAgICAgY29uc3QgaGV4ID0gZXYudG9IRVhTdHJpbmcoKVxuICAgICAgdGhpcy5wdXNoRXZlbnQoXCJjb2xvclwiLCB7aGV4OiBoZXh9KVxuICAgIH0sIHRocm90dGxlTXMpKVxuICB9XG59XG5cbkhvb2tzLkJyaWdodG5lc3NTbGlkZXIgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhyb3R0bGUoZSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlKVxuICAgICAgdGhpcy5wdXNoRXZlbnQoXCJicmlnaHRuZXNzXCIsIHt2YWx1ZTogdmFsdWV9KVxuICAgIH0sIHRocm90dGxlTXMpKVxuICB9XG59XG5cbkhvb2tzLldoaXRlU2xpZGVyID0ge1xuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRocm90dGxlKGUgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChlLnRhcmdldC52YWx1ZSlcbiAgICAgIHRoaXMucHVzaEV2ZW50KFwid2hpdGUtc2xpZGVyXCIsIHt2YWx1ZTogdmFsdWV9KVxuICAgIH0sIHRocm90dGxlTXMpKVxuICB9XG59XG5cbndpbmRvdy51cGRhdGUgPSBmdW5jdGlvbihjb2xvckV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdidWlsZCcsIHtkZXRhaWw6IGNvbG9yRXZlbnR9KTtcbiAgY29sb3JFdmVudC5wcmV2aWV3RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxubGV0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpXG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7aG9va3M6IEhvb2tzLCBwYXJhbXM6IHtfY3NyZl90b2tlbjogY3NyZlRva2VufX0pXG5cbi8vIFNob3cgcHJvZ3Jlc3MgYmFyIG9uIGxpdmUgbmF2aWdhdGlvbiBhbmQgZm9ybSBzdWJtaXRzXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwgaW5mbyA9PiBOUHJvZ3Jlc3Muc3RhcnQoKSlcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIGluZm8gPT4gTlByb2dyZXNzLmRvbmUoKSlcblxuLy8gY29ubmVjdCBpZiB0aGVyZSBhcmUgYW55IExpdmVWaWV3cyBvbiB0aGUgcGFnZVxubGl2ZVNvY2tldC5jb25uZWN0KClcblxuLy8gZXhwb3NlIGxpdmVTb2NrZXQgb24gd2luZG93IGZvciB3ZWIgY29uc29sZSBkZWJ1ZyBsb2dzIGFuZCBsYXRlbmN5IHNpbXVsYXRpb246XG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZURlYnVnKClcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlTGF0ZW5jeVNpbSgxMDAwKSAgLy8gZW5hYmxlZCBmb3IgZHVyYXRpb24gb2YgYnJvd3NlciBzZXNzaW9uXG4vLyA+PiBsaXZlU29ja2V0LmRpc2FibGVMYXRlbmN5U2ltKClcbndpbmRvdy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBUEE7QUFVQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/app.js\n");

/***/ }),

/***/ "./js/jscolor.js":
/*!***********************!*\
  !*** ./js/jscolor.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * jscolor - JavaScript Color Picker\r\n *\r\n * @link    http://jscolor.com\r\n * @license For open source use: GPLv3\r\n *          For commercial use: JSColor Commercial License\r\n * @author  Jan Odvarko - East Desire\r\n * @version 2.3.3\r\n *\r\n * See usage examples at http://jscolor.com/examples/\r\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nif (!window.jscolor) {\n  window.jscolor = function () {\n    // BEGIN window.jscolor\n    var jsc = {\n      initialized: false,\n      instances: [],\n      // created instances of jscolor\n      triggerQueue: [],\n      // events waiting to be triggered after init\n      register: function register() {\n        document.addEventListener('DOMContentLoaded', jsc.init, false);\n        document.addEventListener('mousedown', jsc.onDocumentMouseDown, false);\n        document.addEventListener('keyup', jsc.onDocumentKeyUp, false);\n        window.addEventListener('resize', jsc.onWindowResize, false);\n      },\n      init: function init() {\n        if (jsc.initialized) {\n          return;\n        }\n\n        jsc.pub.install();\n        jsc.initialized = true; // trigger events waiting in the queue\n\n        while (jsc.triggerQueue.length) {\n          var ev = jsc.triggerQueue.shift();\n          jsc.triggerGlobal(ev);\n        }\n      },\n      installBySelector: function installBySelector(selector, rootNode) {\n        rootNode = rootNode ? jsc.node(rootNode) : document;\n\n        if (!rootNode) {\n          throw new Error('Missing root node');\n        }\n\n        var elms = rootNode.querySelectorAll(selector); // for backward compatibility with DEPRECATED installation/configuration using className\n\n        var matchClass = new RegExp('(^|\\\\s)(' + jsc.pub.lookupClass + ')(\\\\s*(\\\\{[^}]*\\\\})|\\\\s|$)', 'i');\n\n        for (var i = 0; i < elms.length; i += 1) {\n          if (elms[i].jscolor && elms[i].jscolor instanceof jsc.pub) {\n            continue; // jscolor already installed on this element\n          }\n\n          if (elms[i].type !== undefined && elms[i].type.toLowerCase() == 'color' && jsc.isColorAttrSupported) {\n            continue; // skips inputs of type 'color' if supported by the browser\n          }\n\n          var dataOpts, m;\n\n          if ((dataOpts = jsc.getDataAttr(elms[i], 'jscolor')) !== null || elms[i].className && (m = elms[i].className.match(matchClass)) // installation using className (DEPRECATED)\n          ) {\n              var targetElm = elms[i];\n              var optsStr = '';\n\n              if (dataOpts !== null) {\n                optsStr = dataOpts;\n              } else if (m) {\n                // installation using className (DEPRECATED)\n                console.warn('Installation using class name is DEPRECATED. Use data-jscolor=\"\" attribute instead.' + jsc.docsRef);\n\n                if (m[4]) {\n                  optsStr = m[4];\n                }\n              }\n\n              var opts = null;\n\n              if (optsStr.trim()) {\n                try {\n                  opts = jsc.parseOptionsStr(optsStr);\n                } catch (e) {\n                  console.warn(e + '\\n' + optsStr);\n                }\n              }\n\n              try {\n                new jsc.pub(targetElm, opts);\n              } catch (e) {\n                console.warn(e);\n              }\n            }\n        }\n      },\n      parseOptionsStr: function parseOptionsStr(str) {\n        var opts = null;\n\n        try {\n          opts = JSON.parse(str);\n        } catch (eParse) {\n          if (!jsc.pub.looseJSON) {\n            throw new Error('Could not parse jscolor options as JSON: ' + eParse);\n          } else {\n            // loose JSON syntax is enabled -> try to evaluate the options string as JavaScript object\n            try {\n              opts = new Function('var opts = (' + str + '); return typeof opts === \"object\" ? opts : {};')();\n            } catch (eEval) {\n              throw new Error('Could not evaluate jscolor options: ' + eEval);\n            }\n          }\n        }\n\n        return opts;\n      },\n      getInstances: function getInstances() {\n        var inst = [];\n\n        for (var i = 0; i < jsc.instances.length; i += 1) {\n          // if the targetElement still exists, the instance is considered \"alive\"\n          if (jsc.instances[i] && jsc.instances[i].targetElement) {\n            inst.push(jsc.instances[i]);\n          }\n        }\n\n        return inst;\n      },\n      createEl: function createEl(tagName) {\n        var el = document.createElement(tagName);\n        jsc.setData(el, 'gui', true);\n        return el;\n      },\n      node: function node(nodeOrSelector) {\n        if (!nodeOrSelector) {\n          return null;\n        }\n\n        if (typeof nodeOrSelector === 'string') {\n          // query selector\n          var sel = nodeOrSelector;\n          var el = null;\n\n          try {\n            el = document.querySelector(sel);\n          } catch (e) {\n            console.warn(e);\n            return null;\n          }\n\n          if (!el) {\n            console.warn('No element matches the selector: %s', sel);\n          }\n\n          return el;\n        }\n\n        if (jsc.isNode(nodeOrSelector)) {\n          // DOM node\n          return nodeOrSelector;\n        }\n\n        console.warn('Invalid node of type %s: %s', _typeof(nodeOrSelector), nodeOrSelector);\n        return null;\n      },\n      // See https://stackoverflow.com/questions/384286/\n      isNode: function isNode(val) {\n        if ((typeof Node === \"undefined\" ? \"undefined\" : _typeof(Node)) === 'object') {\n          return val instanceof Node;\n        }\n\n        return val && _typeof(val) === 'object' && typeof val.nodeType === 'number' && typeof val.nodeName === 'string';\n      },\n      nodeName: function nodeName(node) {\n        if (node && node.nodeName) {\n          return node.nodeName.toLowerCase();\n        }\n\n        return false;\n      },\n      removeChildren: function removeChildren(node) {\n        while (node.firstChild) {\n          node.removeChild(node.firstChild);\n        }\n      },\n      isTextInput: function isTextInput(el) {\n        return el && jsc.nodeName(el) === 'input' && el.type.toLowerCase() === 'text';\n      },\n      isButton: function isButton(el) {\n        if (!el) {\n          return false;\n        }\n\n        var n = jsc.nodeName(el);\n        return n === 'button' || n === 'input' && ['button', 'submit', 'reset'].indexOf(el.type.toLowerCase()) > -1;\n      },\n      isButtonEmpty: function isButtonEmpty(el) {\n        switch (jsc.nodeName(el)) {\n          case 'input':\n            return !el.value || el.value.trim() === '';\n\n          case 'button':\n            return el.textContent.trim() === '';\n        }\n\n        return null; // could not determine element's text\n      },\n      // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n      isPassiveEventSupported: function () {\n        var supported = false;\n\n        try {\n          var opts = Object.defineProperty({}, 'passive', {\n            get: function get() {\n              supported = true;\n            }\n          });\n          window.addEventListener('testPassive', null, opts);\n          window.removeEventListener('testPassive', null, opts);\n        } catch (e) {}\n\n        return supported;\n      }(),\n      isColorAttrSupported: function () {\n        var elm = document.createElement('input');\n\n        if (elm.setAttribute) {\n          elm.setAttribute('type', 'color');\n\n          if (elm.type.toLowerCase() == 'color') {\n            return true;\n          }\n        }\n\n        return false;\n      }(),\n      dataProp: '_data_jscolor',\n      // usage:\n      //   setData(obj, prop, value)\n      //   setData(obj, {prop:value, ...})\n      //\n      setData: function setData() {\n        var obj = arguments[0];\n\n        if (arguments.length === 3) {\n          // setting a single property\n          var data = obj.hasOwnProperty(jsc.dataProp) ? obj[jsc.dataProp] : obj[jsc.dataProp] = {};\n          var prop = arguments[1];\n          var value = arguments[2];\n          data[prop] = value;\n          return true;\n        } else if (arguments.length === 2 && _typeof(arguments[1]) === 'object') {\n          // setting multiple properties\n          var data = obj.hasOwnProperty(jsc.dataProp) ? obj[jsc.dataProp] : obj[jsc.dataProp] = {};\n          var map = arguments[1];\n\n          for (var prop in map) {\n            if (map.hasOwnProperty(prop)) {\n              data[prop] = map[prop];\n            }\n          }\n\n          return true;\n        }\n\n        throw new Error('Invalid arguments');\n      },\n      // usage:\n      //   removeData(obj, prop, [prop...])\n      //\n      removeData: function removeData() {\n        var obj = arguments[0];\n\n        if (!obj.hasOwnProperty(jsc.dataProp)) {\n          return true; // data object does not exist\n        }\n\n        for (var i = 1; i < arguments.length; i += 1) {\n          var prop = arguments[i];\n          delete obj[jsc.dataProp][prop];\n        }\n\n        return true;\n      },\n      getData: function getData(obj, prop, setDefault) {\n        if (!obj.hasOwnProperty(jsc.dataProp)) {\n          // data object does not exist\n          if (setDefault !== undefined) {\n            obj[jsc.dataProp] = {}; // create data object\n          } else {\n            return undefined; // no value to return\n          }\n        }\n\n        var data = obj[jsc.dataProp];\n\n        if (!data.hasOwnProperty(prop) && setDefault !== undefined) {\n          data[prop] = setDefault;\n        }\n\n        return data[prop];\n      },\n      getDataAttr: function getDataAttr(el, name) {\n        var attrName = 'data-' + name;\n        var attrValue = el.getAttribute(attrName);\n        return attrValue;\n      },\n      _attachedGroupEvents: {},\n      attachGroupEvent: function attachGroupEvent(groupName, el, evnt, func) {\n        if (!jsc._attachedGroupEvents.hasOwnProperty(groupName)) {\n          jsc._attachedGroupEvents[groupName] = [];\n        }\n\n        jsc._attachedGroupEvents[groupName].push([el, evnt, func]);\n\n        el.addEventListener(evnt, func, false);\n      },\n      detachGroupEvents: function detachGroupEvents(groupName) {\n        if (jsc._attachedGroupEvents.hasOwnProperty(groupName)) {\n          for (var i = 0; i < jsc._attachedGroupEvents[groupName].length; i += 1) {\n            var evt = jsc._attachedGroupEvents[groupName][i];\n            evt[0].removeEventListener(evt[1], evt[2], false);\n          }\n\n          delete jsc._attachedGroupEvents[groupName];\n        }\n      },\n      preventDefault: function preventDefault(e) {\n        if (e.preventDefault) {\n          e.preventDefault();\n        }\n\n        e.returnValue = false;\n      },\n      captureTarget: function captureTarget(target) {\n        // IE\n        if (target.setCapture) {\n          jsc._capturedTarget = target;\n\n          jsc._capturedTarget.setCapture();\n        }\n      },\n      releaseTarget: function releaseTarget() {\n        // IE\n        if (jsc._capturedTarget) {\n          jsc._capturedTarget.releaseCapture();\n\n          jsc._capturedTarget = null;\n        }\n      },\n      triggerEvent: function triggerEvent(el, eventName, bubbles, cancelable) {\n        if (!el) {\n          return;\n        }\n\n        var ev = null;\n\n        if (typeof Event === 'function') {\n          ev = new Event(eventName, {\n            bubbles: bubbles,\n            cancelable: cancelable\n          });\n        } else {\n          // IE\n          ev = document.createEvent('Event');\n          ev.initEvent(eventName, bubbles, cancelable);\n        }\n\n        if (!ev) {\n          return false;\n        } // so that we know that the event was triggered internally\n\n\n        jsc.setData(ev, 'internal', true);\n        el.dispatchEvent(ev);\n        return true;\n      },\n      triggerInputEvent: function triggerInputEvent(el, eventName, bubbles, cancelable) {\n        if (!el) {\n          return;\n        }\n\n        if (jsc.isTextInput(el)) {\n          jsc.triggerEvent(el, eventName, bubbles, cancelable);\n        }\n      },\n      eventKey: function eventKey(ev) {\n        var keys = {\n          9: 'Tab',\n          13: 'Enter',\n          27: 'Escape'\n        };\n\n        if (typeof ev.code === 'string') {\n          return ev.code;\n        } else if (ev.keyCode !== undefined && keys.hasOwnProperty(ev.keyCode)) {\n          return keys[ev.keyCode];\n        }\n\n        return null;\n      },\n      strList: function strList(str) {\n        if (!str) {\n          return [];\n        }\n\n        return str.replace(/^\\s+|\\s+$/g, '').split(/\\s+/);\n      },\n      // The className parameter (str) can only contain a single class name\n      hasClass: function hasClass(elm, className) {\n        if (!className) {\n          return false;\n        }\n\n        if (elm.classList !== undefined) {\n          return elm.classList.contains(className);\n        } // polyfill\n\n\n        return -1 != (' ' + elm.className.replace(/\\s+/g, ' ') + ' ').indexOf(' ' + className + ' ');\n      },\n      // The className parameter (str) can contain multiple class names separated by whitespace\n      addClass: function addClass(elm, className) {\n        var classNames = jsc.strList(className);\n\n        if (elm.classList !== undefined) {\n          for (var i = 0; i < classNames.length; i += 1) {\n            elm.classList.add(classNames[i]);\n          }\n\n          return;\n        } // polyfill\n\n\n        for (var i = 0; i < classNames.length; i += 1) {\n          if (!jsc.hasClass(elm, classNames[i])) {\n            elm.className += (elm.className ? ' ' : '') + classNames[i];\n          }\n        }\n      },\n      // The className parameter (str) can contain multiple class names separated by whitespace\n      removeClass: function removeClass(elm, className) {\n        var classNames = jsc.strList(className);\n\n        if (elm.classList !== undefined) {\n          for (var i = 0; i < classNames.length; i += 1) {\n            elm.classList.remove(classNames[i]);\n          }\n\n          return;\n        } // polyfill\n\n\n        for (var i = 0; i < classNames.length; i += 1) {\n          var repl = new RegExp('^\\\\s*' + classNames[i] + '\\\\s*|' + '\\\\s*' + classNames[i] + '\\\\s*$|' + '\\\\s+' + classNames[i] + '(\\\\s+)', 'g');\n          elm.className = elm.className.replace(repl, '$1');\n        }\n      },\n      getCompStyle: function getCompStyle(elm) {\n        var compStyle = window.getComputedStyle ? window.getComputedStyle(elm) : elm.currentStyle; // Note: In Firefox, getComputedStyle returns null in a hidden iframe,\n        // that's why we need to check if the returned value is non-empty\n\n        if (!compStyle) {\n          return {};\n        }\n\n        return compStyle;\n      },\n      // Note:\n      //   Setting a property to NULL reverts it to the state before it was first set\n      //   with the 'reversible' flag enabled\n      //\n      setStyle: function setStyle(elm, styles, important, reversible) {\n        // using '' for standard priority (IE10 apparently doesn't like value undefined)\n        var priority = important ? 'important' : '';\n        var origStyle = null;\n\n        for (var prop in styles) {\n          if (styles.hasOwnProperty(prop)) {\n            var setVal = null;\n\n            if (styles[prop] === null) {\n              // reverting a property value\n              if (!origStyle) {\n                // get the original style object, but dont't try to create it if it doesn't exist\n                origStyle = jsc.getData(elm, 'origStyle');\n              }\n\n              if (origStyle && origStyle.hasOwnProperty(prop)) {\n                // we have property's original value -> use it\n                setVal = origStyle[prop];\n              }\n            } else {\n              // setting a property value\n              if (reversible) {\n                if (!origStyle) {\n                  // get the original style object and if it doesn't exist, create it\n                  origStyle = jsc.getData(elm, 'origStyle', {});\n                }\n\n                if (!origStyle.hasOwnProperty(prop)) {\n                  // original property value not yet stored -> store it\n                  origStyle[prop] = elm.style[prop];\n                }\n              }\n\n              setVal = styles[prop];\n            }\n\n            if (setVal !== null) {\n              elm.style.setProperty(prop, setVal, priority);\n            }\n          }\n        }\n      },\n      linearGradient: function () {\n        function getFuncName() {\n          var stdName = 'linear-gradient';\n          var prefixes = ['', '-webkit-', '-moz-', '-o-', '-ms-'];\n          var helper = document.createElement('div');\n\n          for (var i = 0; i < prefixes.length; i += 1) {\n            var tryFunc = prefixes[i] + stdName;\n            var tryVal = tryFunc + '(to right, rgba(0,0,0,0), rgba(0,0,0,0))';\n            helper.style.background = tryVal;\n\n            if (helper.style.background) {\n              // CSS background successfully set -> function name is supported\n              return tryFunc;\n            }\n          }\n\n          return stdName; // fallback to standard 'linear-gradient' without vendor prefix\n        }\n\n        var funcName = getFuncName();\n        return function () {\n          return funcName + '(' + Array.prototype.join.call(arguments, ', ') + ')';\n        };\n      }(),\n      setBorderRadius: function setBorderRadius(elm, value) {\n        jsc.setStyle(elm, {\n          'border-radius': value || '0'\n        });\n      },\n      setBoxShadow: function setBoxShadow(elm, value) {\n        jsc.setStyle(elm, {\n          'box-shadow': value || 'none'\n        });\n      },\n      getElementPos: function getElementPos(e, relativeToViewport) {\n        var x = 0,\n            y = 0;\n        var rect = e.getBoundingClientRect();\n        x = rect.left;\n        y = rect.top;\n\n        if (!relativeToViewport) {\n          var viewPos = jsc.getViewPos();\n          x += viewPos[0];\n          y += viewPos[1];\n        }\n\n        return [x, y];\n      },\n      getElementSize: function getElementSize(e) {\n        return [e.offsetWidth, e.offsetHeight];\n      },\n      // get pointer's X/Y coordinates relative to viewport\n      getAbsPointerPos: function getAbsPointerPos(e) {\n        var x = 0,\n            y = 0;\n\n        if (typeof e.changedTouches !== 'undefined' && e.changedTouches.length) {\n          // touch devices\n          x = e.changedTouches[0].clientX;\n          y = e.changedTouches[0].clientY;\n        } else if (typeof e.clientX === 'number') {\n          x = e.clientX;\n          y = e.clientY;\n        }\n\n        return {\n          x: x,\n          y: y\n        };\n      },\n      // get pointer's X/Y coordinates relative to target element\n      getRelPointerPos: function getRelPointerPos(e) {\n        var target = e.target || e.srcElement;\n        var targetRect = target.getBoundingClientRect();\n        var x = 0,\n            y = 0;\n        var clientX = 0,\n            clientY = 0;\n\n        if (typeof e.changedTouches !== 'undefined' && e.changedTouches.length) {\n          // touch devices\n          clientX = e.changedTouches[0].clientX;\n          clientY = e.changedTouches[0].clientY;\n        } else if (typeof e.clientX === 'number') {\n          clientX = e.clientX;\n          clientY = e.clientY;\n        }\n\n        x = clientX - targetRect.left;\n        y = clientY - targetRect.top;\n        return {\n          x: x,\n          y: y\n        };\n      },\n      getViewPos: function getViewPos() {\n        var doc = document.documentElement;\n        return [(window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0), (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)];\n      },\n      getViewSize: function getViewSize() {\n        var doc = document.documentElement;\n        return [window.innerWidth || doc.clientWidth, window.innerHeight || doc.clientHeight];\n      },\n      // r: 0-255\n      // g: 0-255\n      // b: 0-255\n      //\n      // returns: [ 0-360, 0-100, 0-100 ]\n      //\n      RGB_HSV: function RGB_HSV(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var n = Math.min(Math.min(r, g), b);\n        var v = Math.max(Math.max(r, g), b);\n        var m = v - n;\n\n        if (m === 0) {\n          return [null, 0, 100 * v];\n        }\n\n        var h = r === n ? 3 + (b - g) / m : g === n ? 5 + (r - b) / m : 1 + (g - r) / m;\n        return [60 * (h === 6 ? 0 : h), 100 * (m / v), 100 * v];\n      },\n      // h: 0-360\n      // s: 0-100\n      // v: 0-100\n      //\n      // returns: [ 0-255, 0-255, 0-255 ]\n      //\n      HSV_RGB: function HSV_RGB(h, s, v) {\n        var u = 255 * (v / 100);\n\n        if (h === null) {\n          return [u, u, u];\n        }\n\n        h /= 60;\n        s /= 100;\n        var i = Math.floor(h);\n        var f = i % 2 ? h - i : 1 - (h - i);\n        var m = u * (1 - s);\n        var n = u * (1 - s * f);\n\n        switch (i) {\n          case 6:\n          case 0:\n            return [u, n, m];\n\n          case 1:\n            return [n, u, m];\n\n          case 2:\n            return [m, u, n];\n\n          case 3:\n            return [m, n, u];\n\n          case 4:\n            return [n, m, u];\n\n          case 5:\n            return [u, m, n];\n        }\n      },\n      parseColorString: function parseColorString(str) {\n        var ret = {\n          rgba: null,\n          format: null // 'hex' | 'rgb' | 'rgba'\n\n        };\n        var m;\n\n        if (m = str.match(/^\\W*([0-9A-F]{3}([0-9A-F]{3})?)\\W*$/i)) {\n          // HEX notation\n          ret.format = 'hex';\n\n          if (m[1].length === 6) {\n            // 6-char notation\n            ret.rgba = [parseInt(m[1].substr(0, 2), 16), parseInt(m[1].substr(2, 2), 16), parseInt(m[1].substr(4, 2), 16), null];\n          } else {\n            // 3-char notation\n            ret.rgba = [parseInt(m[1].charAt(0) + m[1].charAt(0), 16), parseInt(m[1].charAt(1) + m[1].charAt(1), 16), parseInt(m[1].charAt(2) + m[1].charAt(2), 16), null];\n          }\n\n          return ret;\n        } else if (m = str.match(/^\\W*rgba?\\(([^)]*)\\)\\W*$/i)) {\n          // rgb(...) or rgba(...) notation\n          var params = m[1].split(',');\n          var re = /^\\s*(\\d+|\\d*\\.\\d+|\\d+\\.\\d*)\\s*$/;\n          var mR, mG, mB, mA;\n\n          if (params.length >= 3 && (mR = params[0].match(re)) && (mG = params[1].match(re)) && (mB = params[2].match(re))) {\n            ret.format = 'rgb';\n            ret.rgba = [parseFloat(mR[1]) || 0, parseFloat(mG[1]) || 0, parseFloat(mB[1]) || 0, null];\n\n            if (params.length >= 4 && (mA = params[3].match(re))) {\n              ret.format = 'rgba';\n              ret.rgba[3] = parseFloat(mA[1]) || 0;\n            }\n\n            return ret;\n          }\n        }\n\n        return false;\n      },\n      // Canvas scaling for retina displays\n      //\n      // adapted from https://www.html5rocks.com/en/tutorials/canvas/hidpi/\n      //\n      scaleCanvasForHighDPR: function scaleCanvasForHighDPR(canvas) {\n        var dpr = window.devicePixelRatio || 1;\n        canvas.width *= dpr;\n        canvas.height *= dpr;\n        var ctx = canvas.getContext('2d');\n        ctx.scale(dpr, dpr);\n      },\n      genColorPreviewCanvas: function genColorPreviewCanvas(color, separatorPos, specWidth, scaleForHighDPR) {\n        var sepW = Math.round(jsc.pub.previewSeparator.length);\n        var sqSize = jsc.pub.chessboardSize;\n        var sqColor1 = jsc.pub.chessboardColor1;\n        var sqColor2 = jsc.pub.chessboardColor2;\n        var cWidth = specWidth ? specWidth : sqSize * 2;\n        var cHeight = sqSize * 2;\n        var canvas = jsc.createEl('canvas');\n        var ctx = canvas.getContext('2d');\n        canvas.width = cWidth;\n        canvas.height = cHeight;\n\n        if (scaleForHighDPR) {\n          jsc.scaleCanvasForHighDPR(canvas);\n        } // transparency chessboard - background\n\n\n        ctx.fillStyle = sqColor1;\n        ctx.fillRect(0, 0, cWidth, cHeight); // transparency chessboard - squares\n\n        ctx.fillStyle = sqColor2;\n\n        for (var x = 0; x < cWidth; x += sqSize * 2) {\n          ctx.fillRect(x, 0, sqSize, sqSize);\n          ctx.fillRect(x + sqSize, sqSize, sqSize, sqSize);\n        }\n\n        if (color) {\n          // actual color in foreground\n          ctx.fillStyle = color;\n          ctx.fillRect(0, 0, cWidth, cHeight);\n        }\n\n        var start = null;\n\n        switch (separatorPos) {\n          case 'left':\n            start = 0;\n            ctx.clearRect(0, 0, sepW / 2, cHeight);\n            break;\n\n          case 'right':\n            start = cWidth - sepW;\n            ctx.clearRect(cWidth - sepW / 2, 0, sepW / 2, cHeight);\n            break;\n        }\n\n        if (start !== null) {\n          ctx.lineWidth = 1;\n\n          for (var i = 0; i < jsc.pub.previewSeparator.length; i += 1) {\n            ctx.beginPath();\n            ctx.strokeStyle = jsc.pub.previewSeparator[i];\n            ctx.moveTo(0.5 + start + i, 0);\n            ctx.lineTo(0.5 + start + i, cHeight);\n            ctx.stroke();\n          }\n        }\n\n        return {\n          canvas: canvas,\n          width: cWidth,\n          height: cHeight\n        };\n      },\n      // if position or width is not set => fill the entire element (0%-100%)\n      genColorPreviewGradient: function genColorPreviewGradient(color, position, width) {\n        var params = [];\n\n        if (position && width) {\n          params = ['to ' + {\n            'left': 'right',\n            'right': 'left'\n          }[position], color + ' 0%', color + ' ' + width + 'px', 'rgba(0,0,0,0) ' + (width + 1) + 'px', 'rgba(0,0,0,0) 100%'];\n        } else {\n          params = ['to right', color + ' 0%', color + ' 100%'];\n        }\n\n        return jsc.linearGradient.apply(this, params);\n      },\n      redrawPosition: function redrawPosition() {\n        if (jsc.picker && jsc.picker.owner) {\n          var thisObj = jsc.picker.owner;\n          var tp, vp;\n\n          if (thisObj.fixed) {\n            // Fixed elements are positioned relative to viewport,\n            // therefore we can ignore the scroll offset\n            tp = jsc.getElementPos(thisObj.targetElement, true); // target pos\n\n            vp = [0, 0]; // view pos\n          } else {\n            tp = jsc.getElementPos(thisObj.targetElement); // target pos\n\n            vp = jsc.getViewPos(); // view pos\n          }\n\n          var ts = jsc.getElementSize(thisObj.targetElement); // target size\n\n          var vs = jsc.getViewSize(); // view size\n\n          var ps = jsc.getPickerOuterDims(thisObj); // picker size\n\n          var a, b, c;\n\n          switch (thisObj.position.toLowerCase()) {\n            case 'left':\n              a = 1;\n              b = 0;\n              c = -1;\n              break;\n\n            case 'right':\n              a = 1;\n              b = 0;\n              c = 1;\n              break;\n\n            case 'top':\n              a = 0;\n              b = 1;\n              c = -1;\n              break;\n\n            default:\n              a = 0;\n              b = 1;\n              c = 1;\n              break;\n          }\n\n          var l = (ts[b] + ps[b]) / 2; // compute picker position\n\n          if (!thisObj.smartPosition) {\n            var pp = [tp[a], tp[b] + ts[b] - l + l * c];\n          } else {\n            var pp = [-vp[a] + tp[a] + ps[a] > vs[a] ? -vp[a] + tp[a] + ts[a] / 2 > vs[a] / 2 && tp[a] + ts[a] - ps[a] >= 0 ? tp[a] + ts[a] - ps[a] : tp[a] : tp[a], -vp[b] + tp[b] + ts[b] + ps[b] - l + l * c > vs[b] ? -vp[b] + tp[b] + ts[b] / 2 > vs[b] / 2 && tp[b] + ts[b] - l - l * c >= 0 ? tp[b] + ts[b] - l - l * c : tp[b] + ts[b] - l + l * c : tp[b] + ts[b] - l + l * c >= 0 ? tp[b] + ts[b] - l + l * c : tp[b] + ts[b] - l - l * c];\n          }\n\n          var x = pp[a];\n          var y = pp[b];\n          var positionValue = thisObj.fixed ? 'fixed' : 'absolute';\n          var contractShadow = (pp[0] + ps[0] > tp[0] || pp[0] < tp[0] + ts[0]) && pp[1] + ps[1] < tp[1] + ts[1];\n\n          jsc._drawPosition(thisObj, x, y, positionValue, contractShadow);\n        }\n      },\n      _drawPosition: function _drawPosition(thisObj, x, y, positionValue, contractShadow) {\n        var vShadow = contractShadow ? 0 : thisObj.shadowBlur; // px\n\n        jsc.picker.wrap.style.position = positionValue;\n        jsc.picker.wrap.style.left = x + 'px';\n        jsc.picker.wrap.style.top = y + 'px';\n        jsc.setBoxShadow(jsc.picker.boxS, thisObj.shadow ? new jsc.BoxShadow(0, vShadow, thisObj.shadowBlur, 0, thisObj.shadowColor) : null);\n      },\n      getPickerDims: function getPickerDims(thisObj) {\n        var dims = [2 * thisObj.controlBorderWidth + 2 * thisObj.padding + thisObj.width, 2 * thisObj.controlBorderWidth + 2 * thisObj.padding + thisObj.height];\n        var sliderSpace = 2 * thisObj.controlBorderWidth + 2 * jsc.getControlPadding(thisObj) + thisObj.sliderSize;\n\n        if (jsc.getSliderChannel(thisObj)) {\n          dims[0] += sliderSpace;\n        }\n\n        if (thisObj.hasAlphaChannel()) {\n          dims[0] += sliderSpace;\n        }\n\n        if (thisObj.closeButton) {\n          dims[1] += 2 * thisObj.controlBorderWidth + thisObj.padding + thisObj.buttonHeight;\n        }\n\n        return dims;\n      },\n      getPickerOuterDims: function getPickerOuterDims(thisObj) {\n        var dims = jsc.getPickerDims(thisObj);\n        return [dims[0] + 2 * thisObj.borderWidth, dims[1] + 2 * thisObj.borderWidth];\n      },\n      getControlPadding: function getControlPadding(thisObj) {\n        return Math.max(thisObj.padding / 2, 2 * thisObj.pointerBorderWidth + thisObj.pointerThickness - thisObj.controlBorderWidth);\n      },\n      getPadYChannel: function getPadYChannel(thisObj) {\n        switch (thisObj.mode.charAt(1).toLowerCase()) {\n          case 'v':\n            return 'v';\n            break;\n        }\n\n        return 's';\n      },\n      getSliderChannel: function getSliderChannel(thisObj) {\n        if (thisObj.mode.length > 2) {\n          switch (thisObj.mode.charAt(2).toLowerCase()) {\n            case 's':\n              return 's';\n              break;\n\n            case 'v':\n              return 'v';\n              break;\n          }\n        }\n\n        return null;\n      },\n      onDocumentMouseDown: function onDocumentMouseDown(e) {\n        var target = e.target || e.srcElement;\n\n        if (target.jscolor && target.jscolor instanceof jsc.pub) {\n          // clicked targetElement -> show picker\n          if (target.jscolor.showOnClick && !target.disabled) {\n            target.jscolor.show();\n          }\n        } else if (jsc.getData(target, 'gui')) {\n          // clicked jscolor's GUI element\n          var control = jsc.getData(target, 'control');\n\n          if (control) {\n            // jscolor's control\n            jsc.onControlPointerStart(e, target, jsc.getData(target, 'control'), 'mouse');\n          }\n        } else {\n          // mouse is outside the picker's controls -> hide the color picker!\n          if (jsc.picker && jsc.picker.owner) {\n            jsc.picker.owner.tryHide();\n          }\n        }\n      },\n      onDocumentKeyUp: function onDocumentKeyUp(e) {\n        if (['Tab', 'Escape'].indexOf(jsc.eventKey(e)) !== -1) {\n          if (jsc.picker && jsc.picker.owner) {\n            jsc.picker.owner.tryHide();\n          }\n        }\n      },\n      onWindowResize: function onWindowResize(e) {\n        jsc.redrawPosition();\n      },\n      onParentScroll: function onParentScroll(e) {\n        // hide the picker when one of the parent elements is scrolled\n        if (jsc.picker && jsc.picker.owner) {\n          jsc.picker.owner.tryHide();\n        }\n      },\n      onPickerTouchStart: function onPickerTouchStart(e) {\n        var target = e.target || e.srcElement;\n\n        if (jsc.getData(target, 'control')) {\n          jsc.onControlPointerStart(e, target, jsc.getData(target, 'control'), 'touch');\n        }\n      },\n      // calls function specified in picker's property\n      triggerCallback: function triggerCallback(thisObj, prop) {\n        if (!thisObj[prop]) {\n          return; // callback func not specified\n        }\n\n        var callback = null;\n\n        if (typeof thisObj[prop] === 'string') {\n          // string with code\n          try {\n            callback = new Function(thisObj[prop]);\n          } catch (e) {\n            console.error(e);\n          }\n        } else {\n          // function\n          callback = thisObj[prop];\n        }\n\n        if (callback) {\n          callback.call(thisObj);\n        }\n      },\n      // Triggers a color change related event(s) on all picker instances.\n      // It is possible to specify multiple events separated with a space.\n      triggerGlobal: function triggerGlobal(eventNames) {\n        var inst = jsc.getInstances();\n\n        for (var i = 0; i < inst.length; i += 1) {\n          inst[i].trigger(eventNames);\n        }\n      },\n      _pointerMoveEvent: {\n        mouse: 'mousemove',\n        touch: 'touchmove'\n      },\n      _pointerEndEvent: {\n        mouse: 'mouseup',\n        touch: 'touchend'\n      },\n      _pointerOrigin: null,\n      _capturedTarget: null,\n      onControlPointerStart: function onControlPointerStart(e, target, controlName, pointerType) {\n        var thisObj = jsc.getData(target, 'instance');\n        jsc.preventDefault(e);\n        jsc.captureTarget(target);\n\n        var registerDragEvents = function registerDragEvents(doc, offset) {\n          jsc.attachGroupEvent('drag', doc, jsc._pointerMoveEvent[pointerType], jsc.onDocumentPointerMove(e, target, controlName, pointerType, offset));\n          jsc.attachGroupEvent('drag', doc, jsc._pointerEndEvent[pointerType], jsc.onDocumentPointerEnd(e, target, controlName, pointerType));\n        };\n\n        registerDragEvents(document, [0, 0]);\n\n        if (window.parent && window.frameElement) {\n          var rect = window.frameElement.getBoundingClientRect();\n          var ofs = [-rect.left, -rect.top];\n          registerDragEvents(window.parent.window.document, ofs);\n        }\n\n        var abs = jsc.getAbsPointerPos(e);\n        var rel = jsc.getRelPointerPos(e);\n        jsc._pointerOrigin = {\n          x: abs.x - rel.x,\n          y: abs.y - rel.y\n        };\n\n        switch (controlName) {\n          case 'pad':\n            // if the value slider is at the bottom, move it up\n            if (jsc.getSliderChannel(thisObj) === 'v' && thisObj.channels.v === 0) {\n              thisObj.fromHSVA(null, null, 100, null);\n            }\n\n            jsc.setPad(thisObj, e, 0, 0);\n            break;\n\n          case 'sld':\n            jsc.setSld(thisObj, e, 0);\n            break;\n\n          case 'asld':\n            jsc.setASld(thisObj, e, 0);\n            break;\n        }\n\n        thisObj.trigger('input');\n      },\n      onDocumentPointerMove: function onDocumentPointerMove(e, target, controlName, pointerType, offset) {\n        return function (e) {\n          var thisObj = jsc.getData(target, 'instance');\n\n          switch (controlName) {\n            case 'pad':\n              jsc.setPad(thisObj, e, offset[0], offset[1]);\n              break;\n\n            case 'sld':\n              jsc.setSld(thisObj, e, offset[1]);\n              break;\n\n            case 'asld':\n              jsc.setASld(thisObj, e, offset[1]);\n              break;\n          }\n\n          thisObj.trigger('input');\n        };\n      },\n      onDocumentPointerEnd: function onDocumentPointerEnd(e, target, controlName, pointerType) {\n        return function (e) {\n          var thisObj = jsc.getData(target, 'instance');\n          jsc.detachGroupEvents('drag');\n          jsc.releaseTarget(); // Always trigger changes AFTER detaching outstanding mouse handlers,\n          // in case some color change occured in user-defined onChange/onInput handler\n          // would intrude into current mouse events\n\n          thisObj.trigger('input');\n          thisObj.trigger('change');\n        };\n      },\n      setPad: function setPad(thisObj, e, ofsX, ofsY) {\n        var pointerAbs = jsc.getAbsPointerPos(e);\n        var x = ofsX + pointerAbs.x - jsc._pointerOrigin.x - thisObj.padding - thisObj.controlBorderWidth;\n        var y = ofsY + pointerAbs.y - jsc._pointerOrigin.y - thisObj.padding - thisObj.controlBorderWidth;\n        var xVal = x * (360 / (thisObj.width - 1));\n        var yVal = 100 - y * (100 / (thisObj.height - 1));\n\n        switch (jsc.getPadYChannel(thisObj)) {\n          case 's':\n            thisObj.fromHSVA(xVal, yVal, null, null);\n            break;\n\n          case 'v':\n            thisObj.fromHSVA(xVal, null, yVal, null);\n            break;\n        }\n      },\n      setSld: function setSld(thisObj, e, ofsY) {\n        var pointerAbs = jsc.getAbsPointerPos(e);\n        var y = ofsY + pointerAbs.y - jsc._pointerOrigin.y - thisObj.padding - thisObj.controlBorderWidth;\n        var yVal = 100 - y * (100 / (thisObj.height - 1));\n\n        switch (jsc.getSliderChannel(thisObj)) {\n          case 's':\n            thisObj.fromHSVA(null, yVal, null, null);\n            break;\n\n          case 'v':\n            thisObj.fromHSVA(null, null, yVal, null);\n            break;\n        }\n      },\n      setASld: function setASld(thisObj, e, ofsY) {\n        var pointerAbs = jsc.getAbsPointerPos(e);\n        var y = ofsY + pointerAbs.y - jsc._pointerOrigin.y - thisObj.padding - thisObj.controlBorderWidth;\n        var yVal = 1.0 - y * (1.0 / (thisObj.height - 1));\n\n        if (yVal < 1.0) {\n          // if format is flexible and the current format doesn't support alpha, switch to a suitable one\n          if (thisObj.format.toLowerCase() === 'any' && thisObj.getFormat() !== 'rgba') {\n            thisObj._currentFormat = 'rgba';\n          }\n        }\n\n        thisObj.fromHSVA(null, null, null, yVal);\n      },\n      createPalette: function createPalette() {\n        var paletteObj = {\n          elm: null,\n          draw: null\n        };\n        var canvas = jsc.createEl('canvas');\n        var ctx = canvas.getContext('2d');\n\n        var drawFunc = function drawFunc(width, height, type) {\n          canvas.width = width;\n          canvas.height = height;\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          var hGrad = ctx.createLinearGradient(0, 0, canvas.width, 0);\n          hGrad.addColorStop(0 / 6, '#F00');\n          hGrad.addColorStop(1 / 6, '#FF0');\n          hGrad.addColorStop(2 / 6, '#0F0');\n          hGrad.addColorStop(3 / 6, '#0FF');\n          hGrad.addColorStop(4 / 6, '#00F');\n          hGrad.addColorStop(5 / 6, '#F0F');\n          hGrad.addColorStop(6 / 6, '#F00');\n          ctx.fillStyle = hGrad;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n          var vGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);\n\n          switch (type.toLowerCase()) {\n            case 's':\n              vGrad.addColorStop(0, 'rgba(255,255,255,0)');\n              vGrad.addColorStop(1, 'rgba(255,255,255,1)');\n              break;\n\n            case 'v':\n              vGrad.addColorStop(0, 'rgba(0,0,0,0)');\n              vGrad.addColorStop(1, 'rgba(0,0,0,1)');\n              break;\n          }\n\n          ctx.fillStyle = vGrad;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n        };\n\n        paletteObj.elm = canvas;\n        paletteObj.draw = drawFunc;\n        return paletteObj;\n      },\n      createSliderGradient: function createSliderGradient() {\n        var sliderObj = {\n          elm: null,\n          draw: null\n        };\n        var canvas = jsc.createEl('canvas');\n        var ctx = canvas.getContext('2d');\n\n        var drawFunc = function drawFunc(width, height, color1, color2) {\n          canvas.width = width;\n          canvas.height = height;\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          var grad = ctx.createLinearGradient(0, 0, 0, canvas.height);\n          grad.addColorStop(0, color1);\n          grad.addColorStop(1, color2);\n          ctx.fillStyle = grad;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n        };\n\n        sliderObj.elm = canvas;\n        sliderObj.draw = drawFunc;\n        return sliderObj;\n      },\n      createASliderGradient: function createASliderGradient() {\n        var sliderObj = {\n          elm: null,\n          draw: null\n        };\n        var canvas = jsc.createEl('canvas');\n        var ctx = canvas.getContext('2d');\n\n        var drawFunc = function drawFunc(width, height, color) {\n          canvas.width = width;\n          canvas.height = height;\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          var sqSize = canvas.width / 2;\n          var sqColor1 = jsc.pub.chessboardColor1;\n          var sqColor2 = jsc.pub.chessboardColor2; // dark gray background\n\n          ctx.fillStyle = sqColor1;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n          for (var y = 0; y < canvas.height; y += sqSize * 2) {\n            // light gray squares\n            ctx.fillStyle = sqColor2;\n            ctx.fillRect(0, y, sqSize, sqSize);\n            ctx.fillRect(sqSize, y + sqSize, sqSize, sqSize);\n          }\n\n          var grad = ctx.createLinearGradient(0, 0, 0, canvas.height);\n          grad.addColorStop(0, color);\n          grad.addColorStop(1, 'rgba(0,0,0,0)');\n          ctx.fillStyle = grad;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n        };\n\n        sliderObj.elm = canvas;\n        sliderObj.draw = drawFunc;\n        return sliderObj;\n      },\n      BoxShadow: function () {\n        var BoxShadow = function BoxShadow(hShadow, vShadow, blur, spread, color, inset) {\n          this.hShadow = hShadow;\n          this.vShadow = vShadow;\n          this.blur = blur;\n          this.spread = spread;\n          this.color = color;\n          this.inset = !!inset;\n        };\n\n        BoxShadow.prototype.toString = function () {\n          var vals = [Math.round(this.hShadow) + 'px', Math.round(this.vShadow) + 'px', Math.round(this.blur) + 'px', Math.round(this.spread) + 'px', this.color];\n\n          if (this.inset) {\n            vals.push('inset');\n          }\n\n          return vals.join(' ');\n        };\n\n        return BoxShadow;\n      }(),\n      flags: {\n        leaveValue: 1 << 0,\n        leaveAlpha: 1 << 1,\n        leavePreview: 1 << 2\n      },\n      enumOpts: {\n        format: ['auto', 'any', 'hex', 'rgb', 'rgba'],\n        previewPosition: ['left', 'right'],\n        mode: ['hsv', 'hvs', 'hs', 'hv'],\n        position: ['left', 'right', 'top', 'bottom'],\n        alphaChannel: ['auto', true, false]\n      },\n      deprecatedOpts: {\n        // <old_option>: <new_option>  (<new_option> can be null)\n        'styleElement': 'previewElement',\n        'onFineChange': 'onInput',\n        'overwriteImportant': 'forceStyle',\n        'closable': 'closeButton',\n        'insetWidth': 'controlBorderWidth',\n        'insetColor': 'controlBorderColor',\n        'refine': null\n      },\n      docsRef: ' ' + 'See https://jscolor.com/docs/',\n      //\n      // Usage:\n      // var myPicker = new JSColor(<targetElement> [, <options>])\n      //\n      // (constructor is accessible via both 'jscolor' and 'JSColor' name)\n      //\n      pub: function pub(targetElement, opts) {\n        var THIS = this;\n\n        if (!opts) {\n          opts = {};\n        }\n\n        this.channels = {\n          r: 255,\n          // red [0-255]\n          g: 255,\n          // green [0-255]\n          b: 255,\n          // blue [0-255]\n          h: 0,\n          // hue [0-360]\n          s: 0,\n          // saturation [0-100]\n          v: 100,\n          // value (brightness) [0-100]\n          a: 1.0 // alpha (opacity) [0.0 - 1.0]\n\n        }; // General options\n        //\n\n        this.format = 'auto'; // 'auto' | 'any' | 'hex' | 'rgb' | 'rgba' - Format of the input/output value\n\n        this.value = undefined; // INITIAL color value in any supported format. To change it later, use method fromString(), fromHSVA(), fromRGBA() or channel()\n\n        this.alpha = undefined; // INITIAL alpha value. To change it later, call method channel('A', <value>)\n\n        this.onChange = undefined; // called when color changes. Value can be either a function or a string with JS code.\n\n        this.onInput = undefined; // called repeatedly as the color is being changed, e.g. while dragging a slider. Value can be either a function or a string with JS code.\n\n        this.valueElement = undefined; // element that will be used to display and input the color value\n\n        this.alphaElement = undefined; // element that will be used to display and input the alpha (opacity) value\n\n        this.previewElement = undefined; // element that will preview the picked color using CSS background\n\n        this.previewPosition = 'left'; // 'left' | 'right' - position of the color preview in previewElement\n\n        this.previewSize = 32; // (px) width of the color preview displayed in previewElement\n\n        this.previewPadding = 8; // (px) space between color preview and content of the previewElement\n\n        this.required = true; // whether the associated text input must always contain a color value. If false, the input can be left empty.\n\n        this.hash = true; // whether to prefix the HEX color code with # symbol (only applicable for HEX format)\n\n        this.uppercase = true; // whether to show the HEX color code in upper case (only applicable for HEX format)\n\n        this.forceStyle = true; // whether to overwrite CSS style of the previewElement using !important flag\n        // Color Picker options\n        //\n\n        this.width = 181; // width of color palette (in px)\n\n        this.height = 101; // height of color palette (in px)\n\n        this.mode = 'HSV'; // 'HSV' | 'HVS' | 'HS' | 'HV' - layout of the color picker controls\n\n        this.alphaChannel = 'auto'; // 'auto' | true | false - if alpha channel is enabled, the alpha slider will be visible. If 'auto', it will be determined according to color format\n\n        this.position = 'bottom'; // 'left' | 'right' | 'top' | 'bottom' - position relative to the target element\n\n        this.smartPosition = true; // automatically change picker position when there is not enough space for it\n\n        this.showOnClick = true; // whether to show the picker when user clicks its target element\n\n        this.hideOnLeave = true; // whether to automatically hide the picker when user leaves its target element (e.g. upon clicking the document)\n\n        this.sliderSize = 16; // px\n\n        this.crossSize = 8; // px\n\n        this.closeButton = false; // whether to display the Close button\n\n        this.closeText = 'Close';\n        this.buttonColor = 'rgba(0,0,0,1)'; // CSS color\n\n        this.buttonHeight = 18; // px\n\n        this.padding = 12; // px\n\n        this.backgroundColor = 'rgba(255,255,255,1)'; // CSS color\n\n        this.borderWidth = 1; // px\n\n        this.borderColor = 'rgba(187,187,187,1)'; // CSS color\n\n        this.borderRadius = 8; // px\n\n        this.controlBorderWidth = 1; // px\n\n        this.controlBorderColor = 'rgba(187,187,187,1)'; // CSS color\n\n        this.shadow = true; // whether to display a shadow\n\n        this.shadowBlur = 15; // px\n\n        this.shadowColor = 'rgba(0,0,0,0.2)'; // CSS color\n\n        this.pointerColor = 'rgba(76,76,76,1)'; // CSS color\n\n        this.pointerBorderWidth = 1; // px\n\n        this.pointerBorderColor = 'rgba(255,255,255,1)'; // CSS color\n\n        this.pointerThickness = 2; // px\n\n        this.zIndex = 5000;\n        this.container = undefined; // where to append the color picker (BODY element by default)\n        // Experimental\n        //\n\n        this.minS = 0; // min allowed saturation (0 - 100)\n\n        this.maxS = 100; // max allowed saturation (0 - 100)\n\n        this.minV = 0; // min allowed value (brightness) (0 - 100)\n\n        this.maxV = 100; // max allowed value (brightness) (0 - 100)\n\n        this.minA = 0.0; // min allowed alpha (opacity) (0.0 - 1.0)\n\n        this.maxA = 1.0; // max allowed alpha (opacity) (0.0 - 1.0)\n        // let's process the DEPRECATED 'options' property (this will be later removed)\n\n        if (jsc.pub.options) {\n          // let's set custom default options, if specified\n          for (var opt in jsc.pub.options) {\n            if (jsc.pub.options.hasOwnProperty(opt)) {\n              try {\n                setOption(opt, jsc.pub.options[opt]);\n              } catch (e) {\n                console.warn(e);\n              }\n            }\n          }\n        } // let's apply configuration presets\n        //\n\n\n        var presetsArr = [];\n\n        if (opts.preset) {\n          if (typeof opts.preset === 'string') {\n            presetsArr = opts.preset.split(/\\s+/);\n          } else if (Array.isArray(opts.preset)) {\n            presetsArr = opts.preset.slice(); // slice() to clone\n          } else {\n            console.warn('Unrecognized preset value');\n          }\n        } // always use the 'default' preset. If it's not listed, append it to the end.\n\n\n        if (presetsArr.indexOf('default') === -1) {\n          presetsArr.push('default');\n        } // let's apply the presets in reverse order, so that should there be any overlapping options,\n        // the formerly listed preset will override the latter\n\n\n        for (var i = presetsArr.length - 1; i >= 0; i -= 1) {\n          var pres = presetsArr[i];\n\n          if (!pres) {\n            continue; // preset is empty string\n          }\n\n          if (!jsc.pub.presets.hasOwnProperty(pres)) {\n            console.warn('Unknown preset: %s', pres);\n            continue;\n          }\n\n          for (var opt in jsc.pub.presets[pres]) {\n            if (jsc.pub.presets[pres].hasOwnProperty(opt)) {\n              try {\n                setOption(opt, jsc.pub.presets[pres][opt]);\n              } catch (e) {\n                console.warn(e);\n              }\n            }\n          }\n        } // let's set specific options for this color picker\n\n\n        var nonProperties = [// these options won't be set as instance properties\n        'preset'];\n\n        for (var opt in opts) {\n          if (opts.hasOwnProperty(opt)) {\n            if (nonProperties.indexOf(opt) === -1) {\n              try {\n                setOption(opt, opts[opt]);\n              } catch (e) {\n                console.warn(e);\n              }\n            }\n          }\n        } // Getter: option(name)\n        // Setter: option(name, value)\n        //         option({name:value, ...})\n        //\n\n\n        this.option = function () {\n          if (!arguments.length) {\n            throw new Error('No option specified');\n          }\n\n          if (arguments.length === 1 && typeof arguments[0] === 'string') {\n            // getting a single option\n            try {\n              return getOption(arguments[0]);\n            } catch (e) {\n              console.warn(e);\n            }\n\n            return false;\n          } else if (arguments.length >= 2 && typeof arguments[0] === 'string') {\n            // setting a single option\n            try {\n              if (!setOption(arguments[0], arguments[1])) {\n                return false;\n              }\n            } catch (e) {\n              console.warn(e);\n              return false;\n            }\n\n            this.redraw(); // immediately redraws the picker, if it's displayed\n\n            this.exposeColor(); // in case some preview-related or format-related option was changed\n\n            return true;\n          } else if (arguments.length === 1 && _typeof(arguments[0]) === 'object') {\n            // setting multiple options\n            var opts = arguments[0];\n            var success = true;\n\n            for (var opt in opts) {\n              if (opts.hasOwnProperty(opt)) {\n                try {\n                  if (!setOption(opt, opts[opt])) {\n                    success = false;\n                  }\n                } catch (e) {\n                  console.warn(e);\n                  success = false;\n                }\n              }\n            }\n\n            this.redraw(); // immediately redraws the picker, if it's displayed\n\n            this.exposeColor(); // in case some preview-related or format-related option was changed\n\n            return success;\n          }\n\n          throw new Error('Invalid arguments');\n        }; // Getter: channel(name)\n        // Setter: channel(name, value)\n        //\n\n\n        this.channel = function (name, value) {\n          if (typeof name !== 'string') {\n            throw new Error('Invalid value for channel name: ' + name);\n          }\n\n          if (value === undefined) {\n            // getting channel value\n            if (!this.channels.hasOwnProperty(name.toLowerCase())) {\n              console.warn('Getting unknown channel: ' + name);\n              return false;\n            }\n\n            return this.channels[name.toLowerCase()];\n          } else {\n            // setting channel value\n            var res = false;\n\n            switch (name.toLowerCase()) {\n              case 'r':\n                res = this.fromRGBA(value, null, null, null);\n                break;\n\n              case 'g':\n                res = this.fromRGBA(null, value, null, null);\n                break;\n\n              case 'b':\n                res = this.fromRGBA(null, null, value, null);\n                break;\n\n              case 'h':\n                res = this.fromHSVA(value, null, null, null);\n                break;\n\n              case 's':\n                res = this.fromHSVA(null, value, null, null);\n                break;\n\n              case 'v':\n                res = this.fromHSVA(null, null, value, null);\n                break;\n\n              case 'a':\n                res = this.fromHSVA(null, null, null, value);\n                break;\n\n              default:\n                console.warn('Setting unknown channel: ' + name);\n                return false;\n            }\n\n            if (res) {\n              this.redraw(); // immediately redraws the picker, if it's displayed\n\n              return true;\n            }\n          }\n\n          return false;\n        }; // Triggers given input event(s) by:\n        // - executing on<Event> callback specified as picker's option\n        // - triggering standard DOM event listeners attached to the value element\n        //\n        // It is possible to specify multiple events separated with a space.\n        //\n\n\n        this.trigger = function (eventNames) {\n          var evs = jsc.strList(eventNames);\n\n          for (var i = 0; i < evs.length; i += 1) {\n            var ev = evs[i].toLowerCase(); // trigger a callback\n\n            var callbackProp = null;\n\n            switch (ev) {\n              case 'input':\n                callbackProp = 'onInput';\n                break;\n\n              case 'change':\n                callbackProp = 'onChange';\n                break;\n            }\n\n            if (callbackProp) {\n              jsc.triggerCallback(this, callbackProp);\n            } // trigger standard DOM event listeners on the value element\n\n\n            jsc.triggerInputEvent(this.valueElement, ev, true, true);\n          }\n        }; // h: 0-360\n        // s: 0-100\n        // v: 0-100\n        // a: 0.0-1.0\n        //\n\n\n        this.fromHSVA = function (h, s, v, a, flags) {\n          // null = don't change\n          if (h === undefined) {\n            h = null;\n          }\n\n          if (s === undefined) {\n            s = null;\n          }\n\n          if (v === undefined) {\n            v = null;\n          }\n\n          if (a === undefined) {\n            a = null;\n          }\n\n          if (h !== null) {\n            if (isNaN(h)) {\n              return false;\n            }\n\n            this.channels.h = Math.max(0, Math.min(360, h));\n          }\n\n          if (s !== null) {\n            if (isNaN(s)) {\n              return false;\n            }\n\n            this.channels.s = Math.max(0, Math.min(100, this.maxS, s), this.minS);\n          }\n\n          if (v !== null) {\n            if (isNaN(v)) {\n              return false;\n            }\n\n            this.channels.v = Math.max(0, Math.min(100, this.maxV, v), this.minV);\n          }\n\n          if (a !== null) {\n            if (isNaN(a)) {\n              return false;\n            }\n\n            this.channels.a = this.hasAlphaChannel() ? Math.max(0, Math.min(1, this.maxA, a), this.minA) : 1.0; // if alpha channel is disabled, the color should stay 100% opaque\n          }\n\n          var rgb = jsc.HSV_RGB(this.channels.h, this.channels.s, this.channels.v);\n          this.channels.r = rgb[0];\n          this.channels.g = rgb[1];\n          this.channels.b = rgb[2];\n          this.exposeColor(flags);\n          return true;\n        }; // r: 0-255\n        // g: 0-255\n        // b: 0-255\n        // a: 0.0-1.0\n        //\n\n\n        this.fromRGBA = function (r, g, b, a, flags) {\n          // null = don't change\n          if (r === undefined) {\n            r = null;\n          }\n\n          if (g === undefined) {\n            g = null;\n          }\n\n          if (b === undefined) {\n            b = null;\n          }\n\n          if (a === undefined) {\n            a = null;\n          }\n\n          if (r !== null) {\n            if (isNaN(r)) {\n              return false;\n            }\n\n            r = Math.max(0, Math.min(255, r));\n          }\n\n          if (g !== null) {\n            if (isNaN(g)) {\n              return false;\n            }\n\n            g = Math.max(0, Math.min(255, g));\n          }\n\n          if (b !== null) {\n            if (isNaN(b)) {\n              return false;\n            }\n\n            b = Math.max(0, Math.min(255, b));\n          }\n\n          if (a !== null) {\n            if (isNaN(a)) {\n              return false;\n            }\n\n            this.channels.a = this.hasAlphaChannel() ? Math.max(0, Math.min(1, this.maxA, a), this.minA) : 1.0; // if alpha channel is disabled, the color should stay 100% opaque\n          }\n\n          var hsv = jsc.RGB_HSV(r === null ? this.channels.r : r, g === null ? this.channels.g : g, b === null ? this.channels.b : b);\n\n          if (hsv[0] !== null) {\n            this.channels.h = Math.max(0, Math.min(360, hsv[0]));\n          }\n\n          if (hsv[2] !== 0) {\n            // fully black color stays black through entire saturation range, so let's not change saturation\n            this.channels.s = Math.max(0, this.minS, Math.min(100, this.maxS, hsv[1]));\n          }\n\n          this.channels.v = Math.max(0, this.minV, Math.min(100, this.maxV, hsv[2])); // update RGB according to final HSV, as some values might be trimmed\n\n          var rgb = jsc.HSV_RGB(this.channels.h, this.channels.s, this.channels.v);\n          this.channels.r = rgb[0];\n          this.channels.g = rgb[1];\n          this.channels.b = rgb[2];\n          this.exposeColor(flags);\n          return true;\n        }; // DEPRECATED. Use .fromHSVA() instead\n        //\n\n\n        this.fromHSV = function (h, s, v, flags) {\n          console.warn('fromHSV() method is DEPRECATED. Using fromHSVA() instead.' + jsc.docsRef);\n          return this.fromHSVA(h, s, v, null, flags);\n        }; // DEPRECATED. Use .fromRGBA() instead\n        //\n\n\n        this.fromRGB = function (r, g, b, flags) {\n          console.warn('fromRGB() method is DEPRECATED. Using fromRGBA() instead.' + jsc.docsRef);\n          return this.fromRGBA(r, g, b, null, flags);\n        };\n\n        this.fromString = function (str, flags) {\n          if (!this.required && str.trim() === '') {\n            // setting empty string to an optional color input\n            this.setPreviewElementBg(null);\n            this.setValueElementValue('');\n            return true;\n          }\n\n          var color = jsc.parseColorString(str);\n\n          if (!color) {\n            return false; // could not parse\n          }\n\n          if (this.format.toLowerCase() === 'any') {\n            this._currentFormat = color.format; // adapt format\n\n            if (this.getFormat() !== 'rgba') {\n              color.rgba[3] = 1.0; // when switching to a format that doesn't support alpha, set full opacity\n            }\n\n            this.redraw(); // to show/hide the alpha slider according to current format\n          }\n\n          this.fromRGBA(color.rgba[0], color.rgba[1], color.rgba[2], color.rgba[3], flags);\n          return true;\n        };\n\n        this.toString = function (format) {\n          if (format === undefined) {\n            format = this.getFormat(); // format not specified -> use the current format\n          }\n\n          switch (format.toLowerCase()) {\n            case 'hex':\n              return this.toHEXString();\n              break;\n\n            case 'rgb':\n              return this.toRGBString();\n              break;\n\n            case 'rgba':\n              return this.toRGBAString();\n              break;\n          }\n\n          return false;\n        };\n\n        this.toHEXString = function () {\n          return '#' + (('0' + Math.round(this.channels.r).toString(16)).substr(-2) + ('0' + Math.round(this.channels.g).toString(16)).substr(-2) + ('0' + Math.round(this.channels.b).toString(16)).substr(-2)).toUpperCase();\n        };\n\n        this.toRGBString = function () {\n          return 'rgb(' + Math.round(this.channels.r) + ',' + Math.round(this.channels.g) + ',' + Math.round(this.channels.b) + ')';\n        };\n\n        this.toRGBAString = function () {\n          return 'rgba(' + Math.round(this.channels.r) + ',' + Math.round(this.channels.g) + ',' + Math.round(this.channels.b) + ',' + Math.round(this.channels.a * 100) / 100 + ')';\n        };\n\n        this.toGrayscale = function () {\n          return 0.213 * this.channels.r + 0.715 * this.channels.g + 0.072 * this.channels.b;\n        };\n\n        this.toCanvas = function () {\n          return jsc.genColorPreviewCanvas(this.toRGBAString()).canvas;\n        };\n\n        this.toDataURL = function () {\n          return this.toCanvas().toDataURL();\n        };\n\n        this.toBackground = function () {\n          return jsc.pub.background(this.toRGBAString());\n        };\n\n        this.isLight = function () {\n          return this.toGrayscale() > 255 / 2;\n        };\n\n        this.hide = function () {\n          if (isPickerOwner()) {\n            detachPicker();\n          }\n        };\n\n        this.show = function () {\n          drawPicker();\n        };\n\n        this.redraw = function () {\n          if (isPickerOwner()) {\n            drawPicker();\n          }\n        };\n\n        this.getFormat = function () {\n          return this._currentFormat;\n        };\n\n        this.hasAlphaChannel = function () {\n          if (this.alphaChannel === 'auto') {\n            return this.format.toLowerCase() === 'any' || // format can change on the fly (e.g. from hex to rgba), so let's consider the alpha channel enabled\n            this.getFormat() === 'rgba' || // the current format supports alpha channel\n            this.alpha !== undefined || // initial alpha value is set, so we're working with alpha channel\n            this.alphaElement !== undefined // the alpha value is redirected, so we're working with alpha channel\n            ;\n          }\n\n          return this.alphaChannel; // the alpha channel is explicitly set\n        };\n\n        this.processValueInput = function (str) {\n          if (!this.fromString(str)) {\n            // could not parse the color value - let's just expose the current color\n            this.exposeColor();\n          }\n        };\n\n        this.processAlphaInput = function (str) {\n          if (!this.fromHSVA(null, null, null, parseFloat(str))) {\n            // could not parse the alpha value - let's just expose the current color\n            this.exposeColor();\n          }\n        };\n\n        this.exposeColor = function (flags) {\n          if (!(flags & jsc.flags.leaveValue) && this.valueElement) {\n            var value = this.toString();\n\n            if (this.getFormat() === 'hex') {\n              if (!this.uppercase) {\n                value = value.toLowerCase();\n              }\n\n              if (!this.hash) {\n                value = value.replace(/^#/, '');\n              }\n            }\n\n            this.setValueElementValue(value);\n          }\n\n          if (!(flags & jsc.flags.leaveAlpha) && this.alphaElement) {\n            var value = Math.round(this.channels.a * 100) / 100;\n            this.setAlphaElementValue(value);\n          }\n\n          if (!(flags & jsc.flags.leavePreview) && this.previewElement) {\n            var previewPos = null; // 'left' | 'right' (null -> fill the entire element)\n\n            if (jsc.isTextInput(this.previewElement) || // text input\n            jsc.isButton(this.previewElement) && !jsc.isButtonEmpty(this.previewElement) // button with text\n            ) {\n                previewPos = this.previewPosition;\n              }\n\n            this.setPreviewElementBg(this.toRGBAString());\n          }\n\n          if (isPickerOwner()) {\n            redrawPad();\n            redrawSld();\n            redrawASld();\n          }\n        };\n\n        this.setPreviewElementBg = function (color) {\n          if (!this.previewElement) {\n            return;\n          }\n\n          var position = null; // color preview position:  null | 'left' | 'right'\n\n          var width = null; // color preview width:  px | null = fill the entire element\n\n          if (jsc.isTextInput(this.previewElement) || // text input\n          jsc.isButton(this.previewElement) && !jsc.isButtonEmpty(this.previewElement) // button with text\n          ) {\n              position = this.previewPosition;\n              width = this.previewSize;\n            }\n\n          var backgrounds = [];\n\n          if (!color) {\n            // there is no color preview to display -> let's remove any previous background image\n            backgrounds.push({\n              image: 'none',\n              position: 'left top',\n              size: 'auto',\n              repeat: 'no-repeat',\n              origin: 'padding-box'\n            });\n          } else {\n            // CSS gradient for background color preview\n            backgrounds.push({\n              image: jsc.genColorPreviewGradient(color, position, width ? width - jsc.pub.previewSeparator.length : null),\n              position: 'left top',\n              size: 'auto',\n              repeat: position ? 'repeat-y' : 'repeat',\n              origin: 'padding-box'\n            }); // data URL of generated PNG image with a gray transparency chessboard\n\n            var preview = jsc.genColorPreviewCanvas('rgba(0,0,0,0)', position ? {\n              'left': 'right',\n              'right': 'left'\n            }[position] : null, width, true);\n            backgrounds.push({\n              image: 'url(\\'' + preview.canvas.toDataURL() + '\\')',\n              position: (position || 'left') + ' top',\n              size: preview.width + 'px ' + preview.height + 'px',\n              repeat: position ? 'repeat-y' : 'repeat',\n              origin: 'padding-box'\n            });\n          }\n\n          var bg = {\n            image: [],\n            position: [],\n            size: [],\n            repeat: [],\n            origin: []\n          };\n\n          for (var i = 0; i < backgrounds.length; i += 1) {\n            bg.image.push(backgrounds[i].image);\n            bg.position.push(backgrounds[i].position);\n            bg.size.push(backgrounds[i].size);\n            bg.repeat.push(backgrounds[i].repeat);\n            bg.origin.push(backgrounds[i].origin);\n          } // set previewElement's background-images\n\n\n          var sty = {\n            'background-image': bg.image.join(', '),\n            'background-position': bg.position.join(', '),\n            'background-size': bg.size.join(', '),\n            'background-repeat': bg.repeat.join(', '),\n            'background-origin': bg.origin.join(', ')\n          };\n          jsc.setStyle(this.previewElement, sty, this.forceStyle); // set/restore previewElement's padding\n\n          var padding = {\n            left: null,\n            right: null\n          };\n\n          if (position) {\n            padding[position] = this.previewSize + this.previewPadding + 'px';\n          }\n\n          var sty = {\n            'padding-left': padding.left,\n            'padding-right': padding.right\n          };\n          jsc.setStyle(this.previewElement, sty, this.forceStyle, true);\n        };\n\n        this.setValueElementValue = function (str) {\n          if (this.valueElement) {\n            if (jsc.nodeName(this.valueElement) === 'input') {\n              this.valueElement.value = str;\n            } else {\n              this.valueElement.innerHTML = str;\n            }\n          }\n        };\n\n        this.setAlphaElementValue = function (str) {\n          if (this.alphaElement) {\n            if (jsc.nodeName(this.alphaElement) === 'input') {\n              this.alphaElement.value = str;\n            } else {\n              this.alphaElement.innerHTML = str;\n            }\n          }\n        };\n\n        this._processParentElementsInDOM = function () {\n          if (this._linkedElementsProcessed) {\n            return;\n          }\n\n          this._linkedElementsProcessed = true;\n          var elm = this.targetElement;\n\n          do {\n            // If the target element or one of its parent nodes has fixed position,\n            // then use fixed positioning instead\n            var compStyle = jsc.getCompStyle(elm);\n\n            if (compStyle.position && compStyle.position.toLowerCase() === 'fixed') {\n              this.fixed = true;\n            }\n\n            if (elm !== this.targetElement) {\n              // Ensure to attach onParentScroll only once to each parent element\n              // (multiple targetElements can share the same parent nodes)\n              //\n              // Note: It's not just offsetParents that can be scrollable,\n              // that's why we loop through all parent nodes\n              if (!jsc.getData(elm, 'hasScrollListener')) {\n                elm.addEventListener('scroll', jsc.onParentScroll, false);\n                jsc.setData(elm, 'hasScrollListener', true);\n              }\n            }\n          } while ((elm = elm.parentNode) && jsc.nodeName(elm) !== 'body');\n        };\n\n        this.tryHide = function () {\n          if (this.hideOnLeave) {\n            this.hide();\n          }\n        };\n\n        function setOption(option, value) {\n          if (typeof option !== 'string') {\n            throw new Error('Invalid value for option name: ' + option);\n          } // enum option\n\n\n          if (jsc.enumOpts.hasOwnProperty(option)) {\n            if (typeof value === 'string') {\n              // enum string values are case insensitive\n              value = value.toLowerCase();\n            }\n\n            if (jsc.enumOpts[option].indexOf(value) === -1) {\n              throw new Error('Option \\'' + option + '\\' has invalid value: ' + value);\n            }\n          } // deprecated option\n\n\n          if (jsc.deprecatedOpts.hasOwnProperty(option)) {\n            var oldOpt = option;\n            var newOpt = jsc.deprecatedOpts[option];\n\n            if (newOpt) {\n              // if we have a new name for this option, let's log a warning and use the new name\n              console.warn('Option \\'%s\\' is DEPRECATED, using \\'%s\\' instead.' + jsc.docsRef, oldOpt, newOpt);\n              option = newOpt;\n            } else {\n              // new name not available for the option\n              throw new Error('Option \\'' + option + '\\' is DEPRECATED');\n            }\n          }\n\n          if (!(option in THIS)) {\n            throw new Error('Unrecognized configuration option: ' + option);\n          }\n\n          THIS[option] = value;\n          return true;\n        }\n\n        function getOption(option) {\n          // deprecated option\n          if (jsc.deprecatedOpts.hasOwnProperty(option)) {\n            var oldOpt = option;\n            var newOpt = jsc.deprecatedOpts[option];\n\n            if (newOpt) {\n              // if we have a new name for this option, let's log a warning and use the new name\n              console.warn('Option \\'%s\\' is DEPRECATED, using \\'%s\\' instead.' + jsc.docsRef, oldOpt, newOpt);\n              option = newOpt;\n            } else {\n              // new name not available for the option\n              throw new Error('Option \\'' + option + '\\' is DEPRECATED');\n            }\n          }\n\n          if (!(option in THIS)) {\n            throw new Error('Unrecognized configuration option: ' + option);\n          }\n\n          return THIS[option];\n        }\n\n        function detachPicker() {\n          jsc.removeClass(THIS.targetElement, jsc.pub.activeClassName);\n          jsc.picker.wrap.parentNode.removeChild(jsc.picker.wrap);\n          delete jsc.picker.owner;\n        }\n\n        function drawPicker() {\n          // At this point, when drawing the picker, we know what the parent elements are\n          // and we can do all related DOM operations, such as registering events on them\n          // or checking their positioning\n          THIS._processParentElementsInDOM();\n\n          if (!jsc.picker) {\n            jsc.picker = {\n              owner: null,\n              // owner picker instance\n              wrap: jsc.createEl('div'),\n              box: jsc.createEl('div'),\n              boxS: jsc.createEl('div'),\n              // shadow area\n              boxB: jsc.createEl('div'),\n              // border\n              pad: jsc.createEl('div'),\n              padB: jsc.createEl('div'),\n              // border\n              padM: jsc.createEl('div'),\n              // mouse/touch area\n              padPal: jsc.createPalette(),\n              cross: jsc.createEl('div'),\n              crossBY: jsc.createEl('div'),\n              // border Y\n              crossBX: jsc.createEl('div'),\n              // border X\n              crossLY: jsc.createEl('div'),\n              // line Y\n              crossLX: jsc.createEl('div'),\n              // line X\n              sld: jsc.createEl('div'),\n              // slider\n              sldB: jsc.createEl('div'),\n              // border\n              sldM: jsc.createEl('div'),\n              // mouse/touch area\n              sldGrad: jsc.createSliderGradient(),\n              sldPtrS: jsc.createEl('div'),\n              // slider pointer spacer\n              sldPtrIB: jsc.createEl('div'),\n              // slider pointer inner border\n              sldPtrMB: jsc.createEl('div'),\n              // slider pointer middle border\n              sldPtrOB: jsc.createEl('div'),\n              // slider pointer outer border\n              asld: jsc.createEl('div'),\n              // alpha slider\n              asldB: jsc.createEl('div'),\n              // border\n              asldM: jsc.createEl('div'),\n              // mouse/touch area\n              asldGrad: jsc.createASliderGradient(),\n              asldPtrS: jsc.createEl('div'),\n              // slider pointer spacer\n              asldPtrIB: jsc.createEl('div'),\n              // slider pointer inner border\n              asldPtrMB: jsc.createEl('div'),\n              // slider pointer middle border\n              asldPtrOB: jsc.createEl('div'),\n              // slider pointer outer border\n              btn: jsc.createEl('div'),\n              btnT: jsc.createEl('span') // text\n\n            };\n            jsc.picker.pad.appendChild(jsc.picker.padPal.elm);\n            jsc.picker.padB.appendChild(jsc.picker.pad);\n            jsc.picker.cross.appendChild(jsc.picker.crossBY);\n            jsc.picker.cross.appendChild(jsc.picker.crossBX);\n            jsc.picker.cross.appendChild(jsc.picker.crossLY);\n            jsc.picker.cross.appendChild(jsc.picker.crossLX);\n            jsc.picker.padB.appendChild(jsc.picker.cross);\n            jsc.picker.box.appendChild(jsc.picker.padB);\n            jsc.picker.box.appendChild(jsc.picker.padM);\n            jsc.picker.sld.appendChild(jsc.picker.sldGrad.elm);\n            jsc.picker.sldB.appendChild(jsc.picker.sld);\n            jsc.picker.sldB.appendChild(jsc.picker.sldPtrOB);\n            jsc.picker.sldPtrOB.appendChild(jsc.picker.sldPtrMB);\n            jsc.picker.sldPtrMB.appendChild(jsc.picker.sldPtrIB);\n            jsc.picker.sldPtrIB.appendChild(jsc.picker.sldPtrS);\n            jsc.picker.box.appendChild(jsc.picker.sldB);\n            jsc.picker.box.appendChild(jsc.picker.sldM);\n            jsc.picker.asld.appendChild(jsc.picker.asldGrad.elm);\n            jsc.picker.asldB.appendChild(jsc.picker.asld);\n            jsc.picker.asldB.appendChild(jsc.picker.asldPtrOB);\n            jsc.picker.asldPtrOB.appendChild(jsc.picker.asldPtrMB);\n            jsc.picker.asldPtrMB.appendChild(jsc.picker.asldPtrIB);\n            jsc.picker.asldPtrIB.appendChild(jsc.picker.asldPtrS);\n            jsc.picker.box.appendChild(jsc.picker.asldB);\n            jsc.picker.box.appendChild(jsc.picker.asldM);\n            jsc.picker.btn.appendChild(jsc.picker.btnT);\n            jsc.picker.box.appendChild(jsc.picker.btn);\n            jsc.picker.boxB.appendChild(jsc.picker.box);\n            jsc.picker.wrap.appendChild(jsc.picker.boxS);\n            jsc.picker.wrap.appendChild(jsc.picker.boxB);\n            jsc.picker.wrap.addEventListener('touchstart', jsc.onPickerTouchStart, jsc.isPassiveEventSupported ? {\n              passive: false\n            } : false);\n          }\n\n          var p = jsc.picker;\n          var displaySlider = !!jsc.getSliderChannel(THIS);\n          var displayAlphaSlider = THIS.hasAlphaChannel();\n          var dims = jsc.getPickerDims(THIS);\n          var crossOuterSize = 2 * THIS.pointerBorderWidth + THIS.pointerThickness + 2 * THIS.crossSize;\n          var controlPadding = jsc.getControlPadding(THIS);\n          var borderRadius = Math.min(THIS.borderRadius, Math.round(THIS.padding * Math.PI)); // px\n\n          var padCursor = 'crosshair'; // wrap\n\n          p.wrap.className = 'jscolor-picker-wrap';\n          p.wrap.style.clear = 'both';\n          p.wrap.style.width = dims[0] + 2 * THIS.borderWidth + 'px';\n          p.wrap.style.height = dims[1] + 2 * THIS.borderWidth + 'px';\n          p.wrap.style.zIndex = THIS.zIndex; // picker\n\n          p.box.className = 'jscolor-picker';\n          p.box.style.width = dims[0] + 'px';\n          p.box.style.height = dims[1] + 'px';\n          p.box.style.position = 'relative'; // picker shadow\n\n          p.boxS.className = 'jscolor-picker-shadow';\n          p.boxS.style.position = 'absolute';\n          p.boxS.style.left = '0';\n          p.boxS.style.top = '0';\n          p.boxS.style.width = '100%';\n          p.boxS.style.height = '100%';\n          jsc.setBorderRadius(p.boxS, borderRadius + 'px'); // picker border\n\n          p.boxB.className = 'jscolor-picker-border';\n          p.boxB.style.position = 'relative';\n          p.boxB.style.border = THIS.borderWidth + 'px solid';\n          p.boxB.style.borderColor = THIS.borderColor;\n          p.boxB.style.background = THIS.backgroundColor;\n          jsc.setBorderRadius(p.boxB, borderRadius + 'px'); // IE hack:\n          // If the element is transparent, IE will trigger the event on the elements under it,\n          // e.g. on Canvas or on elements with border\n\n          p.padM.style.background = 'rgba(255,0,0,.2)';\n          p.sldM.style.background = 'rgba(0,255,0,.2)';\n          p.asldM.style.background = 'rgba(0,0,255,.2)';\n          p.padM.style.opacity = p.sldM.style.opacity = p.asldM.style.opacity = '0'; // pad\n\n          p.pad.style.position = 'relative';\n          p.pad.style.width = THIS.width + 'px';\n          p.pad.style.height = THIS.height + 'px'; // pad palettes (HSV and HVS)\n\n          p.padPal.draw(THIS.width, THIS.height, jsc.getPadYChannel(THIS)); // pad border\n\n          p.padB.style.position = 'absolute';\n          p.padB.style.left = THIS.padding + 'px';\n          p.padB.style.top = THIS.padding + 'px';\n          p.padB.style.border = THIS.controlBorderWidth + 'px solid';\n          p.padB.style.borderColor = THIS.controlBorderColor; // pad mouse area\n\n          p.padM.style.position = 'absolute';\n          p.padM.style.left = 0 + 'px';\n          p.padM.style.top = 0 + 'px';\n          p.padM.style.width = THIS.padding + 2 * THIS.controlBorderWidth + THIS.width + controlPadding + 'px';\n          p.padM.style.height = 2 * THIS.controlBorderWidth + 2 * THIS.padding + THIS.height + 'px';\n          p.padM.style.cursor = padCursor;\n          jsc.setData(p.padM, {\n            instance: THIS,\n            control: 'pad'\n          }); // pad cross\n\n          p.cross.style.position = 'absolute';\n          p.cross.style.left = p.cross.style.top = '0';\n          p.cross.style.width = p.cross.style.height = crossOuterSize + 'px'; // pad cross border Y and X\n\n          p.crossBY.style.position = p.crossBX.style.position = 'absolute';\n          p.crossBY.style.background = p.crossBX.style.background = THIS.pointerBorderColor;\n          p.crossBY.style.width = p.crossBX.style.height = 2 * THIS.pointerBorderWidth + THIS.pointerThickness + 'px';\n          p.crossBY.style.height = p.crossBX.style.width = crossOuterSize + 'px';\n          p.crossBY.style.left = p.crossBX.style.top = Math.floor(crossOuterSize / 2) - Math.floor(THIS.pointerThickness / 2) - THIS.pointerBorderWidth + 'px';\n          p.crossBY.style.top = p.crossBX.style.left = '0'; // pad cross line Y and X\n\n          p.crossLY.style.position = p.crossLX.style.position = 'absolute';\n          p.crossLY.style.background = p.crossLX.style.background = THIS.pointerColor;\n          p.crossLY.style.height = p.crossLX.style.width = crossOuterSize - 2 * THIS.pointerBorderWidth + 'px';\n          p.crossLY.style.width = p.crossLX.style.height = THIS.pointerThickness + 'px';\n          p.crossLY.style.left = p.crossLX.style.top = Math.floor(crossOuterSize / 2) - Math.floor(THIS.pointerThickness / 2) + 'px';\n          p.crossLY.style.top = p.crossLX.style.left = THIS.pointerBorderWidth + 'px'; // slider\n\n          p.sld.style.overflow = 'hidden';\n          p.sld.style.width = THIS.sliderSize + 'px';\n          p.sld.style.height = THIS.height + 'px'; // slider gradient\n\n          p.sldGrad.draw(THIS.sliderSize, THIS.height, '#000', '#000'); // slider border\n\n          p.sldB.style.display = displaySlider ? 'block' : 'none';\n          p.sldB.style.position = 'absolute';\n          p.sldB.style.left = THIS.padding + THIS.width + 2 * THIS.controlBorderWidth + 2 * controlPadding + 'px';\n          p.sldB.style.top = THIS.padding + 'px';\n          p.sldB.style.border = THIS.controlBorderWidth + 'px solid';\n          p.sldB.style.borderColor = THIS.controlBorderColor; // slider mouse area\n\n          p.sldM.style.display = displaySlider ? 'block' : 'none';\n          p.sldM.style.position = 'absolute';\n          p.sldM.style.left = THIS.padding + THIS.width + 2 * THIS.controlBorderWidth + controlPadding + 'px';\n          p.sldM.style.top = 0 + 'px';\n          p.sldM.style.width = THIS.sliderSize + 2 * controlPadding + 2 * THIS.controlBorderWidth + (displayAlphaSlider ? 0 : Math.max(0, THIS.padding - controlPadding)) // remaining padding to the right edge\n          + 'px';\n          p.sldM.style.height = 2 * THIS.controlBorderWidth + 2 * THIS.padding + THIS.height + 'px';\n          p.sldM.style.cursor = 'default';\n          jsc.setData(p.sldM, {\n            instance: THIS,\n            control: 'sld'\n          }); // slider pointer inner and outer border\n\n          p.sldPtrIB.style.border = p.sldPtrOB.style.border = THIS.pointerBorderWidth + 'px solid ' + THIS.pointerBorderColor; // slider pointer outer border\n\n          p.sldPtrOB.style.position = 'absolute';\n          p.sldPtrOB.style.left = -(2 * THIS.pointerBorderWidth + THIS.pointerThickness) + 'px';\n          p.sldPtrOB.style.top = '0'; // slider pointer middle border\n\n          p.sldPtrMB.style.border = THIS.pointerThickness + 'px solid ' + THIS.pointerColor; // slider pointer spacer\n\n          p.sldPtrS.style.width = THIS.sliderSize + 'px';\n          p.sldPtrS.style.height = jsc.pub.sliderInnerSpace + 'px'; // alpha slider\n\n          p.asld.style.overflow = 'hidden';\n          p.asld.style.width = THIS.sliderSize + 'px';\n          p.asld.style.height = THIS.height + 'px'; // alpha slider gradient\n\n          p.asldGrad.draw(THIS.sliderSize, THIS.height, '#000'); // alpha slider border\n\n          p.asldB.style.display = displayAlphaSlider ? 'block' : 'none';\n          p.asldB.style.position = 'absolute';\n          p.asldB.style.left = THIS.padding + THIS.width + 2 * THIS.controlBorderWidth + controlPadding + (displaySlider ? THIS.sliderSize + 3 * controlPadding + 2 * THIS.controlBorderWidth : 0) + 'px';\n          p.asldB.style.top = THIS.padding + 'px';\n          p.asldB.style.border = THIS.controlBorderWidth + 'px solid';\n          p.asldB.style.borderColor = THIS.controlBorderColor; // alpha slider mouse area\n\n          p.asldM.style.display = displayAlphaSlider ? 'block' : 'none';\n          p.asldM.style.position = 'absolute';\n          p.asldM.style.left = THIS.padding + THIS.width + 2 * THIS.controlBorderWidth + controlPadding + (displaySlider ? THIS.sliderSize + 2 * controlPadding + 2 * THIS.controlBorderWidth : 0) + 'px';\n          p.asldM.style.top = 0 + 'px';\n          p.asldM.style.width = THIS.sliderSize + 2 * controlPadding + 2 * THIS.controlBorderWidth + Math.max(0, THIS.padding - controlPadding) // remaining padding to the right edge\n          + 'px';\n          p.asldM.style.height = 2 * THIS.controlBorderWidth + 2 * THIS.padding + THIS.height + 'px';\n          p.asldM.style.cursor = 'default';\n          jsc.setData(p.asldM, {\n            instance: THIS,\n            control: 'asld'\n          }); // alpha slider pointer inner and outer border\n\n          p.asldPtrIB.style.border = p.asldPtrOB.style.border = THIS.pointerBorderWidth + 'px solid ' + THIS.pointerBorderColor; // alpha slider pointer outer border\n\n          p.asldPtrOB.style.position = 'absolute';\n          p.asldPtrOB.style.left = -(2 * THIS.pointerBorderWidth + THIS.pointerThickness) + 'px';\n          p.asldPtrOB.style.top = '0'; // alpha slider pointer middle border\n\n          p.asldPtrMB.style.border = THIS.pointerThickness + 'px solid ' + THIS.pointerColor; // alpha slider pointer spacer\n\n          p.asldPtrS.style.width = THIS.sliderSize + 'px';\n          p.asldPtrS.style.height = jsc.pub.sliderInnerSpace + 'px'; // the Close button\n\n          function setBtnBorder() {\n            var insetColors = THIS.controlBorderColor.split(/\\s+/);\n            var outsetColor = insetColors.length < 2 ? insetColors[0] : insetColors[1] + ' ' + insetColors[0] + ' ' + insetColors[0] + ' ' + insetColors[1];\n            p.btn.style.borderColor = outsetColor;\n          }\n\n          var btnPadding = 15; // px\n\n          p.btn.className = 'jscolor-btn-close';\n          p.btn.style.display = THIS.closeButton ? 'block' : 'none';\n          p.btn.style.position = 'absolute';\n          p.btn.style.left = THIS.padding + 'px';\n          p.btn.style.bottom = THIS.padding + 'px';\n          p.btn.style.padding = '0 ' + btnPadding + 'px';\n          p.btn.style.maxWidth = dims[0] - 2 * THIS.padding - 2 * THIS.controlBorderWidth - 2 * btnPadding + 'px';\n          p.btn.style.overflow = 'hidden';\n          p.btn.style.height = THIS.buttonHeight + 'px';\n          p.btn.style.whiteSpace = 'nowrap';\n          p.btn.style.border = THIS.controlBorderWidth + 'px solid';\n          setBtnBorder();\n          p.btn.style.color = THIS.buttonColor;\n          p.btn.style.font = '12px sans-serif';\n          p.btn.style.textAlign = 'center';\n          p.btn.style.cursor = 'pointer';\n\n          p.btn.onmousedown = function () {\n            THIS.hide();\n          };\n\n          p.btnT.style.lineHeight = THIS.buttonHeight + 'px';\n          p.btnT.innerHTML = '';\n          p.btnT.appendChild(document.createTextNode(THIS.closeText)); // reposition the pointers\n\n          redrawPad();\n          redrawSld();\n          redrawASld(); // If we are changing the owner without first closing the picker,\n          // make sure to first deal with the old owner\n\n          if (jsc.picker.owner && jsc.picker.owner !== THIS) {\n            jsc.removeClass(jsc.picker.owner.targetElement, jsc.pub.activeClassName);\n          } // Set a new picker owner\n\n\n          jsc.picker.owner = THIS; // The redrawPosition() method needs picker.owner to be set, that's why we call it here,\n          // after setting the owner\n\n          if (THIS.container === document.body) {\n            jsc.redrawPosition();\n          } else {\n            jsc._drawPosition(THIS, 0, 0, 'relative', false);\n          }\n\n          if (p.wrap.parentNode !== THIS.container) {\n            THIS.container.appendChild(p.wrap);\n          }\n\n          jsc.addClass(THIS.targetElement, jsc.pub.activeClassName);\n        }\n\n        function redrawPad() {\n          // redraw the pad pointer\n          var yChannel = jsc.getPadYChannel(THIS);\n          var x = Math.round(THIS.channels.h / 360 * (THIS.width - 1));\n          var y = Math.round((1 - THIS.channels[yChannel] / 100) * (THIS.height - 1));\n          var crossOuterSize = 2 * THIS.pointerBorderWidth + THIS.pointerThickness + 2 * THIS.crossSize;\n          var ofs = -Math.floor(crossOuterSize / 2);\n          jsc.picker.cross.style.left = x + ofs + 'px';\n          jsc.picker.cross.style.top = y + ofs + 'px'; // redraw the slider\n\n          switch (jsc.getSliderChannel(THIS)) {\n            case 's':\n              var rgb1 = jsc.HSV_RGB(THIS.channels.h, 100, THIS.channels.v);\n              var rgb2 = jsc.HSV_RGB(THIS.channels.h, 0, THIS.channels.v);\n              var color1 = 'rgb(' + Math.round(rgb1[0]) + ',' + Math.round(rgb1[1]) + ',' + Math.round(rgb1[2]) + ')';\n              var color2 = 'rgb(' + Math.round(rgb2[0]) + ',' + Math.round(rgb2[1]) + ',' + Math.round(rgb2[2]) + ')';\n              jsc.picker.sldGrad.draw(THIS.sliderSize, THIS.height, color1, color2);\n              break;\n\n            case 'v':\n              var rgb = jsc.HSV_RGB(THIS.channels.h, THIS.channels.s, 100);\n              var color1 = 'rgb(' + Math.round(rgb[0]) + ',' + Math.round(rgb[1]) + ',' + Math.round(rgb[2]) + ')';\n              var color2 = '#000';\n              jsc.picker.sldGrad.draw(THIS.sliderSize, THIS.height, color1, color2);\n              break;\n          } // redraw the alpha slider\n\n\n          jsc.picker.asldGrad.draw(THIS.sliderSize, THIS.height, THIS.toHEXString());\n        }\n\n        function redrawSld() {\n          var sldChannel = jsc.getSliderChannel(THIS);\n\n          if (sldChannel) {\n            // redraw the slider pointer\n            var y = Math.round((1 - THIS.channels[sldChannel] / 100) * (THIS.height - 1));\n            jsc.picker.sldPtrOB.style.top = y - (2 * THIS.pointerBorderWidth + THIS.pointerThickness) - Math.floor(jsc.pub.sliderInnerSpace / 2) + 'px';\n          } // redraw the alpha slider\n\n\n          jsc.picker.asldGrad.draw(THIS.sliderSize, THIS.height, THIS.toHEXString());\n        }\n\n        function redrawASld() {\n          var y = Math.round((1 - THIS.channels.a) * (THIS.height - 1));\n          jsc.picker.asldPtrOB.style.top = y - (2 * THIS.pointerBorderWidth + THIS.pointerThickness) - Math.floor(jsc.pub.sliderInnerSpace / 2) + 'px';\n        }\n\n        function isPickerOwner() {\n          return jsc.picker && jsc.picker.owner === THIS;\n        }\n\n        function onValueKeyDown(ev) {\n          if (jsc.eventKey(ev) === 'Enter') {\n            if (THIS.valueElement) {\n              THIS.processValueInput(THIS.valueElement.value);\n            }\n\n            THIS.tryHide();\n          }\n        }\n\n        function onAlphaKeyDown(ev) {\n          if (jsc.eventKey(ev) === 'Enter') {\n            if (THIS.alphaElement) {\n              THIS.processAlphaInput(THIS.alphaElement.value);\n            }\n\n            THIS.tryHide();\n          }\n        }\n\n        function onValueChange(ev) {\n          if (jsc.getData(ev, 'internal')) {\n            return; // skip if the event was internally triggered by jscolor\n          }\n\n          var oldVal = THIS.valueElement.value;\n          THIS.processValueInput(THIS.valueElement.value); // this might change the value\n\n          jsc.triggerCallback(THIS, 'onChange');\n\n          if (THIS.valueElement.value !== oldVal) {\n            // value was additionally changed -> let's trigger the change event again, even though it was natively dispatched\n            jsc.triggerInputEvent(THIS.valueElement, 'change', true, true);\n          }\n        }\n\n        function onAlphaChange(ev) {\n          if (jsc.getData(ev, 'internal')) {\n            return; // skip if the event was internally triggered by jscolor\n          }\n\n          var oldVal = THIS.alphaElement.value;\n          THIS.processAlphaInput(THIS.alphaElement.value); // this might change the value\n\n          jsc.triggerCallback(THIS, 'onChange'); // triggering valueElement's onChange (because changing alpha changes the entire color, e.g. with rgba format)\n\n          jsc.triggerInputEvent(THIS.valueElement, 'change', true, true);\n\n          if (THIS.alphaElement.value !== oldVal) {\n            // value was additionally changed -> let's trigger the change event again, even though it was natively dispatched\n            jsc.triggerInputEvent(THIS.alphaElement, 'change', true, true);\n          }\n        }\n\n        function onValueInput(ev) {\n          if (jsc.getData(ev, 'internal')) {\n            return; // skip if the event was internally triggered by jscolor\n          }\n\n          if (THIS.valueElement) {\n            THIS.fromString(THIS.valueElement.value, jsc.flags.leaveValue);\n          }\n\n          jsc.triggerCallback(THIS, 'onInput'); // triggering valueElement's onInput\n          // (not needed, it was dispatched normally by the browser)\n        }\n\n        function onAlphaInput(ev) {\n          if (jsc.getData(ev, 'internal')) {\n            return; // skip if the event was internally triggered by jscolor\n          }\n\n          if (THIS.alphaElement) {\n            THIS.fromHSVA(null, null, null, parseFloat(THIS.alphaElement.value), jsc.flags.leaveAlpha);\n          }\n\n          jsc.triggerCallback(THIS, 'onInput'); // triggering valueElement's onInput (because changing alpha changes the entire color, e.g. with rgba format)\n\n          jsc.triggerInputEvent(THIS.valueElement, 'input', true, true);\n        } //\n        // Install the color picker on chosen element(s)\n        //\n        // Determine picker's container element\n\n\n        if (this.container === undefined) {\n          this.container = document.body; // default container is BODY element\n        } else {\n          // explicitly set to custom element\n          this.container = jsc.node(this.container);\n        }\n\n        if (!this.container) {\n          throw new Error('Cannot instantiate color picker without a container element');\n        } // Fetch the target element\n\n\n        this.targetElement = jsc.node(targetElement);\n\n        if (!this.targetElement) {\n          // temporarily customized error message to help with migrating from versions prior to 2.2\n          if (typeof targetElement === 'string' && /^[a-zA-Z][\\w:.-]*$/.test(targetElement)) {\n            // targetElement looks like valid ID\n            var possiblyId = targetElement;\n            throw new Error('If \\'' + possiblyId + '\\' is supposed to be an ID, please use \\'#' + possiblyId + '\\' or any valid CSS selector.');\n          }\n\n          throw new Error('Cannot instantiate color picker without a target element');\n        }\n\n        if (this.targetElement.jscolor && this.targetElement.jscolor instanceof jsc.pub) {\n          throw new Error('Color picker already installed on this element');\n        } // link this instance with the target element\n\n\n        this.targetElement.jscolor = this;\n        jsc.addClass(this.targetElement, jsc.pub.className); // register this instance\n\n        jsc.instances.push(this); // if target is BUTTON\n\n        if (jsc.isButton(this.targetElement)) {\n          if (this.targetElement.type.toLowerCase() !== 'button') {\n            // on buttons, always force type to be 'button', e.g. in situations the target <button> has no type\n            // and thus defaults to 'submit' and would submit the form when clicked\n            this.targetElement.type = 'button';\n          }\n\n          if (jsc.isButtonEmpty(this.targetElement)) {\n            // empty button\n            // it is important to clear element's contents first.\n            // if we're re-instantiating color pickers on DOM that has been modified by changing page's innerHTML,\n            // we would keep adding more non-breaking spaces to element's content (because element's contents survive\n            // innerHTML changes, but picker instances don't)\n            jsc.removeChildren(this.targetElement); // let's insert a non-breaking space\n\n            this.targetElement.appendChild(document.createTextNode('\\xa0')); // set min-width = previewSize, if not already greater\n\n            var compStyle = jsc.getCompStyle(this.targetElement);\n            var currMinWidth = parseFloat(compStyle['min-width']) || 0;\n\n            if (currMinWidth < this.previewSize) {\n              jsc.setStyle(this.targetElement, {\n                'min-width': this.previewSize + 'px'\n              }, this.forceStyle);\n            }\n          }\n        } // Determine the value element\n\n\n        if (this.valueElement === undefined) {\n          if (jsc.isTextInput(this.targetElement)) {\n            // for text inputs, default valueElement is targetElement\n            this.valueElement = this.targetElement;\n          } else {// leave it undefined\n          }\n        } else if (this.valueElement === null) {// explicitly set to null\n          // leave it null\n        } else {\n          // explicitly set to custom element\n          this.valueElement = jsc.node(this.valueElement);\n        } // Determine the alpha element\n\n\n        if (this.alphaElement) {\n          this.alphaElement = jsc.node(this.alphaElement);\n        } // Determine the preview element\n\n\n        if (this.previewElement === undefined) {\n          this.previewElement = this.targetElement; // default previewElement is targetElement\n        } else if (this.previewElement === null) {// explicitly set to null\n          // leave it null\n        } else {\n          // explicitly set to custom element\n          this.previewElement = jsc.node(this.previewElement);\n        } // valueElement\n\n\n        if (this.valueElement && jsc.isTextInput(this.valueElement)) {\n          // If the value element has onInput event already set, we need to detach it and attach AFTER our listener.\n          // otherwise the picker instance would still contain the old color when accessed from the onInput handler.\n          var valueElementOrigEvents = {\n            onInput: this.valueElement.oninput\n          };\n          this.valueElement.oninput = null;\n          this.valueElement.addEventListener('keydown', onValueKeyDown, false);\n          this.valueElement.addEventListener('change', onValueChange, false);\n          this.valueElement.addEventListener('input', onValueInput, false); // the original event listener must be attached AFTER our handler (to let it first set picker's color)\n\n          if (valueElementOrigEvents.onInput) {\n            this.valueElement.addEventListener('input', valueElementOrigEvents.onInput, false);\n          }\n\n          this.valueElement.setAttribute('autocomplete', 'off');\n          this.valueElement.setAttribute('autocorrect', 'off');\n          this.valueElement.setAttribute('autocapitalize', 'off');\n          this.valueElement.setAttribute('spellcheck', false);\n        } // alphaElement\n\n\n        if (this.alphaElement && jsc.isTextInput(this.alphaElement)) {\n          this.alphaElement.addEventListener('keydown', onAlphaKeyDown, false);\n          this.alphaElement.addEventListener('change', onAlphaChange, false);\n          this.alphaElement.addEventListener('input', onAlphaInput, false);\n          this.alphaElement.setAttribute('autocomplete', 'off');\n          this.alphaElement.setAttribute('autocorrect', 'off');\n          this.alphaElement.setAttribute('autocapitalize', 'off');\n          this.alphaElement.setAttribute('spellcheck', false);\n        } // determine initial color value\n        //\n\n\n        var initValue = 'FFFFFF';\n\n        if (this.value !== undefined) {\n          initValue = this.value; // get initial color from the 'value' property\n        } else if (this.valueElement && this.valueElement.value !== undefined) {\n          initValue = this.valueElement.value; // get initial color from valueElement's value\n        } // determine initial alpha value\n        //\n\n\n        var initAlpha = undefined;\n\n        if (this.alpha !== undefined) {\n          initAlpha = '' + this.alpha; // get initial alpha value from the 'alpha' property\n        } else if (this.alphaElement && this.alphaElement.value !== undefined) {\n          initAlpha = this.alphaElement.value; // get initial color from alphaElement's value\n        } // determine current format based on the initial color value\n        //\n\n\n        this._currentFormat = null;\n\n        if (['auto', 'any'].indexOf(this.format.toLowerCase()) > -1) {\n          // format is 'auto' or 'any' -> let's auto-detect current format\n          var color = jsc.parseColorString(initValue);\n          this._currentFormat = color ? color.format : 'hex';\n        } else {\n          // format is specified\n          this._currentFormat = this.format.toLowerCase();\n        } // let's parse the initial color value and expose color's preview\n\n\n        this.processValueInput(initValue); // let's also parse and expose the initial alpha value, if any\n        //\n        // Note: If the initial color value contains alpha value in it (e.g. in rgba format),\n        // this will overwrite it. So we should only process alpha input if there was any initial\n        // alpha explicitly set, otherwise we could needlessly lose initial value's alpha\n\n        if (initAlpha !== undefined) {\n          this.processAlphaInput(initAlpha);\n        }\n      }\n    }; //================================\n    // Public properties and methods\n    //================================\n    //\n    // These will be publicly available via jscolor.<name> and JSColor.<name>\n    //\n    // class that will be set to elements having jscolor installed on them\n\n    jsc.pub.className = 'jscolor'; // class that will be set to elements having jscolor active on them\n\n    jsc.pub.activeClassName = 'jscolor-active'; // whether to try to parse the options string by evaluating it using 'new Function()'\n    // in case it could not be parsed with JSON.parse()\n\n    jsc.pub.looseJSON = true; // presets\n\n    jsc.pub.presets = {}; // built-in presets\n\n    jsc.pub.presets['default'] = {}; // baseline for customization\n\n    jsc.pub.presets['light'] = {\n      // default color scheme\n      backgroundColor: 'rgba(255,255,255,1)',\n      controlBorderColor: 'rgba(187,187,187,1)',\n      buttonColor: 'rgba(0,0,0,1)'\n    };\n    jsc.pub.presets['dark'] = {\n      backgroundColor: 'rgba(51,51,51,1)',\n      controlBorderColor: 'rgba(153,153,153,1)',\n      buttonColor: 'rgba(240,240,240,1)'\n    };\n    jsc.pub.presets['small'] = {\n      width: 101,\n      height: 101,\n      padding: 10,\n      sliderSize: 14\n    };\n    jsc.pub.presets['medium'] = {\n      width: 181,\n      height: 101,\n      padding: 12,\n      sliderSize: 16\n    }; // default size\n\n    jsc.pub.presets['large'] = {\n      width: 271,\n      height: 151,\n      padding: 12,\n      sliderSize: 24\n    };\n    jsc.pub.presets['thin'] = {\n      borderWidth: 1,\n      controlBorderWidth: 1,\n      pointerBorderWidth: 1\n    }; // default thickness\n\n    jsc.pub.presets['thick'] = {\n      borderWidth: 2,\n      controlBorderWidth: 2,\n      pointerBorderWidth: 2\n    }; // size of space in the sliders\n\n    jsc.pub.sliderInnerSpace = 3; // px\n    // transparency chessboard\n\n    jsc.pub.chessboardSize = 8; // px\n\n    jsc.pub.chessboardColor1 = '#666666';\n    jsc.pub.chessboardColor2 = '#999999'; // preview separator\n\n    jsc.pub.previewSeparator = ['rgba(255,255,255,.65)', 'rgba(128,128,128,.65)']; // Installs jscolor on current DOM tree\n\n    jsc.pub.install = function (rootNode) {\n      var success = true;\n\n      try {\n        jsc.installBySelector('[data-jscolor]', rootNode);\n      } catch (e) {\n        success = false;\n        console.warn(e);\n      } // for backward compatibility with DEPRECATED installation using class name\n\n\n      if (jsc.pub.lookupClass) {\n        try {\n          jsc.installBySelector('input.' + jsc.pub.lookupClass + ', ' + 'button.' + jsc.pub.lookupClass, rootNode);\n        } catch (e) {}\n      }\n\n      return success;\n    }; // Triggers given input event(s) (e.g. 'input' or 'change') on all color pickers.\n    //\n    // It is possible to specify multiple events separated with a space.\n    // If called before jscolor is initialized, then the events will be triggered after initialization.\n    //\n\n\n    jsc.pub.trigger = function (eventNames) {\n      if (jsc.initialized) {\n        jsc.triggerGlobal(eventNames);\n      } else {\n        jsc.triggerQueue.push(eventNames);\n      }\n    }; // Hides current color picker box\n\n\n    jsc.pub.hide = function () {\n      if (jsc.picker && jsc.picker.owner) {\n        jsc.picker.owner.hide();\n      }\n    }; // Returns a data URL of a gray chessboard image that indicates transparency\n\n\n    jsc.pub.chessboard = function (color) {\n      if (!color) {\n        color = 'rgba(0,0,0,0)';\n      }\n\n      var preview = jsc.genColorPreviewCanvas(color);\n      return preview.canvas.toDataURL();\n    }; // Returns a data URL of a gray chessboard image that indicates transparency\n\n\n    jsc.pub.background = function (color) {\n      var backgrounds = []; // CSS gradient for background color preview\n\n      backgrounds.push(jsc.genColorPreviewGradient(color)); // data URL of generated PNG image with a gray transparency chessboard\n\n      var preview = jsc.genColorPreviewCanvas();\n      backgrounds.push(['url(\\'' + preview.canvas.toDataURL() + '\\')', 'left top', 'repeat'].join(' '));\n      return backgrounds.join(', ');\n    }; //\n    // DEPRECATED properties and methods\n    //\n    // DEPRECATED. Use jscolor.presets.default instead.\n    //\n    // Custom default options for all color pickers, e.g. { hash: true, width: 300 }\n\n\n    jsc.pub.options = {}; // DEPRECATED. Use data-jscolor attribute instead, which installs jscolor on given element.\n    //\n    // By default, we'll search for all elements with class=\"jscolor\" and install a color picker on them.\n    //\n    // You can change what class name will be looked for by setting the property jscolor.lookupClass\n    // anywhere in your HTML document. To completely disable the automatic lookup, set it to null.\n    //\n\n    jsc.pub.lookupClass = 'jscolor'; // DEPRECATED. Use jscolor.install() instead\n    //\n\n    jsc.pub.init = function () {\n      console.warn('jscolor.init() is DEPRECATED. Using jscolor.install() instead.' + jsc.docsRef);\n      return jsc.pub.install();\n    }; // DEPRECATED. Use data-jscolor attribute instead, which installs jscolor on given element.\n    //\n    // Install jscolor on all elements that have the specified class name\n\n\n    jsc.pub.installByClassName = function () {\n      console.error('jscolor.installByClassName() is DEPRECATED. Use data-jscolor=\"\" attribute instead of a class name.' + jsc.docsRef);\n      return false;\n    };\n\n    jsc.register();\n    return jsc.pub;\n  }(); // END window.jscolor\n\n\n  window.JSColor = window.jscolor; // 'JSColor' is an alias to 'jscolor'\n} // endif//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9qc2NvbG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vanMvanNjb2xvci5qcz9jZjY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBqc2NvbG9yIC0gSmF2YVNjcmlwdCBDb2xvciBQaWNrZXJcclxuICpcclxuICogQGxpbmsgICAgaHR0cDovL2pzY29sb3IuY29tXHJcbiAqIEBsaWNlbnNlIEZvciBvcGVuIHNvdXJjZSB1c2U6IEdQTHYzXHJcbiAqICAgICAgICAgIEZvciBjb21tZXJjaWFsIHVzZTogSlNDb2xvciBDb21tZXJjaWFsIExpY2Vuc2VcclxuICogQGF1dGhvciAgSmFuIE9kdmFya28gLSBFYXN0IERlc2lyZVxyXG4gKiBAdmVyc2lvbiAyLjMuM1xyXG4gKlxyXG4gKiBTZWUgdXNhZ2UgZXhhbXBsZXMgYXQgaHR0cDovL2pzY29sb3IuY29tL2V4YW1wbGVzL1xyXG4gKi9cclxuXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5pZiAoIXdpbmRvdy5qc2NvbG9yKSB7XHJcblxyXG53aW5kb3cuanNjb2xvciA9IChmdW5jdGlvbiAoKSB7IC8vIEJFR0lOIHdpbmRvdy5qc2NvbG9yXHJcblxyXG52YXIganNjID0ge1xyXG5cclxuXHJcblx0aW5pdGlhbGl6ZWQgOiBmYWxzZSxcclxuXHJcblx0aW5zdGFuY2VzIDogW10sIC8vIGNyZWF0ZWQgaW5zdGFuY2VzIG9mIGpzY29sb3JcclxuXHJcblx0dHJpZ2dlclF1ZXVlIDogW10sIC8vIGV2ZW50cyB3YWl0aW5nIHRvIGJlIHRyaWdnZXJlZCBhZnRlciBpbml0XHJcblxyXG5cclxuXHRyZWdpc3RlciA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBqc2MuaW5pdCwgZmFsc2UpO1xyXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywganNjLm9uRG9jdW1lbnRNb3VzZURvd24sIGZhbHNlKTtcclxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywganNjLm9uRG9jdW1lbnRLZXlVcCwgZmFsc2UpO1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGpzYy5vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cclxuXHRpbml0IDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKGpzYy5pbml0aWFsaXplZCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0anNjLnB1Yi5pbnN0YWxsKCk7XHJcblx0XHRqc2MuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuXHRcdC8vIHRyaWdnZXIgZXZlbnRzIHdhaXRpbmcgaW4gdGhlIHF1ZXVlXHJcblx0XHR3aGlsZSAoanNjLnRyaWdnZXJRdWV1ZS5sZW5ndGgpIHtcclxuXHRcdFx0dmFyIGV2ID0ganNjLnRyaWdnZXJRdWV1ZS5zaGlmdCgpO1xyXG5cdFx0XHRqc2MudHJpZ2dlckdsb2JhbChldik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdGluc3RhbGxCeVNlbGVjdG9yIDogZnVuY3Rpb24gKHNlbGVjdG9yLCByb290Tm9kZSkge1xyXG5cdFx0cm9vdE5vZGUgPSByb290Tm9kZSA/IGpzYy5ub2RlKHJvb3ROb2RlKSA6IGRvY3VtZW50O1xyXG5cdFx0aWYgKCFyb290Tm9kZSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgcm9vdCBub2RlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGVsbXMgPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuXHJcblx0XHQvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIERFUFJFQ0FURUQgaW5zdGFsbGF0aW9uL2NvbmZpZ3VyYXRpb24gdXNpbmcgY2xhc3NOYW1lXHJcblx0XHR2YXIgbWF0Y2hDbGFzcyA9IG5ldyBSZWdFeHAoJyhefFxcXFxzKSgnICsganNjLnB1Yi5sb29rdXBDbGFzcyArICcpKFxcXFxzKihcXFxce1tefV0qXFxcXH0pfFxcXFxzfCQpJywgJ2knKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsbXMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHJcblx0XHRcdGlmIChlbG1zW2ldLmpzY29sb3IgJiYgZWxtc1tpXS5qc2NvbG9yIGluc3RhbmNlb2YganNjLnB1Yikge1xyXG5cdFx0XHRcdGNvbnRpbnVlOyAvLyBqc2NvbG9yIGFscmVhZHkgaW5zdGFsbGVkIG9uIHRoaXMgZWxlbWVudFxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZWxtc1tpXS50eXBlICE9PSB1bmRlZmluZWQgJiYgZWxtc1tpXS50eXBlLnRvTG93ZXJDYXNlKCkgPT0gJ2NvbG9yJyAmJiBqc2MuaXNDb2xvckF0dHJTdXBwb3J0ZWQpIHtcclxuXHRcdFx0XHRjb250aW51ZTsgLy8gc2tpcHMgaW5wdXRzIG9mIHR5cGUgJ2NvbG9yJyBpZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXJcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGRhdGFPcHRzLCBtO1xyXG5cclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdChkYXRhT3B0cyA9IGpzYy5nZXREYXRhQXR0cihlbG1zW2ldLCAnanNjb2xvcicpKSAhPT0gbnVsbCB8fFxyXG5cdFx0XHRcdChlbG1zW2ldLmNsYXNzTmFtZSAmJiAobSA9IGVsbXNbaV0uY2xhc3NOYW1lLm1hdGNoKG1hdGNoQ2xhc3MpKSkgLy8gaW5zdGFsbGF0aW9uIHVzaW5nIGNsYXNzTmFtZSAoREVQUkVDQVRFRClcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0dmFyIHRhcmdldEVsbSA9IGVsbXNbaV07XHJcblxyXG5cdFx0XHRcdHZhciBvcHRzU3RyID0gJyc7XHJcblx0XHRcdFx0aWYgKGRhdGFPcHRzICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRvcHRzU3RyID0gZGF0YU9wdHM7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAobSkgeyAvLyBpbnN0YWxsYXRpb24gdXNpbmcgY2xhc3NOYW1lIChERVBSRUNBVEVEKVxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YWxsYXRpb24gdXNpbmcgY2xhc3MgbmFtZSBpcyBERVBSRUNBVEVELiBVc2UgZGF0YS1qc2NvbG9yPVwiXCIgYXR0cmlidXRlIGluc3RlYWQuJyArIGpzYy5kb2NzUmVmKTtcclxuXHRcdFx0XHRcdGlmIChtWzRdKSB7XHJcblx0XHRcdFx0XHRcdG9wdHNTdHIgPSBtWzRdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIG9wdHMgPSBudWxsO1xyXG5cdFx0XHRcdGlmIChvcHRzU3RyLnRyaW0oKSkge1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0b3B0cyA9IGpzYy5wYXJzZU9wdGlvbnNTdHIob3B0c1N0cik7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihlICsgJ1xcbicgKyBvcHRzU3RyKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRuZXcganNjLnB1Yih0YXJnZXRFbG0sIG9wdHMpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0cGFyc2VPcHRpb25zU3RyIDogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0dmFyIG9wdHMgPSBudWxsO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdG9wdHMgPSBKU09OLnBhcnNlKHN0cik7XHJcblxyXG5cdFx0fSBjYXRjaCAoZVBhcnNlKSB7XHJcblx0XHRcdGlmICghanNjLnB1Yi5sb29zZUpTT04pIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBqc2NvbG9yIG9wdGlvbnMgYXMgSlNPTjogJyArIGVQYXJzZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gbG9vc2UgSlNPTiBzeW50YXggaXMgZW5hYmxlZCAtPiB0cnkgdG8gZXZhbHVhdGUgdGhlIG9wdGlvbnMgc3RyaW5nIGFzIEphdmFTY3JpcHQgb2JqZWN0XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdG9wdHMgPSAobmV3IEZ1bmN0aW9uICgndmFyIG9wdHMgPSAoJyArIHN0ciArICcpOyByZXR1cm4gdHlwZW9mIG9wdHMgPT09IFwib2JqZWN0XCIgPyBvcHRzIDoge307JykpKCk7XHJcblx0XHRcdFx0fSBjYXRjaCAoZUV2YWwpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV2YWx1YXRlIGpzY29sb3Igb3B0aW9uczogJyArIGVFdmFsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBvcHRzO1xyXG5cdH0sXHJcblxyXG5cclxuXHRnZXRJbnN0YW5jZXMgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5zdCA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBqc2MuaW5zdGFuY2VzLmxlbmd0aDsgaSArPSAxKSB7XHJcblx0XHRcdC8vIGlmIHRoZSB0YXJnZXRFbGVtZW50IHN0aWxsIGV4aXN0cywgdGhlIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgXCJhbGl2ZVwiXHJcblx0XHRcdGlmIChqc2MuaW5zdGFuY2VzW2ldICYmIGpzYy5pbnN0YW5jZXNbaV0udGFyZ2V0RWxlbWVudCkge1xyXG5cdFx0XHRcdGluc3QucHVzaChqc2MuaW5zdGFuY2VzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGluc3Q7XHJcblx0fSxcclxuXHJcblxyXG5cdGNyZWF0ZUVsIDogZnVuY3Rpb24gKHRhZ05hbWUpIHtcclxuXHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0XHRqc2Muc2V0RGF0YShlbCwgJ2d1aScsIHRydWUpXHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblxyXG5cdG5vZGUgOiBmdW5jdGlvbiAobm9kZU9yU2VsZWN0b3IpIHtcclxuXHRcdGlmICghbm9kZU9yU2VsZWN0b3IpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBub2RlT3JTZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0Ly8gcXVlcnkgc2VsZWN0b3JcclxuXHRcdFx0dmFyIHNlbCA9IG5vZGVPclNlbGVjdG9yO1xyXG5cdFx0XHR2YXIgZWwgPSBudWxsO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWwpO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKGUpO1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghZWwpIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ05vIGVsZW1lbnQgbWF0Y2hlcyB0aGUgc2VsZWN0b3I6ICVzJywgc2VsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZWw7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGpzYy5pc05vZGUobm9kZU9yU2VsZWN0b3IpKSB7XHJcblx0XHRcdC8vIERPTSBub2RlXHJcblx0XHRcdHJldHVybiBub2RlT3JTZWxlY3RvcjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zb2xlLndhcm4oJ0ludmFsaWQgbm9kZSBvZiB0eXBlICVzOiAlcycsIHR5cGVvZiBub2RlT3JTZWxlY3Rvciwgbm9kZU9yU2VsZWN0b3IpO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODQyODYvXHJcblx0aXNOb2RlIDogZnVuY3Rpb24gKHZhbCkge1xyXG5cdFx0aWYgKHR5cGVvZiBOb2RlID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRyZXR1cm4gdmFsIGluc3RhbmNlb2YgTm9kZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XHJcblx0fSxcclxuXHJcblxyXG5cdG5vZGVOYW1lIDogZnVuY3Rpb24gKG5vZGUpIHtcclxuXHRcdGlmIChub2RlICYmIG5vZGUubm9kZU5hbWUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHJcblx0cmVtb3ZlQ2hpbGRyZW4gOiBmdW5jdGlvbiAobm9kZSkge1xyXG5cdFx0d2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdGlzVGV4dElucHV0IDogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRyZXR1cm4gZWwgJiYganNjLm5vZGVOYW1lKGVsKSA9PT0gJ2lucHV0JyAmJiBlbC50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0JztcclxuXHR9LFxyXG5cclxuXHJcblx0aXNCdXR0b24gOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdGlmICghZWwpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG4gPSBqc2Mubm9kZU5hbWUoZWwpO1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0KG4gPT09ICdidXR0b24nKSB8fFxyXG5cdFx0XHQobiA9PT0gJ2lucHV0JyAmJiBbJ2J1dHRvbicsICdzdWJtaXQnLCAncmVzZXQnXS5pbmRleE9mKGVsLnR5cGUudG9Mb3dlckNhc2UoKSkgPiAtMSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblxyXG5cdGlzQnV0dG9uRW1wdHkgOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHN3aXRjaCAoanNjLm5vZGVOYW1lKGVsKSkge1xyXG5cdFx0XHRjYXNlICdpbnB1dCc6IHJldHVybiAoIWVsLnZhbHVlIHx8IGVsLnZhbHVlLnRyaW0oKSA9PT0gJycpO1xyXG5cdFx0XHRjYXNlICdidXR0b24nOiByZXR1cm4gKGVsLnRleHRDb250ZW50LnRyaW0oKSA9PT0gJycpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7IC8vIGNvdWxkIG5vdCBkZXRlcm1pbmUgZWxlbWVudCdzIHRleHRcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kXHJcblx0aXNQYXNzaXZlRXZlbnRTdXBwb3J0ZWQgOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgc3VwcG9ydGVkID0gdHJ1ZTsgfVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XHJcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xyXG5cdFx0fSBjYXRjaCAoZSkge31cclxuXHJcblx0XHRyZXR1cm4gc3VwcG9ydGVkO1xyXG5cdH0pKCksXHJcblxyXG5cclxuXHRpc0NvbG9yQXR0clN1cHBvcnRlZCA6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdGlmIChlbG0uc2V0QXR0cmlidXRlKSB7XHJcblx0XHRcdGVsbS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY29sb3InKTtcclxuXHRcdFx0aWYgKGVsbS50eXBlLnRvTG93ZXJDYXNlKCkgPT0gJ2NvbG9yJykge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSkoKSxcclxuXHJcblxyXG5cdGRhdGFQcm9wIDogJ19kYXRhX2pzY29sb3InLFxyXG5cclxuXHJcblx0Ly8gdXNhZ2U6XHJcblx0Ly8gICBzZXREYXRhKG9iaiwgcHJvcCwgdmFsdWUpXHJcblx0Ly8gICBzZXREYXRhKG9iaiwge3Byb3A6dmFsdWUsIC4uLn0pXHJcblx0Ly9cclxuXHRzZXREYXRhIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9iaiA9IGFyZ3VtZW50c1swXTtcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHQvLyBzZXR0aW5nIGEgc2luZ2xlIHByb3BlcnR5XHJcblx0XHRcdHZhciBkYXRhID0gb2JqLmhhc093blByb3BlcnR5KGpzYy5kYXRhUHJvcCkgPyBvYmpbanNjLmRhdGFQcm9wXSA6IChvYmpbanNjLmRhdGFQcm9wXSA9IHt9KTtcclxuXHRcdFx0dmFyIHByb3AgPSBhcmd1bWVudHNbMV07XHJcblx0XHRcdHZhciB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcclxuXHJcblx0XHRcdGRhdGFbcHJvcF0gPSB2YWx1ZTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdC8vIHNldHRpbmcgbXVsdGlwbGUgcHJvcGVydGllc1xyXG5cdFx0XHR2YXIgZGF0YSA9IG9iai5oYXNPd25Qcm9wZXJ0eShqc2MuZGF0YVByb3ApID8gb2JqW2pzYy5kYXRhUHJvcF0gOiAob2JqW2pzYy5kYXRhUHJvcF0gPSB7fSk7XHJcblx0XHRcdHZhciBtYXAgPSBhcmd1bWVudHNbMV07XHJcblxyXG5cdFx0XHRmb3IgKHZhciBwcm9wIGluIG1hcCkge1xyXG5cdFx0XHRcdGlmIChtYXAuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuXHRcdFx0XHRcdGRhdGFbcHJvcF0gPSBtYXBbcHJvcF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gdXNhZ2U6XHJcblx0Ly8gICByZW1vdmVEYXRhKG9iaiwgcHJvcCwgW3Byb3AuLi5dKVxyXG5cdC8vXHJcblx0cmVtb3ZlRGF0YSA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvYmogPSBhcmd1bWVudHNbMF07XHJcblx0XHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShqc2MuZGF0YVByb3ApKSB7XHJcblx0XHRcdHJldHVybiB0cnVlOyAvLyBkYXRhIG9iamVjdCBkb2VzIG5vdCBleGlzdFxyXG5cdFx0fVxyXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHRcdFx0dmFyIHByb3AgPSBhcmd1bWVudHNbaV07XHJcblx0XHRcdGRlbGV0ZSBvYmpbanNjLmRhdGFQcm9wXVtwcm9wXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cclxuXHRnZXREYXRhIDogZnVuY3Rpb24gKG9iaiwgcHJvcCwgc2V0RGVmYXVsdCkge1xyXG5cdFx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoanNjLmRhdGFQcm9wKSkge1xyXG5cdFx0XHQvLyBkYXRhIG9iamVjdCBkb2VzIG5vdCBleGlzdFxyXG5cdFx0XHRpZiAoc2V0RGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0b2JqW2pzYy5kYXRhUHJvcF0gPSB7fTsgLy8gY3JlYXRlIGRhdGEgb2JqZWN0XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDsgLy8gbm8gdmFsdWUgdG8gcmV0dXJuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHZhciBkYXRhID0gb2JqW2pzYy5kYXRhUHJvcF07XHJcblxyXG5cdFx0aWYgKCFkYXRhLmhhc093blByb3BlcnR5KHByb3ApICYmIHNldERlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRkYXRhW3Byb3BdID0gc2V0RGVmYXVsdDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBkYXRhW3Byb3BdO1xyXG5cdH0sXHJcblxyXG5cclxuXHRnZXREYXRhQXR0ciA6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0dmFyIGF0dHJOYW1lID0gJ2RhdGEtJyArIG5hbWU7XHJcblx0XHR2YXIgYXR0clZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcclxuXHRcdHJldHVybiBhdHRyVmFsdWU7XHJcblx0fSxcclxuXHJcblxyXG5cdF9hdHRhY2hlZEdyb3VwRXZlbnRzIDoge30sXHJcblxyXG5cclxuXHRhdHRhY2hHcm91cEV2ZW50IDogZnVuY3Rpb24gKGdyb3VwTmFtZSwgZWwsIGV2bnQsIGZ1bmMpIHtcclxuXHRcdGlmICghanNjLl9hdHRhY2hlZEdyb3VwRXZlbnRzLmhhc093blByb3BlcnR5KGdyb3VwTmFtZSkpIHtcclxuXHRcdFx0anNjLl9hdHRhY2hlZEdyb3VwRXZlbnRzW2dyb3VwTmFtZV0gPSBbXTtcclxuXHRcdH1cclxuXHRcdGpzYy5fYXR0YWNoZWRHcm91cEV2ZW50c1tncm91cE5hbWVdLnB1c2goW2VsLCBldm50LCBmdW5jXSk7XHJcblx0XHRlbC5hZGRFdmVudExpc3RlbmVyKGV2bnQsIGZ1bmMsIGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHJcblx0ZGV0YWNoR3JvdXBFdmVudHMgOiBmdW5jdGlvbiAoZ3JvdXBOYW1lKSB7XHJcblx0XHRpZiAoanNjLl9hdHRhY2hlZEdyb3VwRXZlbnRzLmhhc093blByb3BlcnR5KGdyb3VwTmFtZSkpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBqc2MuX2F0dGFjaGVkR3JvdXBFdmVudHNbZ3JvdXBOYW1lXS5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0XHRcdHZhciBldnQgPSBqc2MuX2F0dGFjaGVkR3JvdXBFdmVudHNbZ3JvdXBOYW1lXVtpXTtcclxuXHRcdFx0XHRldnRbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRbMV0sIGV2dFsyXSwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRlbGV0ZSBqc2MuX2F0dGFjaGVkR3JvdXBFdmVudHNbZ3JvdXBOYW1lXTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0cHJldmVudERlZmF1bHQgOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUucHJldmVudERlZmF1bHQpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblxyXG5cdGNhcHR1cmVUYXJnZXQgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcblx0XHQvLyBJRVxyXG5cdFx0aWYgKHRhcmdldC5zZXRDYXB0dXJlKSB7XHJcblx0XHRcdGpzYy5fY2FwdHVyZWRUYXJnZXQgPSB0YXJnZXQ7XHJcblx0XHRcdGpzYy5fY2FwdHVyZWRUYXJnZXQuc2V0Q2FwdHVyZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHRyZWxlYXNlVGFyZ2V0IDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gSUVcclxuXHRcdGlmIChqc2MuX2NhcHR1cmVkVGFyZ2V0KSB7XHJcblx0XHRcdGpzYy5fY2FwdHVyZWRUYXJnZXQucmVsZWFzZUNhcHR1cmUoKTtcclxuXHRcdFx0anNjLl9jYXB0dXJlZFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdHRyaWdnZXJFdmVudCA6IGZ1bmN0aW9uIChlbCwgZXZlbnROYW1lLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XHJcblx0XHRpZiAoIWVsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZXYgPSBudWxsO1xyXG5cclxuXHRcdGlmICh0eXBlb2YgRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0ZXYgPSBuZXcgRXZlbnQoZXZlbnROYW1lLCB7XHJcblx0XHRcdFx0YnViYmxlczogYnViYmxlcyxcclxuXHRcdFx0XHRjYW5jZWxhYmxlOiBjYW5jZWxhYmxlXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gSUVcclxuXHRcdFx0ZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuXHRcdFx0ZXYuaW5pdEV2ZW50KGV2ZW50TmFtZSwgYnViYmxlcywgY2FuY2VsYWJsZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFldikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgaW50ZXJuYWxseVxyXG5cdFx0anNjLnNldERhdGEoZXYsICdpbnRlcm5hbCcsIHRydWUpO1xyXG5cclxuXHRcdGVsLmRpc3BhdGNoRXZlbnQoZXYpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblxyXG5cdHRyaWdnZXJJbnB1dEV2ZW50IDogZnVuY3Rpb24gKGVsLCBldmVudE5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcclxuXHRcdGlmICghZWwpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGpzYy5pc1RleHRJbnB1dChlbCkpIHtcclxuXHRcdFx0anNjLnRyaWdnZXJFdmVudChlbCwgZXZlbnROYW1lLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0ZXZlbnRLZXkgOiBmdW5jdGlvbiAoZXYpIHtcclxuXHRcdHZhciBrZXlzID0ge1xyXG5cdFx0XHQ5OiAnVGFiJyxcclxuXHRcdFx0MTM6ICdFbnRlcicsXHJcblx0XHRcdDI3OiAnRXNjYXBlJyxcclxuXHRcdH07XHJcblx0XHRpZiAodHlwZW9mIGV2LmNvZGUgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHJldHVybiBldi5jb2RlO1xyXG5cdFx0fSBlbHNlIGlmIChldi5rZXlDb2RlICE9PSB1bmRlZmluZWQgJiYga2V5cy5oYXNPd25Qcm9wZXJ0eShldi5rZXlDb2RlKSkge1xyXG5cdFx0XHRyZXR1cm4ga2V5c1tldi5rZXlDb2RlXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0sXHJcblxyXG5cclxuXHRzdHJMaXN0IDogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0aWYgKCFzdHIpIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykuc3BsaXQoL1xccysvKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gVGhlIGNsYXNzTmFtZSBwYXJhbWV0ZXIgKHN0cikgY2FuIG9ubHkgY29udGFpbiBhIHNpbmdsZSBjbGFzcyBuYW1lXHJcblx0aGFzQ2xhc3MgOiBmdW5jdGlvbiAoZWxtLCBjbGFzc05hbWUpIHtcclxuXHRcdGlmICghY2xhc3NOYW1lKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGlmIChlbG0uY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIGVsbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHRcdC8vIHBvbHlmaWxsXHJcblx0XHRyZXR1cm4gLTEgIT0gKCcgJyArIGVsbS5jbGFzc05hbWUucmVwbGFjZSgvXFxzKy9nLCAnICcpICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIFRoZSBjbGFzc05hbWUgcGFyYW1ldGVyIChzdHIpIGNhbiBjb250YWluIG11bHRpcGxlIGNsYXNzIG5hbWVzIHNlcGFyYXRlZCBieSB3aGl0ZXNwYWNlXHJcblx0YWRkQ2xhc3MgOiBmdW5jdGlvbiAoZWxtLCBjbGFzc05hbWUpIHtcclxuXHRcdHZhciBjbGFzc05hbWVzID0ganNjLnN0ckxpc3QoY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAoZWxtLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0XHRcdGVsbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdC8vIHBvbHlmaWxsXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHRcdFx0aWYgKCFqc2MuaGFzQ2xhc3MoZWxtLCBjbGFzc05hbWVzW2ldKSkge1xyXG5cdFx0XHRcdGVsbS5jbGFzc05hbWUgKz0gKGVsbS5jbGFzc05hbWUgPyAnICcgOiAnJykgKyBjbGFzc05hbWVzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIFRoZSBjbGFzc05hbWUgcGFyYW1ldGVyIChzdHIpIGNhbiBjb250YWluIG11bHRpcGxlIGNsYXNzIG5hbWVzIHNlcGFyYXRlZCBieSB3aGl0ZXNwYWNlXHJcblx0cmVtb3ZlQ2xhc3MgOiBmdW5jdGlvbiAoZWxtLCBjbGFzc05hbWUpIHtcclxuXHRcdHZhciBjbGFzc05hbWVzID0ganNjLnN0ckxpc3QoY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAoZWxtLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0XHRcdGVsbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdC8vIHBvbHlmaWxsXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHRcdFx0dmFyIHJlcGwgPSBuZXcgUmVnRXhwKFxyXG5cdFx0XHRcdCdeXFxcXHMqJyArIGNsYXNzTmFtZXNbaV0gKyAnXFxcXHMqfCcgK1xyXG5cdFx0XHRcdCdcXFxccyonICsgY2xhc3NOYW1lc1tpXSArICdcXFxccyokfCcgK1xyXG5cdFx0XHRcdCdcXFxccysnICsgY2xhc3NOYW1lc1tpXSArICcoXFxcXHMrKScsXHJcblx0XHRcdFx0J2cnXHJcblx0XHRcdCk7XHJcblx0XHRcdGVsbS5jbGFzc05hbWUgPSBlbG0uY2xhc3NOYW1lLnJlcGxhY2UocmVwbCwgJyQxJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdGdldENvbXBTdHlsZSA6IGZ1bmN0aW9uIChlbG0pIHtcclxuXHRcdHZhciBjb21wU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsbSkgOiBlbG0uY3VycmVudFN0eWxlO1xyXG5cclxuXHRcdC8vIE5vdGU6IEluIEZpcmVmb3gsIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBudWxsIGluIGEgaGlkZGVuIGlmcmFtZSxcclxuXHRcdC8vIHRoYXQncyB3aHkgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbm9uLWVtcHR5XHJcblx0XHRpZiAoIWNvbXBTdHlsZSkge1xyXG5cdFx0XHRyZXR1cm4ge307XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29tcFN0eWxlO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBOb3RlOlxyXG5cdC8vICAgU2V0dGluZyBhIHByb3BlcnR5IHRvIE5VTEwgcmV2ZXJ0cyBpdCB0byB0aGUgc3RhdGUgYmVmb3JlIGl0IHdhcyBmaXJzdCBzZXRcclxuXHQvLyAgIHdpdGggdGhlICdyZXZlcnNpYmxlJyBmbGFnIGVuYWJsZWRcclxuXHQvL1xyXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKGVsbSwgc3R5bGVzLCBpbXBvcnRhbnQsIHJldmVyc2libGUpIHtcclxuXHRcdC8vIHVzaW5nICcnIGZvciBzdGFuZGFyZCBwcmlvcml0eSAoSUUxMCBhcHBhcmVudGx5IGRvZXNuJ3QgbGlrZSB2YWx1ZSB1bmRlZmluZWQpXHJcblx0XHR2YXIgcHJpb3JpdHkgPSBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnO1xyXG5cdFx0dmFyIG9yaWdTdHlsZSA9IG51bGw7XHJcblxyXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBzdHlsZXMpIHtcclxuXHRcdFx0aWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG5cdFx0XHRcdHZhciBzZXRWYWwgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRpZiAoc3R5bGVzW3Byb3BdID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHQvLyByZXZlcnRpbmcgYSBwcm9wZXJ0eSB2YWx1ZVxyXG5cclxuXHRcdFx0XHRcdGlmICghb3JpZ1N0eWxlKSB7XHJcblx0XHRcdFx0XHRcdC8vIGdldCB0aGUgb3JpZ2luYWwgc3R5bGUgb2JqZWN0LCBidXQgZG9udCd0IHRyeSB0byBjcmVhdGUgaXQgaWYgaXQgZG9lc24ndCBleGlzdFxyXG5cdFx0XHRcdFx0XHRvcmlnU3R5bGUgPSBqc2MuZ2V0RGF0YShlbG0sICdvcmlnU3R5bGUnKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChvcmlnU3R5bGUgJiYgb3JpZ1N0eWxlLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcblx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgcHJvcGVydHkncyBvcmlnaW5hbCB2YWx1ZSAtPiB1c2UgaXRcclxuXHRcdFx0XHRcdFx0c2V0VmFsID0gb3JpZ1N0eWxlW3Byb3BdO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gc2V0dGluZyBhIHByb3BlcnR5IHZhbHVlXHJcblxyXG5cdFx0XHRcdFx0aWYgKHJldmVyc2libGUpIHtcclxuXHRcdFx0XHRcdFx0aWYgKCFvcmlnU3R5bGUpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBnZXQgdGhlIG9yaWdpbmFsIHN0eWxlIG9iamVjdCBhbmQgaWYgaXQgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XHJcblx0XHRcdFx0XHRcdFx0b3JpZ1N0eWxlID0ganNjLmdldERhdGEoZWxtLCAnb3JpZ1N0eWxlJywge30pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmICghb3JpZ1N0eWxlLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gb3JpZ2luYWwgcHJvcGVydHkgdmFsdWUgbm90IHlldCBzdG9yZWQgLT4gc3RvcmUgaXRcclxuXHRcdFx0XHRcdFx0XHRvcmlnU3R5bGVbcHJvcF0gPSBlbG0uc3R5bGVbcHJvcF07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHNldFZhbCA9IHN0eWxlc1twcm9wXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChzZXRWYWwgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBzZXRWYWwsIHByaW9yaXR5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0bGluZWFyR3JhZGllbnQgOiAoZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldEZ1bmNOYW1lICgpIHtcclxuXHRcdFx0dmFyIHN0ZE5hbWUgPSAnbGluZWFyLWdyYWRpZW50JztcclxuXHRcdFx0dmFyIHByZWZpeGVzID0gWycnLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJywgJy1tcy0nXTtcclxuXHRcdFx0dmFyIGhlbHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0XHRcdHZhciB0cnlGdW5jID0gcHJlZml4ZXNbaV0gKyBzdGROYW1lO1xyXG5cdFx0XHRcdHZhciB0cnlWYWwgPSB0cnlGdW5jICsgJyh0byByaWdodCwgcmdiYSgwLDAsMCwwKSwgcmdiYSgwLDAsMCwwKSknO1xyXG5cclxuXHRcdFx0XHRoZWxwZXIuc3R5bGUuYmFja2dyb3VuZCA9IHRyeVZhbDtcclxuXHRcdFx0XHRpZiAoaGVscGVyLnN0eWxlLmJhY2tncm91bmQpIHsgLy8gQ1NTIGJhY2tncm91bmQgc3VjY2Vzc2Z1bGx5IHNldCAtPiBmdW5jdGlvbiBuYW1lIGlzIHN1cHBvcnRlZFxyXG5cdFx0XHRcdFx0cmV0dXJuIHRyeUZ1bmM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzdGROYW1lOyAvLyBmYWxsYmFjayB0byBzdGFuZGFyZCAnbGluZWFyLWdyYWRpZW50JyB3aXRob3V0IHZlbmRvciBwcmVmaXhcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZSgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBmdW5jTmFtZSArICcoJyArIEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnLCAnKSArICcpJztcclxuXHRcdH07XHJcblxyXG5cdH0pKCksXHJcblxyXG5cclxuXHRzZXRCb3JkZXJSYWRpdXMgOiBmdW5jdGlvbiAoZWxtLCB2YWx1ZSkge1xyXG5cdFx0anNjLnNldFN0eWxlKGVsbSwgeydib3JkZXItcmFkaXVzJyA6IHZhbHVlIHx8ICcwJ30pO1xyXG5cdH0sXHJcblxyXG5cclxuXHRzZXRCb3hTaGFkb3cgOiBmdW5jdGlvbiAoZWxtLCB2YWx1ZSkge1xyXG5cdFx0anNjLnNldFN0eWxlKGVsbSwgeydib3gtc2hhZG93JzogdmFsdWUgfHwgJ25vbmUnfSk7XHJcblx0fSxcclxuXHJcblxyXG5cdGdldEVsZW1lbnRQb3MgOiBmdW5jdGlvbiAoZSwgcmVsYXRpdmVUb1ZpZXdwb3J0KSB7XHJcblx0XHR2YXIgeD0wLCB5PTA7XHJcblx0XHR2YXIgcmVjdCA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHR4ID0gcmVjdC5sZWZ0O1xyXG5cdFx0eSA9IHJlY3QudG9wO1xyXG5cdFx0aWYgKCFyZWxhdGl2ZVRvVmlld3BvcnQpIHtcclxuXHRcdFx0dmFyIHZpZXdQb3MgPSBqc2MuZ2V0Vmlld1BvcygpO1xyXG5cdFx0XHR4ICs9IHZpZXdQb3NbMF07XHJcblx0XHRcdHkgKz0gdmlld1Bvc1sxXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBbeCwgeV07XHJcblx0fSxcclxuXHJcblxyXG5cdGdldEVsZW1lbnRTaXplIDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBbZS5vZmZzZXRXaWR0aCwgZS5vZmZzZXRIZWlnaHRdO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBnZXQgcG9pbnRlcidzIFgvWSBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB2aWV3cG9ydFxyXG5cdGdldEFic1BvaW50ZXJQb3MgOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHggPSAwLCB5ID0gMDtcclxuXHRcdGlmICh0eXBlb2YgZS5jaGFuZ2VkVG91Y2hlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gdG91Y2ggZGV2aWNlc1xyXG5cdFx0XHR4ID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xyXG5cdFx0XHR5ID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZS5jbGllbnRYID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHR4ID0gZS5jbGllbnRYO1xyXG5cdFx0XHR5ID0gZS5jbGllbnRZO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHsgeDogeCwgeTogeSB9O1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBnZXQgcG9pbnRlcidzIFgvWSBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0YXJnZXQgZWxlbWVudFxyXG5cdGdldFJlbFBvaW50ZXJQb3MgOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdHZhciB0YXJnZXRSZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRcdHZhciB4ID0gMCwgeSA9IDA7XHJcblxyXG5cdFx0dmFyIGNsaWVudFggPSAwLCBjbGllbnRZID0gMDtcclxuXHRcdGlmICh0eXBlb2YgZS5jaGFuZ2VkVG91Y2hlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gdG91Y2ggZGV2aWNlc1xyXG5cdFx0XHRjbGllbnRYID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xyXG5cdFx0XHRjbGllbnRZID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZS5jbGllbnRYID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRjbGllbnRYID0gZS5jbGllbnRYO1xyXG5cdFx0XHRjbGllbnRZID0gZS5jbGllbnRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHggPSBjbGllbnRYIC0gdGFyZ2V0UmVjdC5sZWZ0O1xyXG5cdFx0eSA9IGNsaWVudFkgLSB0YXJnZXRSZWN0LnRvcDtcclxuXHRcdHJldHVybiB7IHg6IHgsIHk6IHkgfTtcclxuXHR9LFxyXG5cclxuXHJcblx0Z2V0Vmlld1BvcyA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvYy5zY3JvbGxMZWZ0KSAtIChkb2MuY2xpZW50TGVmdCB8fCAwKSxcclxuXHRcdFx0KHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2Muc2Nyb2xsVG9wKSAtIChkb2MuY2xpZW50VG9wIHx8IDApXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cclxuXHRnZXRWaWV3U2l6ZSA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2luZG93LmlubmVyV2lkdGggfHwgZG9jLmNsaWVudFdpZHRoKSxcclxuXHRcdFx0KHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2MuY2xpZW50SGVpZ2h0KSxcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHI6IDAtMjU1XHJcblx0Ly8gZzogMC0yNTVcclxuXHQvLyBiOiAwLTI1NVxyXG5cdC8vXHJcblx0Ly8gcmV0dXJuczogWyAwLTM2MCwgMC0xMDAsIDAtMTAwIF1cclxuXHQvL1xyXG5cdFJHQl9IU1YgOiBmdW5jdGlvbiAociwgZywgYikge1xyXG5cdFx0ciAvPSAyNTU7XHJcblx0XHRnIC89IDI1NTtcclxuXHRcdGIgLz0gMjU1O1xyXG5cdFx0dmFyIG4gPSBNYXRoLm1pbihNYXRoLm1pbihyLGcpLGIpO1xyXG5cdFx0dmFyIHYgPSBNYXRoLm1heChNYXRoLm1heChyLGcpLGIpO1xyXG5cdFx0dmFyIG0gPSB2IC0gbjtcclxuXHRcdGlmIChtID09PSAwKSB7IHJldHVybiBbIG51bGwsIDAsIDEwMCAqIHYgXTsgfVxyXG5cdFx0dmFyIGggPSByPT09biA/IDMrKGItZykvbSA6IChnPT09biA/IDUrKHItYikvbSA6IDErKGctcikvbSk7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQ2MCAqIChoPT09Nj8wOmgpLFxyXG5cdFx0XHQxMDAgKiAobS92KSxcclxuXHRcdFx0MTAwICogdlxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gaDogMC0zNjBcclxuXHQvLyBzOiAwLTEwMFxyXG5cdC8vIHY6IDAtMTAwXHJcblx0Ly9cclxuXHQvLyByZXR1cm5zOiBbIDAtMjU1LCAwLTI1NSwgMC0yNTUgXVxyXG5cdC8vXHJcblx0SFNWX1JHQiA6IGZ1bmN0aW9uIChoLCBzLCB2KSB7XHJcblx0XHR2YXIgdSA9IDI1NSAqICh2IC8gMTAwKTtcclxuXHJcblx0XHRpZiAoaCA9PT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gWyB1LCB1LCB1IF07XHJcblx0XHR9XHJcblxyXG5cdFx0aCAvPSA2MDtcclxuXHRcdHMgLz0gMTAwO1xyXG5cclxuXHRcdHZhciBpID0gTWF0aC5mbG9vcihoKTtcclxuXHRcdHZhciBmID0gaSUyID8gaC1pIDogMS0oaC1pKTtcclxuXHRcdHZhciBtID0gdSAqICgxIC0gcyk7XHJcblx0XHR2YXIgbiA9IHUgKiAoMSAtIHMgKiBmKTtcclxuXHRcdHN3aXRjaCAoaSkge1xyXG5cdFx0XHRjYXNlIDY6XHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIFt1LG4sbV07XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIFtuLHUsbV07XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIFttLHUsbl07XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIFttLG4sdV07XHJcblx0XHRcdGNhc2UgNDogcmV0dXJuIFtuLG0sdV07XHJcblx0XHRcdGNhc2UgNTogcmV0dXJuIFt1LG0sbl07XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdHBhcnNlQ29sb3JTdHJpbmcgOiBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHR2YXIgcmV0ID0ge1xyXG5cdFx0XHRyZ2JhOiBudWxsLFxyXG5cdFx0XHRmb3JtYXQ6IG51bGwgLy8gJ2hleCcgfCAncmdiJyB8ICdyZ2JhJ1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgbTtcclxuXHRcdGlmIChtID0gc3RyLm1hdGNoKC9eXFxXKihbMC05QS1GXXszfShbMC05QS1GXXszfSk/KVxcVyokL2kpKSB7XHJcblx0XHRcdC8vIEhFWCBub3RhdGlvblxyXG5cclxuXHRcdFx0cmV0LmZvcm1hdCA9ICdoZXgnO1xyXG5cclxuXHRcdFx0aWYgKG1bMV0ubGVuZ3RoID09PSA2KSB7XHJcblx0XHRcdFx0Ly8gNi1jaGFyIG5vdGF0aW9uXHJcblx0XHRcdFx0cmV0LnJnYmEgPSBbXHJcblx0XHRcdFx0XHRwYXJzZUludChtWzFdLnN1YnN0cigwLDIpLDE2KSxcclxuXHRcdFx0XHRcdHBhcnNlSW50KG1bMV0uc3Vic3RyKDIsMiksMTYpLFxyXG5cdFx0XHRcdFx0cGFyc2VJbnQobVsxXS5zdWJzdHIoNCwyKSwxNiksXHJcblx0XHRcdFx0XHRudWxsXHJcblx0XHRcdFx0XTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyAzLWNoYXIgbm90YXRpb25cclxuXHRcdFx0XHRyZXQucmdiYSA9IFtcclxuXHRcdFx0XHRcdHBhcnNlSW50KG1bMV0uY2hhckF0KDApICsgbVsxXS5jaGFyQXQoMCksMTYpLFxyXG5cdFx0XHRcdFx0cGFyc2VJbnQobVsxXS5jaGFyQXQoMSkgKyBtWzFdLmNoYXJBdCgxKSwxNiksXHJcblx0XHRcdFx0XHRwYXJzZUludChtWzFdLmNoYXJBdCgyKSArIG1bMV0uY2hhckF0KDIpLDE2KSxcclxuXHRcdFx0XHRcdG51bGxcclxuXHRcdFx0XHRdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiByZXQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChtID0gc3RyLm1hdGNoKC9eXFxXKnJnYmE/XFwoKFteKV0qKVxcKVxcVyokL2kpKSB7XHJcblx0XHRcdC8vIHJnYiguLi4pIG9yIHJnYmEoLi4uKSBub3RhdGlvblxyXG5cclxuXHRcdFx0dmFyIHBhcmFtcyA9IG1bMV0uc3BsaXQoJywnKTtcclxuXHRcdFx0dmFyIHJlID0gL15cXHMqKFxcZCt8XFxkKlxcLlxcZCt8XFxkK1xcLlxcZCopXFxzKiQvO1xyXG5cdFx0XHR2YXIgbVIsIG1HLCBtQiwgbUE7XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRwYXJhbXMubGVuZ3RoID49IDMgJiZcclxuXHRcdFx0XHQobVIgPSBwYXJhbXNbMF0ubWF0Y2gocmUpKSAmJlxyXG5cdFx0XHRcdChtRyA9IHBhcmFtc1sxXS5tYXRjaChyZSkpICYmXHJcblx0XHRcdFx0KG1CID0gcGFyYW1zWzJdLm1hdGNoKHJlKSlcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0cmV0LmZvcm1hdCA9ICdyZ2InO1xyXG5cdFx0XHRcdHJldC5yZ2JhID0gW1xyXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChtUlsxXSkgfHwgMCxcclxuXHRcdFx0XHRcdHBhcnNlRmxvYXQobUdbMV0pIHx8IDAsXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KG1CWzFdKSB8fCAwLFxyXG5cdFx0XHRcdFx0bnVsbFxyXG5cdFx0XHRcdF07XHJcblxyXG5cdFx0XHRcdGlmIChcclxuXHRcdFx0XHRcdHBhcmFtcy5sZW5ndGggPj0gNCAmJlxyXG5cdFx0XHRcdFx0KG1BID0gcGFyYW1zWzNdLm1hdGNoKHJlKSlcclxuXHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdHJldC5mb3JtYXQgPSAncmdiYSc7XHJcblx0XHRcdFx0XHRyZXQucmdiYVszXSA9IHBhcnNlRmxvYXQobUFbMV0pIHx8IDA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiByZXQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIENhbnZhcyBzY2FsaW5nIGZvciByZXRpbmEgZGlzcGxheXNcclxuXHQvL1xyXG5cdC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2hpZHBpL1xyXG5cdC8vXHJcblx0c2NhbGVDYW52YXNGb3JIaWdoRFBSIDogZnVuY3Rpb24gKGNhbnZhcykge1xyXG5cdFx0dmFyIGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XHJcblx0XHRjYW52YXMud2lkdGggKj0gZHByO1xyXG5cdFx0Y2FudmFzLmhlaWdodCAqPSBkcHI7XHJcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRjdHguc2NhbGUoZHByLCBkcHIpO1xyXG5cdH0sXHJcblxyXG5cclxuXHRnZW5Db2xvclByZXZpZXdDYW52YXMgOiBmdW5jdGlvbiAoY29sb3IsIHNlcGFyYXRvclBvcywgc3BlY1dpZHRoLCBzY2FsZUZvckhpZ2hEUFIpIHtcclxuXHJcblx0XHR2YXIgc2VwVyA9IE1hdGgucm91bmQoanNjLnB1Yi5wcmV2aWV3U2VwYXJhdG9yLmxlbmd0aCk7XHJcblx0XHR2YXIgc3FTaXplID0ganNjLnB1Yi5jaGVzc2JvYXJkU2l6ZTtcclxuXHRcdHZhciBzcUNvbG9yMSA9IGpzYy5wdWIuY2hlc3Nib2FyZENvbG9yMTtcclxuXHRcdHZhciBzcUNvbG9yMiA9IGpzYy5wdWIuY2hlc3Nib2FyZENvbG9yMjtcclxuXHJcblx0XHR2YXIgY1dpZHRoID0gc3BlY1dpZHRoID8gc3BlY1dpZHRoIDogc3FTaXplICogMjtcclxuXHRcdHZhciBjSGVpZ2h0ID0gc3FTaXplICogMjtcclxuXHJcblx0XHR2YXIgY2FudmFzID0ganNjLmNyZWF0ZUVsKCdjYW52YXMnKTtcclxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcblx0XHRjYW52YXMud2lkdGggPSBjV2lkdGg7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gY0hlaWdodDtcclxuXHRcdGlmIChzY2FsZUZvckhpZ2hEUFIpIHtcclxuXHRcdFx0anNjLnNjYWxlQ2FudmFzRm9ySGlnaERQUihjYW52YXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRyYW5zcGFyZW5jeSBjaGVzc2JvYXJkIC0gYmFja2dyb3VuZFxyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHNxQ29sb3IxO1xyXG5cdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIGNXaWR0aCwgY0hlaWdodCk7XHJcblxyXG5cdFx0Ly8gdHJhbnNwYXJlbmN5IGNoZXNzYm9hcmQgLSBzcXVhcmVzXHJcblx0XHRjdHguZmlsbFN0eWxlID0gc3FDb2xvcjI7XHJcblx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IGNXaWR0aDsgeCArPSBzcVNpemUgKiAyKSB7XHJcblx0XHRcdGN0eC5maWxsUmVjdCh4LCAwLCBzcVNpemUsIHNxU2l6ZSk7XHJcblx0XHRcdGN0eC5maWxsUmVjdCh4ICsgc3FTaXplLCBzcVNpemUsIHNxU2l6ZSwgc3FTaXplKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29sb3IpIHtcclxuXHRcdFx0Ly8gYWN0dWFsIGNvbG9yIGluIGZvcmVncm91bmRcclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgY1dpZHRoLCBjSGVpZ2h0KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBudWxsO1xyXG5cdFx0c3dpdGNoIChzZXBhcmF0b3JQb3MpIHtcclxuXHRcdFx0Y2FzZSAnbGVmdCc6XHJcblx0XHRcdFx0c3RhcnQgPSAwO1xyXG5cdFx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2VwVy8yLCBjSGVpZ2h0KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAncmlnaHQnOlxyXG5cdFx0XHRcdHN0YXJ0ID0gY1dpZHRoIC0gc2VwVztcclxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KGNXaWR0aCAtIChzZXBXLzIpLCAwLCBzZXBXLzIsIGNIZWlnaHQpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHN0YXJ0ICE9PSBudWxsKSB7XHJcblx0XHRcdGN0eC5saW5lV2lkdGggPSAxO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGpzYy5wdWIucHJldmlld1NlcGFyYXRvci5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBqc2MucHViLnByZXZpZXdTZXBhcmF0b3JbaV07XHJcblx0XHRcdFx0Y3R4Lm1vdmVUbygwLjUgKyBzdGFydCArIGksIDApO1xyXG5cdFx0XHRcdGN0eC5saW5lVG8oMC41ICsgc3RhcnQgKyBpLCBjSGVpZ2h0KTtcclxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjYW52YXM6IGNhbnZhcyxcclxuXHRcdFx0d2lkdGg6IGNXaWR0aCxcclxuXHRcdFx0aGVpZ2h0OiBjSGVpZ2h0LFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gaWYgcG9zaXRpb24gb3Igd2lkdGggaXMgbm90IHNldCA9PiBmaWxsIHRoZSBlbnRpcmUgZWxlbWVudCAoMCUtMTAwJSlcclxuXHRnZW5Db2xvclByZXZpZXdHcmFkaWVudCA6IGZ1bmN0aW9uIChjb2xvciwgcG9zaXRpb24sIHdpZHRoKSB7XHJcblx0XHR2YXIgcGFyYW1zID0gW107XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICYmIHdpZHRoKSB7XHJcblx0XHRcdHBhcmFtcyA9IFtcclxuXHRcdFx0XHQndG8gJyArIHsnbGVmdCc6J3JpZ2h0JywgJ3JpZ2h0JzonbGVmdCd9W3Bvc2l0aW9uXSxcclxuXHRcdFx0XHRjb2xvciArICcgMCUnLFxyXG5cdFx0XHRcdGNvbG9yICsgJyAnICsgd2lkdGggKyAncHgnLFxyXG5cdFx0XHRcdCdyZ2JhKDAsMCwwLDApICcgKyAod2lkdGggKyAxKSArICdweCcsXHJcblx0XHRcdFx0J3JnYmEoMCwwLDAsMCkgMTAwJScsXHJcblx0XHRcdF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYXJhbXMgPSBbXHJcblx0XHRcdFx0J3RvIHJpZ2h0JyxcclxuXHRcdFx0XHRjb2xvciArICcgMCUnLFxyXG5cdFx0XHRcdGNvbG9yICsgJyAxMDAlJyxcclxuXHRcdFx0XTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ganNjLmxpbmVhckdyYWRpZW50LmFwcGx5KHRoaXMsIHBhcmFtcyk7XHJcblx0fSxcclxuXHJcblxyXG5cdHJlZHJhd1Bvc2l0aW9uIDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmIChqc2MucGlja2VyICYmIGpzYy5waWNrZXIub3duZXIpIHtcclxuXHRcdFx0dmFyIHRoaXNPYmogPSBqc2MucGlja2VyLm93bmVyO1xyXG5cclxuXHRcdFx0dmFyIHRwLCB2cDtcclxuXHJcblx0XHRcdGlmICh0aGlzT2JqLmZpeGVkKSB7XHJcblx0XHRcdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdmlld3BvcnQsXHJcblx0XHRcdFx0Ly8gdGhlcmVmb3JlIHdlIGNhbiBpZ25vcmUgdGhlIHNjcm9sbCBvZmZzZXRcclxuXHRcdFx0XHR0cCA9IGpzYy5nZXRFbGVtZW50UG9zKHRoaXNPYmoudGFyZ2V0RWxlbWVudCwgdHJ1ZSk7IC8vIHRhcmdldCBwb3NcclxuXHRcdFx0XHR2cCA9IFswLCAwXTsgLy8gdmlldyBwb3NcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0cCA9IGpzYy5nZXRFbGVtZW50UG9zKHRoaXNPYmoudGFyZ2V0RWxlbWVudCk7IC8vIHRhcmdldCBwb3NcclxuXHRcdFx0XHR2cCA9IGpzYy5nZXRWaWV3UG9zKCk7IC8vIHZpZXcgcG9zXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0cyA9IGpzYy5nZXRFbGVtZW50U2l6ZSh0aGlzT2JqLnRhcmdldEVsZW1lbnQpOyAvLyB0YXJnZXQgc2l6ZVxyXG5cdFx0XHR2YXIgdnMgPSBqc2MuZ2V0Vmlld1NpemUoKTsgLy8gdmlldyBzaXplXHJcblx0XHRcdHZhciBwcyA9IGpzYy5nZXRQaWNrZXJPdXRlckRpbXModGhpc09iaik7IC8vIHBpY2tlciBzaXplXHJcblx0XHRcdHZhciBhLCBiLCBjO1xyXG5cdFx0XHRzd2l0Y2ggKHRoaXNPYmoucG9zaXRpb24udG9Mb3dlckNhc2UoKSkge1xyXG5cdFx0XHRcdGNhc2UgJ2xlZnQnOiBhPTE7IGI9MDsgYz0tMTsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAncmlnaHQnOmE9MTsgYj0wOyBjPTE7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ3RvcCc6ICBhPTA7IGI9MTsgYz0tMTsgYnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDogICAgIGE9MDsgYj0xOyBjPTE7IGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBsID0gKHRzW2JdK3BzW2JdKS8yO1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSBwaWNrZXIgcG9zaXRpb25cclxuXHRcdFx0aWYgKCF0aGlzT2JqLnNtYXJ0UG9zaXRpb24pIHtcclxuXHRcdFx0XHR2YXIgcHAgPSBbXHJcblx0XHRcdFx0XHR0cFthXSxcclxuXHRcdFx0XHRcdHRwW2JdK3RzW2JdLWwrbCpjXHJcblx0XHRcdFx0XTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgcHAgPSBbXHJcblx0XHRcdFx0XHQtdnBbYV0rdHBbYV0rcHNbYV0gPiB2c1thXSA/XHJcblx0XHRcdFx0XHRcdCgtdnBbYV0rdHBbYV0rdHNbYV0vMiA+IHZzW2FdLzIgJiYgdHBbYV0rdHNbYV0tcHNbYV0gPj0gMCA/IHRwW2FdK3RzW2FdLXBzW2FdIDogdHBbYV0pIDpcclxuXHRcdFx0XHRcdFx0dHBbYV0sXHJcblx0XHRcdFx0XHQtdnBbYl0rdHBbYl0rdHNbYl0rcHNbYl0tbCtsKmMgPiB2c1tiXSA/XHJcblx0XHRcdFx0XHRcdCgtdnBbYl0rdHBbYl0rdHNbYl0vMiA+IHZzW2JdLzIgJiYgdHBbYl0rdHNbYl0tbC1sKmMgPj0gMCA/IHRwW2JdK3RzW2JdLWwtbCpjIDogdHBbYl0rdHNbYl0tbCtsKmMpIDpcclxuXHRcdFx0XHRcdFx0KHRwW2JdK3RzW2JdLWwrbCpjID49IDAgPyB0cFtiXSt0c1tiXS1sK2wqYyA6IHRwW2JdK3RzW2JdLWwtbCpjKVxyXG5cdFx0XHRcdF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB4ID0gcHBbYV07XHJcblx0XHRcdHZhciB5ID0gcHBbYl07XHJcblx0XHRcdHZhciBwb3NpdGlvblZhbHVlID0gdGhpc09iai5maXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xyXG5cdFx0XHR2YXIgY29udHJhY3RTaGFkb3cgPVxyXG5cdFx0XHRcdChwcFswXSArIHBzWzBdID4gdHBbMF0gfHwgcHBbMF0gPCB0cFswXSArIHRzWzBdKSAmJlxyXG5cdFx0XHRcdChwcFsxXSArIHBzWzFdIDwgdHBbMV0gKyB0c1sxXSk7XHJcblxyXG5cdFx0XHRqc2MuX2RyYXdQb3NpdGlvbih0aGlzT2JqLCB4LCB5LCBwb3NpdGlvblZhbHVlLCBjb250cmFjdFNoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdF9kcmF3UG9zaXRpb24gOiBmdW5jdGlvbiAodGhpc09iaiwgeCwgeSwgcG9zaXRpb25WYWx1ZSwgY29udHJhY3RTaGFkb3cpIHtcclxuXHRcdHZhciB2U2hhZG93ID0gY29udHJhY3RTaGFkb3cgPyAwIDogdGhpc09iai5zaGFkb3dCbHVyOyAvLyBweFxyXG5cclxuXHRcdGpzYy5waWNrZXIud3JhcC5zdHlsZS5wb3NpdGlvbiA9IHBvc2l0aW9uVmFsdWU7XHJcblx0XHRqc2MucGlja2VyLndyYXAuc3R5bGUubGVmdCA9IHggKyAncHgnO1xyXG5cdFx0anNjLnBpY2tlci53cmFwLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xyXG5cclxuXHRcdGpzYy5zZXRCb3hTaGFkb3coXHJcblx0XHRcdGpzYy5waWNrZXIuYm94UyxcclxuXHRcdFx0dGhpc09iai5zaGFkb3cgP1xyXG5cdFx0XHRcdG5ldyBqc2MuQm94U2hhZG93KDAsIHZTaGFkb3csIHRoaXNPYmouc2hhZG93Qmx1ciwgMCwgdGhpc09iai5zaGFkb3dDb2xvcikgOlxyXG5cdFx0XHRcdG51bGwpO1xyXG5cdH0sXHJcblxyXG5cclxuXHRnZXRQaWNrZXJEaW1zIDogZnVuY3Rpb24gKHRoaXNPYmopIHtcclxuXHRcdHZhciBkaW1zID0gW1xyXG5cdFx0XHQyICogdGhpc09iai5jb250cm9sQm9yZGVyV2lkdGggKyAyICogdGhpc09iai5wYWRkaW5nICsgdGhpc09iai53aWR0aCxcclxuXHRcdFx0MiAqIHRoaXNPYmouY29udHJvbEJvcmRlcldpZHRoICsgMiAqIHRoaXNPYmoucGFkZGluZyArIHRoaXNPYmouaGVpZ2h0XHJcblx0XHRdO1xyXG5cdFx0dmFyIHNsaWRlclNwYWNlID0gMiAqIHRoaXNPYmouY29udHJvbEJvcmRlcldpZHRoICsgMiAqIGpzYy5nZXRDb250cm9sUGFkZGluZyh0aGlzT2JqKSArIHRoaXNPYmouc2xpZGVyU2l6ZTtcclxuXHRcdGlmIChqc2MuZ2V0U2xpZGVyQ2hhbm5lbCh0aGlzT2JqKSkge1xyXG5cdFx0XHRkaW1zWzBdICs9IHNsaWRlclNwYWNlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXNPYmouaGFzQWxwaGFDaGFubmVsKCkpIHtcclxuXHRcdFx0ZGltc1swXSArPSBzbGlkZXJTcGFjZTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzT2JqLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdGRpbXNbMV0gKz0gMiAqIHRoaXNPYmouY29udHJvbEJvcmRlcldpZHRoICsgdGhpc09iai5wYWRkaW5nICsgdGhpc09iai5idXR0b25IZWlnaHQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGltcztcclxuXHR9LFxyXG5cclxuXHJcblx0Z2V0UGlja2VyT3V0ZXJEaW1zIDogZnVuY3Rpb24gKHRoaXNPYmopIHtcclxuXHRcdHZhciBkaW1zID0ganNjLmdldFBpY2tlckRpbXModGhpc09iaik7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRkaW1zWzBdICsgMiAqIHRoaXNPYmouYm9yZGVyV2lkdGgsXHJcblx0XHRcdGRpbXNbMV0gKyAyICogdGhpc09iai5ib3JkZXJXaWR0aFxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHJcblx0Z2V0Q29udHJvbFBhZGRpbmcgOiBmdW5jdGlvbiAodGhpc09iaikge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KFxyXG5cdFx0XHR0aGlzT2JqLnBhZGRpbmcgLyAyLFxyXG5cdFx0XHQoMiAqIHRoaXNPYmoucG9pbnRlckJvcmRlcldpZHRoICsgdGhpc09iai5wb2ludGVyVGhpY2tuZXNzKSAtIHRoaXNPYmouY29udHJvbEJvcmRlcldpZHRoXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cclxuXHRnZXRQYWRZQ2hhbm5lbCA6IGZ1bmN0aW9uICh0aGlzT2JqKSB7XHJcblx0XHRzd2l0Y2ggKHRoaXNPYmoubW9kZS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSkge1xyXG5cdFx0XHRjYXNlICd2JzogcmV0dXJuICd2JzsgYnJlYWs7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gJ3MnO1xyXG5cdH0sXHJcblxyXG5cclxuXHRnZXRTbGlkZXJDaGFubmVsIDogZnVuY3Rpb24gKHRoaXNPYmopIHtcclxuXHRcdGlmICh0aGlzT2JqLm1vZGUubGVuZ3RoID4gMikge1xyXG5cdFx0XHRzd2l0Y2ggKHRoaXNPYmoubW9kZS5jaGFyQXQoMikudG9Mb3dlckNhc2UoKSkge1xyXG5cdFx0XHRcdGNhc2UgJ3MnOiByZXR1cm4gJ3MnOyBicmVhaztcclxuXHRcdFx0XHRjYXNlICd2JzogcmV0dXJuICd2JzsgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0sXHJcblxyXG5cclxuXHRvbkRvY3VtZW50TW91c2VEb3duIDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblxyXG5cdFx0aWYgKHRhcmdldC5qc2NvbG9yICYmIHRhcmdldC5qc2NvbG9yIGluc3RhbmNlb2YganNjLnB1YikgeyAvLyBjbGlja2VkIHRhcmdldEVsZW1lbnQgLT4gc2hvdyBwaWNrZXJcclxuXHRcdFx0aWYgKHRhcmdldC5qc2NvbG9yLnNob3dPbkNsaWNrICYmICF0YXJnZXQuZGlzYWJsZWQpIHtcclxuXHRcdFx0XHR0YXJnZXQuanNjb2xvci5zaG93KCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoanNjLmdldERhdGEodGFyZ2V0LCAnZ3VpJykpIHsgLy8gY2xpY2tlZCBqc2NvbG9yJ3MgR1VJIGVsZW1lbnRcclxuXHRcdFx0dmFyIGNvbnRyb2wgPSBqc2MuZ2V0RGF0YSh0YXJnZXQsICdjb250cm9sJyk7XHJcblx0XHRcdGlmIChjb250cm9sKSB7XHJcblx0XHRcdFx0Ly8ganNjb2xvcidzIGNvbnRyb2xcclxuXHRcdFx0XHRqc2Mub25Db250cm9sUG9pbnRlclN0YXJ0KGUsIHRhcmdldCwganNjLmdldERhdGEodGFyZ2V0LCAnY29udHJvbCcpLCAnbW91c2UnKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gbW91c2UgaXMgb3V0c2lkZSB0aGUgcGlja2VyJ3MgY29udHJvbHMgLT4gaGlkZSB0aGUgY29sb3IgcGlja2VyIVxyXG5cdFx0XHRpZiAoanNjLnBpY2tlciAmJiBqc2MucGlja2VyLm93bmVyKSB7XHJcblx0XHRcdFx0anNjLnBpY2tlci5vd25lci50cnlIaWRlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0b25Eb2N1bWVudEtleVVwIDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChbJ1RhYicsICdFc2NhcGUnXS5pbmRleE9mKGpzYy5ldmVudEtleShlKSkgIT09IC0xKSB7XHJcblx0XHRcdGlmIChqc2MucGlja2VyICYmIGpzYy5waWNrZXIub3duZXIpIHtcclxuXHRcdFx0XHRqc2MucGlja2VyLm93bmVyLnRyeUhpZGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHRvbldpbmRvd1Jlc2l6ZSA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRqc2MucmVkcmF3UG9zaXRpb24oKTtcclxuXHR9LFxyXG5cclxuXHJcblx0b25QYXJlbnRTY3JvbGwgOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaGlkZSB0aGUgcGlja2VyIHdoZW4gb25lIG9mIHRoZSBwYXJlbnQgZWxlbWVudHMgaXMgc2Nyb2xsZWRcclxuXHRcdGlmIChqc2MucGlja2VyICYmIGpzYy5waWNrZXIub3duZXIpIHtcclxuXHRcdFx0anNjLnBpY2tlci5vd25lci50cnlIaWRlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdG9uUGlja2VyVG91Y2hTdGFydCA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cclxuXHRcdGlmIChqc2MuZ2V0RGF0YSh0YXJnZXQsICdjb250cm9sJykpIHtcclxuXHRcdFx0anNjLm9uQ29udHJvbFBvaW50ZXJTdGFydChlLCB0YXJnZXQsIGpzYy5nZXREYXRhKHRhcmdldCwgJ2NvbnRyb2wnKSwgJ3RvdWNoJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIGNhbGxzIGZ1bmN0aW9uIHNwZWNpZmllZCBpbiBwaWNrZXIncyBwcm9wZXJ0eVxyXG5cdHRyaWdnZXJDYWxsYmFjayA6IGZ1bmN0aW9uICh0aGlzT2JqLCBwcm9wKSB7XHJcblx0XHRpZiAoIXRoaXNPYmpbcHJvcF0pIHtcclxuXHRcdFx0cmV0dXJuOyAvLyBjYWxsYmFjayBmdW5jIG5vdCBzcGVjaWZpZWRcclxuXHRcdH1cclxuXHRcdHZhciBjYWxsYmFjayA9IG51bGw7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0aGlzT2JqW3Byb3BdID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHQvLyBzdHJpbmcgd2l0aCBjb2RlXHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24gKHRoaXNPYmpbcHJvcF0pO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gZnVuY3Rpb25cclxuXHRcdFx0Y2FsbGJhY2sgPSB0aGlzT2JqW3Byb3BdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjYWxsYmFjaykge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKHRoaXNPYmopO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBUcmlnZ2VycyBhIGNvbG9yIGNoYW5nZSByZWxhdGVkIGV2ZW50KHMpIG9uIGFsbCBwaWNrZXIgaW5zdGFuY2VzLlxyXG5cdC8vIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCB3aXRoIGEgc3BhY2UuXHJcblx0dHJpZ2dlckdsb2JhbCA6IGZ1bmN0aW9uIChldmVudE5hbWVzKSB7XHJcblx0XHR2YXIgaW5zdCA9IGpzYy5nZXRJbnN0YW5jZXMoKTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdC5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0XHRpbnN0W2ldLnRyaWdnZXIoZXZlbnROYW1lcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdF9wb2ludGVyTW92ZUV2ZW50IDoge1xyXG5cdFx0bW91c2U6ICdtb3VzZW1vdmUnLFxyXG5cdFx0dG91Y2g6ICd0b3VjaG1vdmUnXHJcblx0fSxcclxuXHRfcG9pbnRlckVuZEV2ZW50IDoge1xyXG5cdFx0bW91c2U6ICdtb3VzZXVwJyxcclxuXHRcdHRvdWNoOiAndG91Y2hlbmQnXHJcblx0fSxcclxuXHJcblxyXG5cdF9wb2ludGVyT3JpZ2luIDogbnVsbCxcclxuXHRfY2FwdHVyZWRUYXJnZXQgOiBudWxsLFxyXG5cclxuXHJcblx0b25Db250cm9sUG9pbnRlclN0YXJ0IDogZnVuY3Rpb24gKGUsIHRhcmdldCwgY29udHJvbE5hbWUsIHBvaW50ZXJUeXBlKSB7XHJcblx0XHR2YXIgdGhpc09iaiA9IGpzYy5nZXREYXRhKHRhcmdldCwgJ2luc3RhbmNlJyk7XHJcblxyXG5cdFx0anNjLnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0anNjLmNhcHR1cmVUYXJnZXQodGFyZ2V0KTtcclxuXHJcblx0XHR2YXIgcmVnaXN0ZXJEcmFnRXZlbnRzID0gZnVuY3Rpb24gKGRvYywgb2Zmc2V0KSB7XHJcblx0XHRcdGpzYy5hdHRhY2hHcm91cEV2ZW50KCdkcmFnJywgZG9jLCBqc2MuX3BvaW50ZXJNb3ZlRXZlbnRbcG9pbnRlclR5cGVdLFxyXG5cdFx0XHRcdGpzYy5vbkRvY3VtZW50UG9pbnRlck1vdmUoZSwgdGFyZ2V0LCBjb250cm9sTmFtZSwgcG9pbnRlclR5cGUsIG9mZnNldCkpO1xyXG5cdFx0XHRqc2MuYXR0YWNoR3JvdXBFdmVudCgnZHJhZycsIGRvYywganNjLl9wb2ludGVyRW5kRXZlbnRbcG9pbnRlclR5cGVdLFxyXG5cdFx0XHRcdGpzYy5vbkRvY3VtZW50UG9pbnRlckVuZChlLCB0YXJnZXQsIGNvbnRyb2xOYW1lLCBwb2ludGVyVHlwZSkpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZWdpc3RlckRyYWdFdmVudHMoZG9jdW1lbnQsIFswLCAwXSk7XHJcblxyXG5cdFx0aWYgKHdpbmRvdy5wYXJlbnQgJiYgd2luZG93LmZyYW1lRWxlbWVudCkge1xyXG5cdFx0XHR2YXIgcmVjdCA9IHdpbmRvdy5mcmFtZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHRcdHZhciBvZnMgPSBbLXJlY3QubGVmdCwgLXJlY3QudG9wXTtcclxuXHRcdFx0cmVnaXN0ZXJEcmFnRXZlbnRzKHdpbmRvdy5wYXJlbnQud2luZG93LmRvY3VtZW50LCBvZnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhYnMgPSBqc2MuZ2V0QWJzUG9pbnRlclBvcyhlKTtcclxuXHRcdHZhciByZWwgPSBqc2MuZ2V0UmVsUG9pbnRlclBvcyhlKTtcclxuXHRcdGpzYy5fcG9pbnRlck9yaWdpbiA9IHtcclxuXHRcdFx0eDogYWJzLnggLSByZWwueCxcclxuXHRcdFx0eTogYWJzLnkgLSByZWwueVxyXG5cdFx0fTtcclxuXHJcblx0XHRzd2l0Y2ggKGNvbnRyb2xOYW1lKSB7XHJcblx0XHRjYXNlICdwYWQnOlxyXG5cdFx0XHQvLyBpZiB0aGUgdmFsdWUgc2xpZGVyIGlzIGF0IHRoZSBib3R0b20sIG1vdmUgaXQgdXBcclxuXHRcdFx0aWYgKGpzYy5nZXRTbGlkZXJDaGFubmVsKHRoaXNPYmopID09PSAndicgJiYgdGhpc09iai5jaGFubmVscy52ID09PSAwKSB7XHJcblx0XHRcdFx0dGhpc09iai5mcm9tSFNWQShudWxsLCBudWxsLCAxMDAsIG51bGwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGpzYy5zZXRQYWQodGhpc09iaiwgZSwgMCwgMCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ3NsZCc6XHJcblx0XHRcdGpzYy5zZXRTbGQodGhpc09iaiwgZSwgMCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ2FzbGQnOlxyXG5cdFx0XHRqc2Muc2V0QVNsZCh0aGlzT2JqLCBlLCAwKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0XHR0aGlzT2JqLnRyaWdnZXIoJ2lucHV0Jyk7XHJcblx0fSxcclxuXHJcblxyXG5cdG9uRG9jdW1lbnRQb2ludGVyTW92ZSA6IGZ1bmN0aW9uIChlLCB0YXJnZXQsIGNvbnRyb2xOYW1lLCBwb2ludGVyVHlwZSwgb2Zmc2V0KSB7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHRoaXNPYmogPSBqc2MuZ2V0RGF0YSh0YXJnZXQsICdpbnN0YW5jZScpO1xyXG5cdFx0XHRzd2l0Y2ggKGNvbnRyb2xOYW1lKSB7XHJcblx0XHRcdGNhc2UgJ3BhZCc6XHJcblx0XHRcdFx0anNjLnNldFBhZCh0aGlzT2JqLCBlLCBvZmZzZXRbMF0sIG9mZnNldFsxXSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdzbGQnOlxyXG5cdFx0XHRcdGpzYy5zZXRTbGQodGhpc09iaiwgZSwgb2Zmc2V0WzFdKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ2FzbGQnOlxyXG5cdFx0XHRcdGpzYy5zZXRBU2xkKHRoaXNPYmosIGUsIG9mZnNldFsxXSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpc09iai50cmlnZ2VyKCdpbnB1dCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHRvbkRvY3VtZW50UG9pbnRlckVuZCA6IGZ1bmN0aW9uIChlLCB0YXJnZXQsIGNvbnRyb2xOYW1lLCBwb2ludGVyVHlwZSkge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciB0aGlzT2JqID0ganNjLmdldERhdGEodGFyZ2V0LCAnaW5zdGFuY2UnKTtcclxuXHRcdFx0anNjLmRldGFjaEdyb3VwRXZlbnRzKCdkcmFnJyk7XHJcblx0XHRcdGpzYy5yZWxlYXNlVGFyZ2V0KCk7XHJcblxyXG5cdFx0XHQvLyBBbHdheXMgdHJpZ2dlciBjaGFuZ2VzIEFGVEVSIGRldGFjaGluZyBvdXRzdGFuZGluZyBtb3VzZSBoYW5kbGVycyxcclxuXHRcdFx0Ly8gaW4gY2FzZSBzb21lIGNvbG9yIGNoYW5nZSBvY2N1cmVkIGluIHVzZXItZGVmaW5lZCBvbkNoYW5nZS9vbklucHV0IGhhbmRsZXJcclxuXHRcdFx0Ly8gd291bGQgaW50cnVkZSBpbnRvIGN1cnJlbnQgbW91c2UgZXZlbnRzXHJcblx0XHRcdHRoaXNPYmoudHJpZ2dlcignaW5wdXQnKTtcclxuXHRcdFx0dGhpc09iai50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblxyXG5cdHNldFBhZCA6IGZ1bmN0aW9uICh0aGlzT2JqLCBlLCBvZnNYLCBvZnNZKSB7XHJcblx0XHR2YXIgcG9pbnRlckFicyA9IGpzYy5nZXRBYnNQb2ludGVyUG9zKGUpO1xyXG5cdFx0dmFyIHggPSBvZnNYICsgcG9pbnRlckFicy54IC0ganNjLl9wb2ludGVyT3JpZ2luLnggLSB0aGlzT2JqLnBhZGRpbmcgLSB0aGlzT2JqLmNvbnRyb2xCb3JkZXJXaWR0aDtcclxuXHRcdHZhciB5ID0gb2ZzWSArIHBvaW50ZXJBYnMueSAtIGpzYy5fcG9pbnRlck9yaWdpbi55IC0gdGhpc09iai5wYWRkaW5nIC0gdGhpc09iai5jb250cm9sQm9yZGVyV2lkdGg7XHJcblxyXG5cdFx0dmFyIHhWYWwgPSB4ICogKDM2MCAvICh0aGlzT2JqLndpZHRoIC0gMSkpO1xyXG5cdFx0dmFyIHlWYWwgPSAxMDAgLSAoeSAqICgxMDAgLyAodGhpc09iai5oZWlnaHQgLSAxKSkpO1xyXG5cclxuXHRcdHN3aXRjaCAoanNjLmdldFBhZFlDaGFubmVsKHRoaXNPYmopKSB7XHJcblx0XHRjYXNlICdzJzogdGhpc09iai5mcm9tSFNWQSh4VmFsLCB5VmFsLCBudWxsLCBudWxsKTsgYnJlYWs7XHJcblx0XHRjYXNlICd2JzogdGhpc09iai5mcm9tSFNWQSh4VmFsLCBudWxsLCB5VmFsLCBudWxsKTsgYnJlYWs7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdHNldFNsZCA6IGZ1bmN0aW9uICh0aGlzT2JqLCBlLCBvZnNZKSB7XHJcblx0XHR2YXIgcG9pbnRlckFicyA9IGpzYy5nZXRBYnNQb2ludGVyUG9zKGUpO1xyXG5cdFx0dmFyIHkgPSBvZnNZICsgcG9pbnRlckFicy55IC0ganNjLl9wb2ludGVyT3JpZ2luLnkgLSB0aGlzT2JqLnBhZGRpbmcgLSB0aGlzT2JqLmNvbnRyb2xCb3JkZXJXaWR0aDtcclxuXHRcdHZhciB5VmFsID0gMTAwIC0gKHkgKiAoMTAwIC8gKHRoaXNPYmouaGVpZ2h0IC0gMSkpKTtcclxuXHJcblx0XHRzd2l0Y2ggKGpzYy5nZXRTbGlkZXJDaGFubmVsKHRoaXNPYmopKSB7XHJcblx0XHRjYXNlICdzJzogdGhpc09iai5mcm9tSFNWQShudWxsLCB5VmFsLCBudWxsLCBudWxsKTsgYnJlYWs7XHJcblx0XHRjYXNlICd2JzogdGhpc09iai5mcm9tSFNWQShudWxsLCBudWxsLCB5VmFsLCBudWxsKTsgYnJlYWs7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdHNldEFTbGQgOiBmdW5jdGlvbiAodGhpc09iaiwgZSwgb2ZzWSkge1xyXG5cdFx0dmFyIHBvaW50ZXJBYnMgPSBqc2MuZ2V0QWJzUG9pbnRlclBvcyhlKTtcclxuXHRcdHZhciB5ID0gb2ZzWSArIHBvaW50ZXJBYnMueSAtIGpzYy5fcG9pbnRlck9yaWdpbi55IC0gdGhpc09iai5wYWRkaW5nIC0gdGhpc09iai5jb250cm9sQm9yZGVyV2lkdGg7XHJcblx0XHR2YXIgeVZhbCA9IDEuMCAtICh5ICogKDEuMCAvICh0aGlzT2JqLmhlaWdodCAtIDEpKSk7XHJcblxyXG5cdFx0aWYgKHlWYWwgPCAxLjApIHtcclxuXHRcdFx0Ly8gaWYgZm9ybWF0IGlzIGZsZXhpYmxlIGFuZCB0aGUgY3VycmVudCBmb3JtYXQgZG9lc24ndCBzdXBwb3J0IGFscGhhLCBzd2l0Y2ggdG8gYSBzdWl0YWJsZSBvbmVcclxuXHRcdFx0aWYgKHRoaXNPYmouZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09ICdhbnknICYmIHRoaXNPYmouZ2V0Rm9ybWF0KCkgIT09ICdyZ2JhJykge1xyXG5cdFx0XHRcdHRoaXNPYmouX2N1cnJlbnRGb3JtYXQgPSAncmdiYSc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzT2JqLmZyb21IU1ZBKG51bGwsIG51bGwsIG51bGwsIHlWYWwpO1xyXG5cdH0sXHJcblxyXG5cclxuXHRjcmVhdGVQYWxldHRlIDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwYWxldHRlT2JqID0ge1xyXG5cdFx0XHRlbG06IG51bGwsXHJcblx0XHRcdGRyYXc6IG51bGxcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGNhbnZhcyA9IGpzYy5jcmVhdGVFbCgnY2FudmFzJyk7XHJcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5cdFx0dmFyIGRyYXdGdW5jID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHR5cGUpIHtcclxuXHRcdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG5cdFx0XHR2YXIgaEdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgY2FudmFzLndpZHRoLCAwKTtcclxuXHRcdFx0aEdyYWQuYWRkQ29sb3JTdG9wKDAgLyA2LCAnI0YwMCcpO1xyXG5cdFx0XHRoR3JhZC5hZGRDb2xvclN0b3AoMSAvIDYsICcjRkYwJyk7XHJcblx0XHRcdGhHcmFkLmFkZENvbG9yU3RvcCgyIC8gNiwgJyMwRjAnKTtcclxuXHRcdFx0aEdyYWQuYWRkQ29sb3JTdG9wKDMgLyA2LCAnIzBGRicpO1xyXG5cdFx0XHRoR3JhZC5hZGRDb2xvclN0b3AoNCAvIDYsICcjMDBGJyk7XHJcblx0XHRcdGhHcmFkLmFkZENvbG9yU3RvcCg1IC8gNiwgJyNGMEYnKTtcclxuXHRcdFx0aEdyYWQuYWRkQ29sb3JTdG9wKDYgLyA2LCAnI0YwMCcpO1xyXG5cclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGhHcmFkO1xyXG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcblx0XHRcdHZhciB2R3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBjYW52YXMuaGVpZ2h0KTtcclxuXHRcdFx0c3dpdGNoICh0eXBlLnRvTG93ZXJDYXNlKCkpIHtcclxuXHRcdFx0Y2FzZSAncyc6XHJcblx0XHRcdFx0dkdyYWQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKDI1NSwyNTUsMjU1LDApJyk7XHJcblx0XHRcdFx0dkdyYWQuYWRkQ29sb3JTdG9wKDEsICdyZ2JhKDI1NSwyNTUsMjU1LDEpJyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ3YnOlxyXG5cdFx0XHRcdHZHcmFkLmFkZENvbG9yU3RvcCgwLCAncmdiYSgwLDAsMCwwKScpO1xyXG5cdFx0XHRcdHZHcmFkLmFkZENvbG9yU3RvcCgxLCAncmdiYSgwLDAsMCwxKScpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2R3JhZDtcclxuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHBhbGV0dGVPYmouZWxtID0gY2FudmFzO1xyXG5cdFx0cGFsZXR0ZU9iai5kcmF3ID0gZHJhd0Z1bmM7XHJcblxyXG5cdFx0cmV0dXJuIHBhbGV0dGVPYmo7XHJcblx0fSxcclxuXHJcblxyXG5cdGNyZWF0ZVNsaWRlckdyYWRpZW50IDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBzbGlkZXJPYmogPSB7XHJcblx0XHRcdGVsbTogbnVsbCxcclxuXHRcdFx0ZHJhdzogbnVsbFxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgY2FudmFzID0ganNjLmNyZWF0ZUVsKCdjYW52YXMnKTtcclxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcblx0XHR2YXIgZHJhd0Z1bmMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgY29sb3IxLCBjb2xvcjIpIHtcclxuXHRcdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG5cdFx0XHR2YXIgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBjYW52YXMuaGVpZ2h0KTtcclxuXHRcdFx0Z3JhZC5hZGRDb2xvclN0b3AoMCwgY29sb3IxKTtcclxuXHRcdFx0Z3JhZC5hZGRDb2xvclN0b3AoMSwgY29sb3IyKTtcclxuXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBncmFkO1xyXG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHRcdH07XHJcblxyXG5cdFx0c2xpZGVyT2JqLmVsbSA9IGNhbnZhcztcclxuXHRcdHNsaWRlck9iai5kcmF3ID0gZHJhd0Z1bmM7XHJcblxyXG5cdFx0cmV0dXJuIHNsaWRlck9iajtcclxuXHR9LFxyXG5cclxuXHJcblx0Y3JlYXRlQVNsaWRlckdyYWRpZW50IDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBzbGlkZXJPYmogPSB7XHJcblx0XHRcdGVsbTogbnVsbCxcclxuXHRcdFx0ZHJhdzogbnVsbFxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgY2FudmFzID0ganNjLmNyZWF0ZUVsKCdjYW52YXMnKTtcclxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcblx0XHR2YXIgZHJhd0Z1bmMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgY29sb3IpIHtcclxuXHRcdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG5cdFx0XHR2YXIgc3FTaXplID0gY2FudmFzLndpZHRoIC8gMjtcclxuXHRcdFx0dmFyIHNxQ29sb3IxID0ganNjLnB1Yi5jaGVzc2JvYXJkQ29sb3IxO1xyXG5cdFx0XHR2YXIgc3FDb2xvcjIgPSBqc2MucHViLmNoZXNzYm9hcmRDb2xvcjI7XHJcblxyXG5cdFx0XHQvLyBkYXJrIGdyYXkgYmFja2dyb3VuZFxyXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gc3FDb2xvcjE7XHJcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5ICs9IHNxU2l6ZSAqIDIpIHtcclxuXHRcdFx0XHQvLyBsaWdodCBncmF5IHNxdWFyZXNcclxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gc3FDb2xvcjI7XHJcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIHksIHNxU2l6ZSwgc3FTaXplKTtcclxuXHRcdFx0XHRjdHguZmlsbFJlY3Qoc3FTaXplLCB5ICsgc3FTaXplLCBzcVNpemUsIHNxU2l6ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGNhbnZhcy5oZWlnaHQpO1xyXG5cdFx0XHRncmFkLmFkZENvbG9yU3RvcCgwLCBjb2xvcik7XHJcblx0XHRcdGdyYWQuYWRkQ29sb3JTdG9wKDEsICdyZ2JhKDAsMCwwLDApJyk7XHJcblxyXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZ3JhZDtcclxuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHNsaWRlck9iai5lbG0gPSBjYW52YXM7XHJcblx0XHRzbGlkZXJPYmouZHJhdyA9IGRyYXdGdW5jO1xyXG5cclxuXHRcdHJldHVybiBzbGlkZXJPYmo7XHJcblx0fSxcclxuXHJcblxyXG5cdEJveFNoYWRvdyA6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgQm94U2hhZG93ID0gZnVuY3Rpb24gKGhTaGFkb3csIHZTaGFkb3csIGJsdXIsIHNwcmVhZCwgY29sb3IsIGluc2V0KSB7XHJcblx0XHRcdHRoaXMuaFNoYWRvdyA9IGhTaGFkb3c7XHJcblx0XHRcdHRoaXMudlNoYWRvdyA9IHZTaGFkb3c7XHJcblx0XHRcdHRoaXMuYmx1ciA9IGJsdXI7XHJcblx0XHRcdHRoaXMuc3ByZWFkID0gc3ByZWFkO1xyXG5cdFx0XHR0aGlzLmNvbG9yID0gY29sb3I7XHJcblx0XHRcdHRoaXMuaW5zZXQgPSAhIWluc2V0O1xyXG5cdFx0fTtcclxuXHJcblx0XHRCb3hTaGFkb3cucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgdmFscyA9IFtcclxuXHRcdFx0XHRNYXRoLnJvdW5kKHRoaXMuaFNoYWRvdykgKyAncHgnLFxyXG5cdFx0XHRcdE1hdGgucm91bmQodGhpcy52U2hhZG93KSArICdweCcsXHJcblx0XHRcdFx0TWF0aC5yb3VuZCh0aGlzLmJsdXIpICsgJ3B4JyxcclxuXHRcdFx0XHRNYXRoLnJvdW5kKHRoaXMuc3ByZWFkKSArICdweCcsXHJcblx0XHRcdFx0dGhpcy5jb2xvclxyXG5cdFx0XHRdO1xyXG5cdFx0XHRpZiAodGhpcy5pbnNldCkge1xyXG5cdFx0XHRcdHZhbHMucHVzaCgnaW5zZXQnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdmFscy5qb2luKCcgJyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBCb3hTaGFkb3c7XHJcblx0fSkoKSxcclxuXHJcblxyXG5cdGZsYWdzIDoge1xyXG5cdFx0bGVhdmVWYWx1ZSA6IDEgPDwgMCxcclxuXHRcdGxlYXZlQWxwaGEgOiAxIDw8IDEsXHJcblx0XHRsZWF2ZVByZXZpZXcgOiAxIDw8IDIsXHJcblx0fSxcclxuXHJcblxyXG5cdGVudW1PcHRzIDoge1xyXG5cdFx0Zm9ybWF0OiBbJ2F1dG8nLCAnYW55JywgJ2hleCcsICdyZ2InLCAncmdiYSddLFxyXG5cdFx0cHJldmlld1Bvc2l0aW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcclxuXHRcdG1vZGU6IFsnaHN2JywgJ2h2cycsICdocycsICdodiddLFxyXG5cdFx0cG9zaXRpb246IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXHJcblx0XHRhbHBoYUNoYW5uZWw6IFsnYXV0bycsIHRydWUsIGZhbHNlXSxcclxuXHR9LFxyXG5cclxuXHJcblx0ZGVwcmVjYXRlZE9wdHMgOiB7XHJcblx0XHQvLyA8b2xkX29wdGlvbj46IDxuZXdfb3B0aW9uPiAgKDxuZXdfb3B0aW9uPiBjYW4gYmUgbnVsbClcclxuXHRcdCdzdHlsZUVsZW1lbnQnOiAncHJldmlld0VsZW1lbnQnLFxyXG5cdFx0J29uRmluZUNoYW5nZSc6ICdvbklucHV0JyxcclxuXHRcdCdvdmVyd3JpdGVJbXBvcnRhbnQnOiAnZm9yY2VTdHlsZScsXHJcblx0XHQnY2xvc2FibGUnOiAnY2xvc2VCdXR0b24nLFxyXG5cdFx0J2luc2V0V2lkdGgnOiAnY29udHJvbEJvcmRlcldpZHRoJyxcclxuXHRcdCdpbnNldENvbG9yJzogJ2NvbnRyb2xCb3JkZXJDb2xvcicsXHJcblx0XHQncmVmaW5lJzogbnVsbCxcclxuXHR9LFxyXG5cclxuXHJcblx0ZG9jc1JlZiA6ICcgJyArICdTZWUgaHR0cHM6Ly9qc2NvbG9yLmNvbS9kb2NzLycsXHJcblxyXG5cclxuXHQvL1xyXG5cdC8vIFVzYWdlOlxyXG5cdC8vIHZhciBteVBpY2tlciA9IG5ldyBKU0NvbG9yKDx0YXJnZXRFbGVtZW50PiBbLCA8b3B0aW9ucz5dKVxyXG5cdC8vXHJcblx0Ly8gKGNvbnN0cnVjdG9yIGlzIGFjY2Vzc2libGUgdmlhIGJvdGggJ2pzY29sb3InIGFuZCAnSlNDb2xvcicgbmFtZSlcclxuXHQvL1xyXG5cclxuXHRwdWIgOiBmdW5jdGlvbiAodGFyZ2V0RWxlbWVudCwgb3B0cykge1xyXG5cclxuXHRcdHZhciBUSElTID0gdGhpcztcclxuXHJcblx0XHRpZiAoIW9wdHMpIHtcclxuXHRcdFx0b3B0cyA9IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2hhbm5lbHMgPSB7XHJcblx0XHRcdHI6IDI1NSwgLy8gcmVkIFswLTI1NV1cclxuXHRcdFx0ZzogMjU1LCAvLyBncmVlbiBbMC0yNTVdXHJcblx0XHRcdGI6IDI1NSwgLy8gYmx1ZSBbMC0yNTVdXHJcblx0XHRcdGg6IDAsIC8vIGh1ZSBbMC0zNjBdXHJcblx0XHRcdHM6IDAsIC8vIHNhdHVyYXRpb24gWzAtMTAwXVxyXG5cdFx0XHR2OiAxMDAsIC8vIHZhbHVlIChicmlnaHRuZXNzKSBbMC0xMDBdXHJcblx0XHRcdGE6IDEuMCwgLy8gYWxwaGEgKG9wYWNpdHkpIFswLjAgLSAxLjBdXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEdlbmVyYWwgb3B0aW9uc1xyXG5cdFx0Ly9cclxuXHRcdHRoaXMuZm9ybWF0ID0gJ2F1dG8nOyAvLyAnYXV0bycgfCAnYW55JyB8ICdoZXgnIHwgJ3JnYicgfCAncmdiYScgLSBGb3JtYXQgb2YgdGhlIGlucHV0L291dHB1dCB2YWx1ZVxyXG5cdFx0dGhpcy52YWx1ZSA9IHVuZGVmaW5lZDsgLy8gSU5JVElBTCBjb2xvciB2YWx1ZSBpbiBhbnkgc3VwcG9ydGVkIGZvcm1hdC4gVG8gY2hhbmdlIGl0IGxhdGVyLCB1c2UgbWV0aG9kIGZyb21TdHJpbmcoKSwgZnJvbUhTVkEoKSwgZnJvbVJHQkEoKSBvciBjaGFubmVsKClcclxuXHRcdHRoaXMuYWxwaGEgPSB1bmRlZmluZWQ7IC8vIElOSVRJQUwgYWxwaGEgdmFsdWUuIFRvIGNoYW5nZSBpdCBsYXRlciwgY2FsbCBtZXRob2QgY2hhbm5lbCgnQScsIDx2YWx1ZT4pXHJcblx0XHR0aGlzLm9uQ2hhbmdlID0gdW5kZWZpbmVkOyAvLyBjYWxsZWQgd2hlbiBjb2xvciBjaGFuZ2VzLiBWYWx1ZSBjYW4gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcgd2l0aCBKUyBjb2RlLlxyXG5cdFx0dGhpcy5vbklucHV0ID0gdW5kZWZpbmVkOyAvLyBjYWxsZWQgcmVwZWF0ZWRseSBhcyB0aGUgY29sb3IgaXMgYmVpbmcgY2hhbmdlZCwgZS5nLiB3aGlsZSBkcmFnZ2luZyBhIHNsaWRlci4gVmFsdWUgY2FuIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nIHdpdGggSlMgY29kZS5cclxuXHRcdHRoaXMudmFsdWVFbGVtZW50ID0gdW5kZWZpbmVkOyAvLyBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgYW5kIGlucHV0IHRoZSBjb2xvciB2YWx1ZVxyXG5cdFx0dGhpcy5hbHBoYUVsZW1lbnQgPSB1bmRlZmluZWQ7IC8vIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSBhbmQgaW5wdXQgdGhlIGFscGhhIChvcGFjaXR5KSB2YWx1ZVxyXG5cdFx0dGhpcy5wcmV2aWV3RWxlbWVudCA9IHVuZGVmaW5lZDsgLy8gZWxlbWVudCB0aGF0IHdpbGwgcHJldmlldyB0aGUgcGlja2VkIGNvbG9yIHVzaW5nIENTUyBiYWNrZ3JvdW5kXHJcblx0XHR0aGlzLnByZXZpZXdQb3NpdGlvbiA9ICdsZWZ0JzsgLy8gJ2xlZnQnIHwgJ3JpZ2h0JyAtIHBvc2l0aW9uIG9mIHRoZSBjb2xvciBwcmV2aWV3IGluIHByZXZpZXdFbGVtZW50XHJcblx0XHR0aGlzLnByZXZpZXdTaXplID0gMzI7IC8vIChweCkgd2lkdGggb2YgdGhlIGNvbG9yIHByZXZpZXcgZGlzcGxheWVkIGluIHByZXZpZXdFbGVtZW50XHJcblx0XHR0aGlzLnByZXZpZXdQYWRkaW5nID0gODsgLy8gKHB4KSBzcGFjZSBiZXR3ZWVuIGNvbG9yIHByZXZpZXcgYW5kIGNvbnRlbnQgb2YgdGhlIHByZXZpZXdFbGVtZW50XHJcblx0XHR0aGlzLnJlcXVpcmVkID0gdHJ1ZTsgLy8gd2hldGhlciB0aGUgYXNzb2NpYXRlZCB0ZXh0IGlucHV0IG11c3QgYWx3YXlzIGNvbnRhaW4gYSBjb2xvciB2YWx1ZS4gSWYgZmFsc2UsIHRoZSBpbnB1dCBjYW4gYmUgbGVmdCBlbXB0eS5cclxuXHRcdHRoaXMuaGFzaCA9IHRydWU7IC8vIHdoZXRoZXIgdG8gcHJlZml4IHRoZSBIRVggY29sb3IgY29kZSB3aXRoICMgc3ltYm9sIChvbmx5IGFwcGxpY2FibGUgZm9yIEhFWCBmb3JtYXQpXHJcblx0XHR0aGlzLnVwcGVyY2FzZSA9IHRydWU7IC8vIHdoZXRoZXIgdG8gc2hvdyB0aGUgSEVYIGNvbG9yIGNvZGUgaW4gdXBwZXIgY2FzZSAob25seSBhcHBsaWNhYmxlIGZvciBIRVggZm9ybWF0KVxyXG5cdFx0dGhpcy5mb3JjZVN0eWxlID0gdHJ1ZTsgLy8gd2hldGhlciB0byBvdmVyd3JpdGUgQ1NTIHN0eWxlIG9mIHRoZSBwcmV2aWV3RWxlbWVudCB1c2luZyAhaW1wb3J0YW50IGZsYWdcclxuXHJcblx0XHQvLyBDb2xvciBQaWNrZXIgb3B0aW9uc1xyXG5cdFx0Ly9cclxuXHRcdHRoaXMud2lkdGggPSAxODE7IC8vIHdpZHRoIG9mIGNvbG9yIHBhbGV0dGUgKGluIHB4KVxyXG5cdFx0dGhpcy5oZWlnaHQgPSAxMDE7IC8vIGhlaWdodCBvZiBjb2xvciBwYWxldHRlIChpbiBweClcclxuXHRcdHRoaXMubW9kZSA9ICdIU1YnOyAvLyAnSFNWJyB8ICdIVlMnIHwgJ0hTJyB8ICdIVicgLSBsYXlvdXQgb2YgdGhlIGNvbG9yIHBpY2tlciBjb250cm9sc1xyXG5cdFx0dGhpcy5hbHBoYUNoYW5uZWwgPSAnYXV0byc7IC8vICdhdXRvJyB8IHRydWUgfCBmYWxzZSAtIGlmIGFscGhhIGNoYW5uZWwgaXMgZW5hYmxlZCwgdGhlIGFscGhhIHNsaWRlciB3aWxsIGJlIHZpc2libGUuIElmICdhdXRvJywgaXQgd2lsbCBiZSBkZXRlcm1pbmVkIGFjY29yZGluZyB0byBjb2xvciBmb3JtYXRcclxuXHRcdHRoaXMucG9zaXRpb24gPSAnYm90dG9tJzsgLy8gJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd0b3AnIHwgJ2JvdHRvbScgLSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcclxuXHRcdHRoaXMuc21hcnRQb3NpdGlvbiA9IHRydWU7IC8vIGF1dG9tYXRpY2FsbHkgY2hhbmdlIHBpY2tlciBwb3NpdGlvbiB3aGVuIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgZm9yIGl0XHJcblx0XHR0aGlzLnNob3dPbkNsaWNrID0gdHJ1ZTsgLy8gd2hldGhlciB0byBzaG93IHRoZSBwaWNrZXIgd2hlbiB1c2VyIGNsaWNrcyBpdHMgdGFyZ2V0IGVsZW1lbnRcclxuXHRcdHRoaXMuaGlkZU9uTGVhdmUgPSB0cnVlOyAvLyB3aGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgaGlkZSB0aGUgcGlja2VyIHdoZW4gdXNlciBsZWF2ZXMgaXRzIHRhcmdldCBlbGVtZW50IChlLmcuIHVwb24gY2xpY2tpbmcgdGhlIGRvY3VtZW50KVxyXG5cdFx0dGhpcy5zbGlkZXJTaXplID0gMTY7IC8vIHB4XHJcblx0XHR0aGlzLmNyb3NzU2l6ZSA9IDg7IC8vIHB4XHJcblx0XHR0aGlzLmNsb3NlQnV0dG9uID0gZmFsc2U7IC8vIHdoZXRoZXIgdG8gZGlzcGxheSB0aGUgQ2xvc2UgYnV0dG9uXHJcblx0XHR0aGlzLmNsb3NlVGV4dCA9ICdDbG9zZSc7XHJcblx0XHR0aGlzLmJ1dHRvbkNvbG9yID0gJ3JnYmEoMCwwLDAsMSknOyAvLyBDU1MgY29sb3JcclxuXHRcdHRoaXMuYnV0dG9uSGVpZ2h0ID0gMTg7IC8vIHB4XHJcblx0XHR0aGlzLnBhZGRpbmcgPSAxMjsgLy8gcHhcclxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMjU1LDI1NSwyNTUsMSknOyAvLyBDU1MgY29sb3JcclxuXHRcdHRoaXMuYm9yZGVyV2lkdGggPSAxOyAvLyBweFxyXG5cdFx0dGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDE4NywxODcsMTg3LDEpJzsgLy8gQ1NTIGNvbG9yXHJcblx0XHR0aGlzLmJvcmRlclJhZGl1cyA9IDg7IC8vIHB4XHJcblx0XHR0aGlzLmNvbnRyb2xCb3JkZXJXaWR0aCA9IDE7IC8vIHB4XHJcblx0XHR0aGlzLmNvbnRyb2xCb3JkZXJDb2xvciA9ICdyZ2JhKDE4NywxODcsMTg3LDEpJzsgLy8gQ1NTIGNvbG9yXHJcblx0XHR0aGlzLnNoYWRvdyA9IHRydWU7IC8vIHdoZXRoZXIgdG8gZGlzcGxheSBhIHNoYWRvd1xyXG5cdFx0dGhpcy5zaGFkb3dCbHVyID0gMTU7IC8vIHB4XHJcblx0XHR0aGlzLnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMC4yKSc7IC8vIENTUyBjb2xvclxyXG5cdFx0dGhpcy5wb2ludGVyQ29sb3IgPSAncmdiYSg3Niw3Niw3NiwxKSc7IC8vIENTUyBjb2xvclxyXG5cdFx0dGhpcy5wb2ludGVyQm9yZGVyV2lkdGggPSAxOyAvLyBweFxyXG5cdFx0dGhpcy5wb2ludGVyQm9yZGVyQ29sb3IgPSAncmdiYSgyNTUsMjU1LDI1NSwxKSc7IC8vIENTUyBjb2xvclxyXG5cdFx0dGhpcy5wb2ludGVyVGhpY2tuZXNzID0gMjsgLy8gcHhcclxuXHRcdHRoaXMuekluZGV4ID0gNTAwMDtcclxuXHRcdHRoaXMuY29udGFpbmVyID0gdW5kZWZpbmVkOyAvLyB3aGVyZSB0byBhcHBlbmQgdGhlIGNvbG9yIHBpY2tlciAoQk9EWSBlbGVtZW50IGJ5IGRlZmF1bHQpXHJcblxyXG5cdFx0Ly8gRXhwZXJpbWVudGFsXHJcblx0XHQvL1xyXG5cdFx0dGhpcy5taW5TID0gMDsgLy8gbWluIGFsbG93ZWQgc2F0dXJhdGlvbiAoMCAtIDEwMClcclxuXHRcdHRoaXMubWF4UyA9IDEwMDsgLy8gbWF4IGFsbG93ZWQgc2F0dXJhdGlvbiAoMCAtIDEwMClcclxuXHRcdHRoaXMubWluViA9IDA7IC8vIG1pbiBhbGxvd2VkIHZhbHVlIChicmlnaHRuZXNzKSAoMCAtIDEwMClcclxuXHRcdHRoaXMubWF4ViA9IDEwMDsgLy8gbWF4IGFsbG93ZWQgdmFsdWUgKGJyaWdodG5lc3MpICgwIC0gMTAwKVxyXG5cdFx0dGhpcy5taW5BID0gMC4wOyAvLyBtaW4gYWxsb3dlZCBhbHBoYSAob3BhY2l0eSkgKDAuMCAtIDEuMClcclxuXHRcdHRoaXMubWF4QSA9IDEuMDsgLy8gbWF4IGFsbG93ZWQgYWxwaGEgKG9wYWNpdHkpICgwLjAgLSAxLjApXHJcblxyXG5cclxuXHRcdC8vIGxldCdzIHByb2Nlc3MgdGhlIERFUFJFQ0FURUQgJ29wdGlvbnMnIHByb3BlcnR5ICh0aGlzIHdpbGwgYmUgbGF0ZXIgcmVtb3ZlZClcclxuXHRcdGlmIChqc2MucHViLm9wdGlvbnMpIHtcclxuXHRcdFx0Ly8gbGV0J3Mgc2V0IGN1c3RvbSBkZWZhdWx0IG9wdGlvbnMsIGlmIHNwZWNpZmllZFxyXG5cdFx0XHRmb3IgKHZhciBvcHQgaW4ganNjLnB1Yi5vcHRpb25zKSB7XHJcblx0XHRcdFx0aWYgKGpzYy5wdWIub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRzZXRPcHRpb24ob3B0LCBqc2MucHViLm9wdGlvbnNbb3B0XSk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gbGV0J3MgYXBwbHkgY29uZmlndXJhdGlvbiBwcmVzZXRzXHJcblx0XHQvL1xyXG5cdFx0dmFyIHByZXNldHNBcnIgPSBbXTtcclxuXHJcblx0XHRpZiAob3B0cy5wcmVzZXQpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBvcHRzLnByZXNldCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRwcmVzZXRzQXJyID0gb3B0cy5wcmVzZXQuc3BsaXQoL1xccysvKTtcclxuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdHMucHJlc2V0KSkge1xyXG5cdFx0XHRcdHByZXNldHNBcnIgPSBvcHRzLnByZXNldC5zbGljZSgpOyAvLyBzbGljZSgpIHRvIGNsb25lXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdVbnJlY29nbml6ZWQgcHJlc2V0IHZhbHVlJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbHdheXMgdXNlIHRoZSAnZGVmYXVsdCcgcHJlc2V0LiBJZiBpdCdzIG5vdCBsaXN0ZWQsIGFwcGVuZCBpdCB0byB0aGUgZW5kLlxyXG5cdFx0aWYgKHByZXNldHNBcnIuaW5kZXhPZignZGVmYXVsdCcpID09PSAtMSkge1xyXG5cdFx0XHRwcmVzZXRzQXJyLnB1c2goJ2RlZmF1bHQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBsZXQncyBhcHBseSB0aGUgcHJlc2V0cyBpbiByZXZlcnNlIG9yZGVyLCBzbyB0aGF0IHNob3VsZCB0aGVyZSBiZSBhbnkgb3ZlcmxhcHBpbmcgb3B0aW9ucyxcclxuXHRcdC8vIHRoZSBmb3JtZXJseSBsaXN0ZWQgcHJlc2V0IHdpbGwgb3ZlcnJpZGUgdGhlIGxhdHRlclxyXG5cdFx0Zm9yICh2YXIgaSA9IHByZXNldHNBcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuXHRcdFx0dmFyIHByZXMgPSBwcmVzZXRzQXJyW2ldO1xyXG5cdFx0XHRpZiAoIXByZXMpIHtcclxuXHRcdFx0XHRjb250aW51ZTsgLy8gcHJlc2V0IGlzIGVtcHR5IHN0cmluZ1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghanNjLnB1Yi5wcmVzZXRzLmhhc093blByb3BlcnR5KHByZXMpKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdVbmtub3duIHByZXNldDogJXMnLCBwcmVzKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IgKHZhciBvcHQgaW4ganNjLnB1Yi5wcmVzZXRzW3ByZXNdKSB7XHJcblx0XHRcdFx0aWYgKGpzYy5wdWIucHJlc2V0c1twcmVzXS5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRzZXRPcHRpb24ob3B0LCBqc2MucHViLnByZXNldHNbcHJlc11bb3B0XSk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gbGV0J3Mgc2V0IHNwZWNpZmljIG9wdGlvbnMgZm9yIHRoaXMgY29sb3IgcGlja2VyXHJcblx0XHR2YXIgbm9uUHJvcGVydGllcyA9IFtcclxuXHRcdFx0Ly8gdGhlc2Ugb3B0aW9ucyB3b24ndCBiZSBzZXQgYXMgaW5zdGFuY2UgcHJvcGVydGllc1xyXG5cdFx0XHQncHJlc2V0JyxcclxuXHRcdF07XHJcblx0XHRmb3IgKHZhciBvcHQgaW4gb3B0cykge1xyXG5cdFx0XHRpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XHJcblx0XHRcdFx0aWYgKG5vblByb3BlcnRpZXMuaW5kZXhPZihvcHQpID09PSAtMSkge1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0c2V0T3B0aW9uKG9wdCwgb3B0c1tvcHRdKTtcclxuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBHZXR0ZXI6IG9wdGlvbihuYW1lKVxyXG5cdFx0Ly8gU2V0dGVyOiBvcHRpb24obmFtZSwgdmFsdWUpXHJcblx0XHQvLyAgICAgICAgIG9wdGlvbih7bmFtZTp2YWx1ZSwgLi4ufSlcclxuXHRcdC8vXHJcblx0XHR0aGlzLm9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyBvcHRpb24gc3BlY2lmaWVkJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0Ly8gZ2V0dGluZyBhIHNpbmdsZSBvcHRpb25cclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGdldE9wdGlvbihhcmd1bWVudHNbMF0pO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHQvLyBzZXR0aW5nIGEgc2luZ2xlIG9wdGlvblxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRpZiAoIXNldE9wdGlvbihhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybihlKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTsgLy8gaW1tZWRpYXRlbHkgcmVkcmF3cyB0aGUgcGlja2VyLCBpZiBpdCdzIGRpc3BsYXllZFxyXG5cdFx0XHRcdHRoaXMuZXhwb3NlQ29sb3IoKTsgLy8gaW4gY2FzZSBzb21lIHByZXZpZXctcmVsYXRlZCBvciBmb3JtYXQtcmVsYXRlZCBvcHRpb24gd2FzIGNoYW5nZWRcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdC8vIHNldHRpbmcgbXVsdGlwbGUgb3B0aW9uc1xyXG5cdFx0XHRcdHZhciBvcHRzID0gYXJndW1lbnRzWzBdO1xyXG5cdFx0XHRcdHZhciBzdWNjZXNzID0gdHJ1ZTtcclxuXHRcdFx0XHRmb3IgKHZhciBvcHQgaW4gb3B0cykge1xyXG5cdFx0XHRcdFx0aWYgKG9wdHMuaGFzT3duUHJvcGVydHkob3B0KSkge1xyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghc2V0T3B0aW9uKG9wdCwgb3B0c1tvcHRdKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0c3VjY2VzcyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihlKTtcclxuXHRcdFx0XHRcdFx0XHRzdWNjZXNzID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTsgLy8gaW1tZWRpYXRlbHkgcmVkcmF3cyB0aGUgcGlja2VyLCBpZiBpdCdzIGRpc3BsYXllZFxyXG5cdFx0XHRcdHRoaXMuZXhwb3NlQ29sb3IoKTsgLy8gaW4gY2FzZSBzb21lIHByZXZpZXctcmVsYXRlZCBvciBmb3JtYXQtcmVsYXRlZCBvcHRpb24gd2FzIGNoYW5nZWRcclxuXHRcdFx0XHRyZXR1cm4gc3VjY2VzcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBHZXR0ZXI6IGNoYW5uZWwobmFtZSlcclxuXHRcdC8vIFNldHRlcjogY2hhbm5lbChuYW1lLCB2YWx1ZSlcclxuXHRcdC8vXHJcblx0XHR0aGlzLmNoYW5uZWwgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgY2hhbm5lbCBuYW1lOiAnICsgbmFtZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Ly8gZ2V0dGluZyBjaGFubmVsIHZhbHVlXHJcblx0XHRcdFx0aWYgKCF0aGlzLmNoYW5uZWxzLmhhc093blByb3BlcnR5KG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignR2V0dGluZyB1bmtub3duIGNoYW5uZWw6ICcgKyBuYW1lKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2hhbm5lbHNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gc2V0dGluZyBjaGFubmVsIHZhbHVlXHJcblx0XHRcdFx0dmFyIHJlcyA9IGZhbHNlO1xyXG5cdFx0XHRcdHN3aXRjaCAobmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcblx0XHRcdFx0XHRjYXNlICdyJzogcmVzID0gdGhpcy5mcm9tUkdCQSh2YWx1ZSwgbnVsbCwgbnVsbCwgbnVsbCk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnZyc6IHJlcyA9IHRoaXMuZnJvbVJHQkEobnVsbCwgdmFsdWUsIG51bGwsIG51bGwpOyBicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ2InOiByZXMgPSB0aGlzLmZyb21SR0JBKG51bGwsIG51bGwsIHZhbHVlLCBudWxsKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdoJzogcmVzID0gdGhpcy5mcm9tSFNWQSh2YWx1ZSwgbnVsbCwgbnVsbCwgbnVsbCk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAncyc6IHJlcyA9IHRoaXMuZnJvbUhTVkEobnVsbCwgdmFsdWUsIG51bGwsIG51bGwpOyBicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ3YnOiByZXMgPSB0aGlzLmZyb21IU1ZBKG51bGwsIG51bGwsIHZhbHVlLCBudWxsKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdhJzogcmVzID0gdGhpcy5mcm9tSFNWQShudWxsLCBudWxsLCBudWxsLCB2YWx1ZSk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdTZXR0aW5nIHVua25vd24gY2hhbm5lbDogJyArIG5hbWUpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChyZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7IC8vIGltbWVkaWF0ZWx5IHJlZHJhd3MgdGhlIHBpY2tlciwgaWYgaXQncyBkaXNwbGF5ZWRcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBUcmlnZ2VycyBnaXZlbiBpbnB1dCBldmVudChzKSBieTpcclxuXHRcdC8vIC0gZXhlY3V0aW5nIG9uPEV2ZW50PiBjYWxsYmFjayBzcGVjaWZpZWQgYXMgcGlja2VyJ3Mgb3B0aW9uXHJcblx0XHQvLyAtIHRyaWdnZXJpbmcgc3RhbmRhcmQgRE9NIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCB0byB0aGUgdmFsdWUgZWxlbWVudFxyXG5cdFx0Ly9cclxuXHRcdC8vIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCB3aXRoIGEgc3BhY2UuXHJcblx0XHQvL1xyXG5cdFx0dGhpcy50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50TmFtZXMpIHtcclxuXHRcdFx0dmFyIGV2cyA9IGpzYy5zdHJMaXN0KGV2ZW50TmFtZXMpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2cy5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0XHRcdHZhciBldiA9IGV2c1tpXS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0XHQvLyB0cmlnZ2VyIGEgY2FsbGJhY2tcclxuXHRcdFx0XHR2YXIgY2FsbGJhY2tQcm9wID0gbnVsbDtcclxuXHRcdFx0XHRzd2l0Y2ggKGV2KSB7XHJcblx0XHRcdFx0XHRjYXNlICdpbnB1dCc6IGNhbGxiYWNrUHJvcCA9ICdvbklucHV0JzsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdjaGFuZ2UnOiBjYWxsYmFja1Byb3AgPSAnb25DaGFuZ2UnOyBicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGNhbGxiYWNrUHJvcCkge1xyXG5cdFx0XHRcdFx0anNjLnRyaWdnZXJDYWxsYmFjayh0aGlzLCBjYWxsYmFja1Byb3ApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdHJpZ2dlciBzdGFuZGFyZCBET00gZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSB2YWx1ZSBlbGVtZW50XHJcblx0XHRcdFx0anNjLnRyaWdnZXJJbnB1dEV2ZW50KHRoaXMudmFsdWVFbGVtZW50LCBldiwgdHJ1ZSwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cclxuXHRcdC8vIGg6IDAtMzYwXHJcblx0XHQvLyBzOiAwLTEwMFxyXG5cdFx0Ly8gdjogMC0xMDBcclxuXHRcdC8vIGE6IDAuMC0xLjBcclxuXHRcdC8vXHJcblx0XHR0aGlzLmZyb21IU1ZBID0gZnVuY3Rpb24gKGgsIHMsIHYsIGEsIGZsYWdzKSB7IC8vIG51bGwgPSBkb24ndCBjaGFuZ2VcclxuXHRcdFx0aWYgKGggPT09IHVuZGVmaW5lZCkgeyBoID0gbnVsbDsgfVxyXG5cdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkKSB7IHMgPSBudWxsOyB9XHJcblx0XHRcdGlmICh2ID09PSB1bmRlZmluZWQpIHsgdiA9IG51bGw7IH1cclxuXHRcdFx0aWYgKGEgPT09IHVuZGVmaW5lZCkgeyBhID0gbnVsbDsgfVxyXG5cclxuXHRcdFx0aWYgKGggIT09IG51bGwpIHtcclxuXHRcdFx0XHRpZiAoaXNOYU4oaCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdFx0dGhpcy5jaGFubmVscy5oID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMzYwLCBoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHMgIT09IG51bGwpIHtcclxuXHRcdFx0XHRpZiAoaXNOYU4ocykpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdFx0dGhpcy5jaGFubmVscy5zID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCB0aGlzLm1heFMsIHMpLCB0aGlzLm1pblMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh2ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKGlzTmFOKHYpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRcdHRoaXMuY2hhbm5lbHMudiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgdGhpcy5tYXhWLCB2KSwgdGhpcy5taW5WKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoYSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdGlmIChpc05hTihhKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0XHR0aGlzLmNoYW5uZWxzLmEgPSB0aGlzLmhhc0FscGhhQ2hhbm5lbCgpID9cclxuXHRcdFx0XHRcdE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMubWF4QSwgYSksIHRoaXMubWluQSkgOlxyXG5cdFx0XHRcdFx0MS4wOyAvLyBpZiBhbHBoYSBjaGFubmVsIGlzIGRpc2FibGVkLCB0aGUgY29sb3Igc2hvdWxkIHN0YXkgMTAwJSBvcGFxdWVcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHJnYiA9IGpzYy5IU1ZfUkdCKFxyXG5cdFx0XHRcdHRoaXMuY2hhbm5lbHMuaCxcclxuXHRcdFx0XHR0aGlzLmNoYW5uZWxzLnMsXHJcblx0XHRcdFx0dGhpcy5jaGFubmVscy52XHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMuY2hhbm5lbHMuciA9IHJnYlswXTtcclxuXHRcdFx0dGhpcy5jaGFubmVscy5nID0gcmdiWzFdO1xyXG5cdFx0XHR0aGlzLmNoYW5uZWxzLmIgPSByZ2JbMl07XHJcblxyXG5cdFx0XHR0aGlzLmV4cG9zZUNvbG9yKGZsYWdzKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHQvLyByOiAwLTI1NVxyXG5cdFx0Ly8gZzogMC0yNTVcclxuXHRcdC8vIGI6IDAtMjU1XHJcblx0XHQvLyBhOiAwLjAtMS4wXHJcblx0XHQvL1xyXG5cdFx0dGhpcy5mcm9tUkdCQSA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhLCBmbGFncykgeyAvLyBudWxsID0gZG9uJ3QgY2hhbmdlXHJcblx0XHRcdGlmIChyID09PSB1bmRlZmluZWQpIHsgciA9IG51bGw7IH1cclxuXHRcdFx0aWYgKGcgPT09IHVuZGVmaW5lZCkgeyBnID0gbnVsbDsgfVxyXG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7IGIgPSBudWxsOyB9XHJcblx0XHRcdGlmIChhID09PSB1bmRlZmluZWQpIHsgYSA9IG51bGw7IH1cclxuXHJcblx0XHRcdGlmIChyICE9PSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKGlzTmFOKHIpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRcdHIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHIpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoZyAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdGlmIChpc05hTihnKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0XHRnID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBnKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGIgIT09IG51bGwpIHtcclxuXHRcdFx0XHRpZiAoaXNOYU4oYikpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdFx0YiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgYikpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChhICE9PSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKGlzTmFOKGEpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRcdHRoaXMuY2hhbm5lbHMuYSA9IHRoaXMuaGFzQWxwaGFDaGFubmVsKCkgP1xyXG5cdFx0XHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5tYXhBLCBhKSwgdGhpcy5taW5BKSA6XHJcblx0XHRcdFx0XHQxLjA7IC8vIGlmIGFscGhhIGNoYW5uZWwgaXMgZGlzYWJsZWQsIHRoZSBjb2xvciBzaG91bGQgc3RheSAxMDAlIG9wYXF1ZVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaHN2ID0ganNjLlJHQl9IU1YoXHJcblx0XHRcdFx0cj09PW51bGwgPyB0aGlzLmNoYW5uZWxzLnIgOiByLFxyXG5cdFx0XHRcdGc9PT1udWxsID8gdGhpcy5jaGFubmVscy5nIDogZyxcclxuXHRcdFx0XHRiPT09bnVsbCA/IHRoaXMuY2hhbm5lbHMuYiA6IGJcclxuXHRcdFx0KTtcclxuXHRcdFx0aWYgKGhzdlswXSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdHRoaXMuY2hhbm5lbHMuaCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDM2MCwgaHN2WzBdKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGhzdlsyXSAhPT0gMCkgeyAvLyBmdWxseSBibGFjayBjb2xvciBzdGF5cyBibGFjayB0aHJvdWdoIGVudGlyZSBzYXR1cmF0aW9uIHJhbmdlLCBzbyBsZXQncyBub3QgY2hhbmdlIHNhdHVyYXRpb25cclxuXHRcdFx0XHR0aGlzLmNoYW5uZWxzLnMgPSBNYXRoLm1heCgwLCB0aGlzLm1pblMsIE1hdGgubWluKDEwMCwgdGhpcy5tYXhTLCBoc3ZbMV0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmNoYW5uZWxzLnYgPSBNYXRoLm1heCgwLCB0aGlzLm1pblYsIE1hdGgubWluKDEwMCwgdGhpcy5tYXhWLCBoc3ZbMl0pKTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBSR0IgYWNjb3JkaW5nIHRvIGZpbmFsIEhTViwgYXMgc29tZSB2YWx1ZXMgbWlnaHQgYmUgdHJpbW1lZFxyXG5cdFx0XHR2YXIgcmdiID0ganNjLkhTVl9SR0IodGhpcy5jaGFubmVscy5oLCB0aGlzLmNoYW5uZWxzLnMsIHRoaXMuY2hhbm5lbHMudik7XHJcblx0XHRcdHRoaXMuY2hhbm5lbHMuciA9IHJnYlswXTtcclxuXHRcdFx0dGhpcy5jaGFubmVscy5nID0gcmdiWzFdO1xyXG5cdFx0XHR0aGlzLmNoYW5uZWxzLmIgPSByZ2JbMl07XHJcblxyXG5cdFx0XHR0aGlzLmV4cG9zZUNvbG9yKGZsYWdzKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHQvLyBERVBSRUNBVEVELiBVc2UgLmZyb21IU1ZBKCkgaW5zdGVhZFxyXG5cdFx0Ly9cclxuXHRcdHRoaXMuZnJvbUhTViA9IGZ1bmN0aW9uIChoLCBzLCB2LCBmbGFncykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ2Zyb21IU1YoKSBtZXRob2QgaXMgREVQUkVDQVRFRC4gVXNpbmcgZnJvbUhTVkEoKSBpbnN0ZWFkLicgKyBqc2MuZG9jc1JlZik7XHJcblx0XHRcdHJldHVybiB0aGlzLmZyb21IU1ZBKGgsIHMsIHYsIG51bGwsIGZsYWdzKTtcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdC8vIERFUFJFQ0FURUQuIFVzZSAuZnJvbVJHQkEoKSBpbnN0ZWFkXHJcblx0XHQvL1xyXG5cdFx0dGhpcy5mcm9tUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIGZsYWdzKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignZnJvbVJHQigpIG1ldGhvZCBpcyBERVBSRUNBVEVELiBVc2luZyBmcm9tUkdCQSgpIGluc3RlYWQuJyArIGpzYy5kb2NzUmVmKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbVJHQkEociwgZywgYiwgbnVsbCwgZmxhZ3MpO1xyXG5cdFx0fTtcclxuXHJcblxyXG5cdFx0dGhpcy5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0ciwgZmxhZ3MpIHtcclxuXHRcdFx0aWYgKCF0aGlzLnJlcXVpcmVkICYmIHN0ci50cmltKCkgPT09ICcnKSB7XHJcblx0XHRcdFx0Ly8gc2V0dGluZyBlbXB0eSBzdHJpbmcgdG8gYW4gb3B0aW9uYWwgY29sb3IgaW5wdXRcclxuXHRcdFx0XHR0aGlzLnNldFByZXZpZXdFbGVtZW50QmcobnVsbCk7XHJcblx0XHRcdFx0dGhpcy5zZXRWYWx1ZUVsZW1lbnRWYWx1ZSgnJyk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBjb2xvciA9IGpzYy5wYXJzZUNvbG9yU3RyaW5nKHN0cik7XHJcblx0XHRcdGlmICghY29sb3IpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGNvdWxkIG5vdCBwYXJzZVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLmZvcm1hdC50b0xvd2VyQ2FzZSgpID09PSAnYW55Jykge1xyXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRGb3JtYXQgPSBjb2xvci5mb3JtYXQ7IC8vIGFkYXB0IGZvcm1hdFxyXG5cdFx0XHRcdGlmICh0aGlzLmdldEZvcm1hdCgpICE9PSAncmdiYScpIHtcclxuXHRcdFx0XHRcdGNvbG9yLnJnYmFbM10gPSAxLjA7IC8vIHdoZW4gc3dpdGNoaW5nIHRvIGEgZm9ybWF0IHRoYXQgZG9lc24ndCBzdXBwb3J0IGFscGhhLCBzZXQgZnVsbCBvcGFjaXR5XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMucmVkcmF3KCk7IC8vIHRvIHNob3cvaGlkZSB0aGUgYWxwaGEgc2xpZGVyIGFjY29yZGluZyB0byBjdXJyZW50IGZvcm1hdFxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZnJvbVJHQkEoXHJcblx0XHRcdFx0Y29sb3IucmdiYVswXSxcclxuXHRcdFx0XHRjb2xvci5yZ2JhWzFdLFxyXG5cdFx0XHRcdGNvbG9yLnJnYmFbMl0sXHJcblx0XHRcdFx0Y29sb3IucmdiYVszXSxcclxuXHRcdFx0XHRmbGFnc1xyXG5cdFx0XHQpO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcblx0XHRcdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGZvcm1hdCA9IHRoaXMuZ2V0Rm9ybWF0KCk7IC8vIGZvcm1hdCBub3Qgc3BlY2lmaWVkIC0+IHVzZSB0aGUgY3VycmVudCBmb3JtYXRcclxuXHRcdFx0fVxyXG5cdFx0XHRzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcblx0XHRcdFx0Y2FzZSAnaGV4JzogcmV0dXJuIHRoaXMudG9IRVhTdHJpbmcoKTsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAncmdiJzogcmV0dXJuIHRoaXMudG9SR0JTdHJpbmcoKTsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAncmdiYSc6IHJldHVybiB0aGlzLnRvUkdCQVN0cmluZygpOyBicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLnRvSEVYU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gJyMnICsgKFxyXG5cdFx0XHRcdCgnMCcgKyBNYXRoLnJvdW5kKHRoaXMuY2hhbm5lbHMucikudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpICtcclxuXHRcdFx0XHQoJzAnICsgTWF0aC5yb3VuZCh0aGlzLmNoYW5uZWxzLmcpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yKSArXHJcblx0XHRcdFx0KCcwJyArIE1hdGgucm91bmQodGhpcy5jaGFubmVscy5iKS50b1N0cmluZygxNikpLnN1YnN0cigtMilcclxuXHRcdFx0KS50b1VwcGVyQ2FzZSgpO1xyXG5cdFx0fTtcclxuXHJcblxyXG5cdFx0dGhpcy50b1JHQlN0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuICgncmdiKCcgK1xyXG5cdFx0XHRcdE1hdGgucm91bmQodGhpcy5jaGFubmVscy5yKSArICcsJyArXHJcblx0XHRcdFx0TWF0aC5yb3VuZCh0aGlzLmNoYW5uZWxzLmcpICsgJywnICtcclxuXHRcdFx0XHRNYXRoLnJvdW5kKHRoaXMuY2hhbm5lbHMuYikgK1xyXG5cdFx0XHQnKScpO1xyXG5cdFx0fTtcclxuXHJcblxyXG5cdFx0dGhpcy50b1JHQkFTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiAoJ3JnYmEoJyArXHJcblx0XHRcdFx0TWF0aC5yb3VuZCh0aGlzLmNoYW5uZWxzLnIpICsgJywnICtcclxuXHRcdFx0XHRNYXRoLnJvdW5kKHRoaXMuY2hhbm5lbHMuZykgKyAnLCcgK1xyXG5cdFx0XHRcdE1hdGgucm91bmQodGhpcy5jaGFubmVscy5iKSArICcsJyArXHJcblx0XHRcdFx0KE1hdGgucm91bmQodGhpcy5jaGFubmVscy5hICogMTAwKSAvIDEwMCkgK1xyXG5cdFx0XHQnKScpO1xyXG5cdFx0fTtcclxuXHJcblxyXG5cdFx0dGhpcy50b0dyYXlzY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHQwLjIxMyAqIHRoaXMuY2hhbm5lbHMuciArXHJcblx0XHRcdFx0MC43MTUgKiB0aGlzLmNoYW5uZWxzLmcgK1xyXG5cdFx0XHRcdDAuMDcyICogdGhpcy5jaGFubmVscy5iXHJcblx0XHRcdCk7XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLnRvQ2FudmFzID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4ganNjLmdlbkNvbG9yUHJldmlld0NhbnZhcyh0aGlzLnRvUkdCQVN0cmluZygpKS5jYW52YXM7XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9DYW52YXMoKS50b0RhdGFVUkwoKTtcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdHRoaXMudG9CYWNrZ3JvdW5kID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4ganNjLnB1Yi5iYWNrZ3JvdW5kKHRoaXMudG9SR0JBU3RyaW5nKCkpO1xyXG5cdFx0fTtcclxuXHJcblxyXG5cdFx0dGhpcy5pc0xpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b0dyYXlzY2FsZSgpID4gMjU1IC8gMjtcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKGlzUGlja2VyT3duZXIoKSkge1xyXG5cdFx0XHRcdGRldGFjaFBpY2tlcigpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGRyYXdQaWNrZXIoKTtcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdHRoaXMucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoaXNQaWNrZXJPd25lcigpKSB7XHJcblx0XHRcdFx0ZHJhd1BpY2tlcigpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLmdldEZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRGb3JtYXQ7XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLmhhc0FscGhhQ2hhbm5lbCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuYWxwaGFDaGFubmVsID09PSAnYXV0bycpIHtcclxuXHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0dGhpcy5mb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gJ2FueScgfHwgLy8gZm9ybWF0IGNhbiBjaGFuZ2Ugb24gdGhlIGZseSAoZS5nLiBmcm9tIGhleCB0byByZ2JhKSwgc28gbGV0J3MgY29uc2lkZXIgdGhlIGFscGhhIGNoYW5uZWwgZW5hYmxlZFxyXG5cdFx0XHRcdFx0dGhpcy5nZXRGb3JtYXQoKSA9PT0gJ3JnYmEnIHx8IC8vIHRoZSBjdXJyZW50IGZvcm1hdCBzdXBwb3J0cyBhbHBoYSBjaGFubmVsXHJcblx0XHRcdFx0XHR0aGlzLmFscGhhICE9PSB1bmRlZmluZWQgfHwgLy8gaW5pdGlhbCBhbHBoYSB2YWx1ZSBpcyBzZXQsIHNvIHdlJ3JlIHdvcmtpbmcgd2l0aCBhbHBoYSBjaGFubmVsXHJcblx0XHRcdFx0XHR0aGlzLmFscGhhRWxlbWVudCAhPT0gdW5kZWZpbmVkIC8vIHRoZSBhbHBoYSB2YWx1ZSBpcyByZWRpcmVjdGVkLCBzbyB3ZSdyZSB3b3JraW5nIHdpdGggYWxwaGEgY2hhbm5lbFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmFscGhhQ2hhbm5lbDsgLy8gdGhlIGFscGhhIGNoYW5uZWwgaXMgZXhwbGljaXRseSBzZXRcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdHRoaXMucHJvY2Vzc1ZhbHVlSW5wdXQgPSBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRcdGlmICghdGhpcy5mcm9tU3RyaW5nKHN0cikpIHtcclxuXHRcdFx0XHQvLyBjb3VsZCBub3QgcGFyc2UgdGhlIGNvbG9yIHZhbHVlIC0gbGV0J3MganVzdCBleHBvc2UgdGhlIGN1cnJlbnQgY29sb3JcclxuXHRcdFx0XHR0aGlzLmV4cG9zZUNvbG9yKCk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cclxuXHRcdHRoaXMucHJvY2Vzc0FscGhhSW5wdXQgPSBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRcdGlmICghdGhpcy5mcm9tSFNWQShudWxsLCBudWxsLCBudWxsLCBwYXJzZUZsb2F0KHN0cikpKSB7XHJcblx0XHRcdFx0Ly8gY291bGQgbm90IHBhcnNlIHRoZSBhbHBoYSB2YWx1ZSAtIGxldCdzIGp1c3QgZXhwb3NlIHRoZSBjdXJyZW50IGNvbG9yXHJcblx0XHRcdFx0dGhpcy5leHBvc2VDb2xvcigpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLmV4cG9zZUNvbG9yID0gZnVuY3Rpb24gKGZsYWdzKSB7XHJcblxyXG5cdFx0XHRpZiAoIShmbGFncyAmIGpzYy5mbGFncy5sZWF2ZVZhbHVlKSAmJiB0aGlzLnZhbHVlRWxlbWVudCkge1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuZ2V0Rm9ybWF0KCkgPT09ICdoZXgnKSB7XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMudXBwZXJjYXNlKSB7IHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTsgfVxyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmhhc2gpIHsgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eIy8sICcnKTsgfVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5zZXRWYWx1ZUVsZW1lbnRWYWx1ZSh2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghKGZsYWdzICYganNjLmZsYWdzLmxlYXZlQWxwaGEpICYmIHRoaXMuYWxwaGFFbGVtZW50KSB7XHJcblx0XHRcdFx0dmFyIHZhbHVlID0gTWF0aC5yb3VuZCh0aGlzLmNoYW5uZWxzLmEgKiAxMDApIC8gMTAwO1xyXG5cdFx0XHRcdHRoaXMuc2V0QWxwaGFFbGVtZW50VmFsdWUodmFsdWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIShmbGFncyAmIGpzYy5mbGFncy5sZWF2ZVByZXZpZXcpICYmIHRoaXMucHJldmlld0VsZW1lbnQpIHtcclxuXHRcdFx0XHR2YXIgcHJldmlld1BvcyA9IG51bGw7IC8vICdsZWZ0JyB8ICdyaWdodCcgKG51bGwgLT4gZmlsbCB0aGUgZW50aXJlIGVsZW1lbnQpXHJcblxyXG5cdFx0XHRcdGlmIChcclxuXHRcdFx0XHRcdGpzYy5pc1RleHRJbnB1dCh0aGlzLnByZXZpZXdFbGVtZW50KSB8fCAvLyB0ZXh0IGlucHV0XHJcblx0XHRcdFx0XHQoanNjLmlzQnV0dG9uKHRoaXMucHJldmlld0VsZW1lbnQpICYmICFqc2MuaXNCdXR0b25FbXB0eSh0aGlzLnByZXZpZXdFbGVtZW50KSkgLy8gYnV0dG9uIHdpdGggdGV4dFxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0cHJldmlld1BvcyA9IHRoaXMucHJldmlld1Bvc2l0aW9uO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5zZXRQcmV2aWV3RWxlbWVudEJnKHRoaXMudG9SR0JBU3RyaW5nKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaXNQaWNrZXJPd25lcigpKSB7XHJcblx0XHRcdFx0cmVkcmF3UGFkKCk7XHJcblx0XHRcdFx0cmVkcmF3U2xkKCk7XHJcblx0XHRcdFx0cmVkcmF3QVNsZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLnNldFByZXZpZXdFbGVtZW50QmcgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuXHRcdFx0aWYgKCF0aGlzLnByZXZpZXdFbGVtZW50KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBudWxsOyAvLyBjb2xvciBwcmV2aWV3IHBvc2l0aW9uOiAgbnVsbCB8ICdsZWZ0JyB8ICdyaWdodCdcclxuXHRcdFx0dmFyIHdpZHRoID0gbnVsbDsgLy8gY29sb3IgcHJldmlldyB3aWR0aDogIHB4IHwgbnVsbCA9IGZpbGwgdGhlIGVudGlyZSBlbGVtZW50XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRqc2MuaXNUZXh0SW5wdXQodGhpcy5wcmV2aWV3RWxlbWVudCkgfHwgLy8gdGV4dCBpbnB1dFxyXG5cdFx0XHRcdChqc2MuaXNCdXR0b24odGhpcy5wcmV2aWV3RWxlbWVudCkgJiYgIWpzYy5pc0J1dHRvbkVtcHR5KHRoaXMucHJldmlld0VsZW1lbnQpKSAvLyBidXR0b24gd2l0aCB0ZXh0XHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5wcmV2aWV3UG9zaXRpb247XHJcblx0XHRcdFx0d2lkdGggPSB0aGlzLnByZXZpZXdTaXplO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYmFja2dyb3VuZHMgPSBbXTtcclxuXHJcblx0XHRcdGlmICghY29sb3IpIHtcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBjb2xvciBwcmV2aWV3IHRvIGRpc3BsYXkgLT4gbGV0J3MgcmVtb3ZlIGFueSBwcmV2aW91cyBiYWNrZ3JvdW5kIGltYWdlXHJcblx0XHRcdFx0YmFja2dyb3VuZHMucHVzaCh7XHJcblx0XHRcdFx0XHRpbWFnZTogJ25vbmUnLFxyXG5cdFx0XHRcdFx0cG9zaXRpb246ICdsZWZ0IHRvcCcsXHJcblx0XHRcdFx0XHRzaXplOiAnYXV0bycsXHJcblx0XHRcdFx0XHRyZXBlYXQ6ICduby1yZXBlYXQnLFxyXG5cdFx0XHRcdFx0b3JpZ2luOiAncGFkZGluZy1ib3gnLFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIENTUyBncmFkaWVudCBmb3IgYmFja2dyb3VuZCBjb2xvciBwcmV2aWV3XHJcblx0XHRcdFx0YmFja2dyb3VuZHMucHVzaCh7XHJcblx0XHRcdFx0XHRpbWFnZToganNjLmdlbkNvbG9yUHJldmlld0dyYWRpZW50KFxyXG5cdFx0XHRcdFx0XHRjb2xvcixcclxuXHRcdFx0XHRcdFx0cG9zaXRpb24sXHJcblx0XHRcdFx0XHRcdHdpZHRoID8gd2lkdGggLSBqc2MucHViLnByZXZpZXdTZXBhcmF0b3IubGVuZ3RoIDogbnVsbFxyXG5cdFx0XHRcdFx0KSxcclxuXHRcdFx0XHRcdHBvc2l0aW9uOiAnbGVmdCB0b3AnLFxyXG5cdFx0XHRcdFx0c2l6ZTogJ2F1dG8nLFxyXG5cdFx0XHRcdFx0cmVwZWF0OiBwb3NpdGlvbiA/ICdyZXBlYXQteScgOiAncmVwZWF0JyxcclxuXHRcdFx0XHRcdG9yaWdpbjogJ3BhZGRpbmctYm94JyxcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Ly8gZGF0YSBVUkwgb2YgZ2VuZXJhdGVkIFBORyBpbWFnZSB3aXRoIGEgZ3JheSB0cmFuc3BhcmVuY3kgY2hlc3Nib2FyZFxyXG5cdFx0XHRcdHZhciBwcmV2aWV3ID0ganNjLmdlbkNvbG9yUHJldmlld0NhbnZhcyhcclxuXHRcdFx0XHRcdCdyZ2JhKDAsMCwwLDApJyxcclxuXHRcdFx0XHRcdHBvc2l0aW9uID8geydsZWZ0JzoncmlnaHQnLCAncmlnaHQnOidsZWZ0J31bcG9zaXRpb25dIDogbnVsbCxcclxuXHRcdFx0XHRcdHdpZHRoLFxyXG5cdFx0XHRcdFx0dHJ1ZVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0YmFja2dyb3VuZHMucHVzaCh7XHJcblx0XHRcdFx0XHRpbWFnZTogJ3VybChcXCcnICsgcHJldmlldy5jYW52YXMudG9EYXRhVVJMKCkgKyAnXFwnKScsXHJcblx0XHRcdFx0XHRwb3NpdGlvbjogKHBvc2l0aW9uIHx8ICdsZWZ0JykgKyAnIHRvcCcsXHJcblx0XHRcdFx0XHRzaXplOiBwcmV2aWV3LndpZHRoICsgJ3B4ICcgKyBwcmV2aWV3LmhlaWdodCArICdweCcsXHJcblx0XHRcdFx0XHRyZXBlYXQ6IHBvc2l0aW9uID8gJ3JlcGVhdC15JyA6ICdyZXBlYXQnLFxyXG5cdFx0XHRcdFx0b3JpZ2luOiAncGFkZGluZy1ib3gnLFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYmcgPSB7XHJcblx0XHRcdFx0aW1hZ2U6IFtdLFxyXG5cdFx0XHRcdHBvc2l0aW9uOiBbXSxcclxuXHRcdFx0XHRzaXplOiBbXSxcclxuXHRcdFx0XHRyZXBlYXQ6IFtdLFxyXG5cdFx0XHRcdG9yaWdpbjogW10sXHJcblx0XHRcdH07XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYmFja2dyb3VuZHMubGVuZ3RoOyBpICs9IDEpIHtcclxuXHRcdFx0XHRiZy5pbWFnZS5wdXNoKGJhY2tncm91bmRzW2ldLmltYWdlKTtcclxuXHRcdFx0XHRiZy5wb3NpdGlvbi5wdXNoKGJhY2tncm91bmRzW2ldLnBvc2l0aW9uKTtcclxuXHRcdFx0XHRiZy5zaXplLnB1c2goYmFja2dyb3VuZHNbaV0uc2l6ZSk7XHJcblx0XHRcdFx0YmcucmVwZWF0LnB1c2goYmFja2dyb3VuZHNbaV0ucmVwZWF0KTtcclxuXHRcdFx0XHRiZy5vcmlnaW4ucHVzaChiYWNrZ3JvdW5kc1tpXS5vcmlnaW4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZXQgcHJldmlld0VsZW1lbnQncyBiYWNrZ3JvdW5kLWltYWdlc1xyXG5cdFx0XHR2YXIgc3R5ID0ge1xyXG5cdFx0XHRcdCdiYWNrZ3JvdW5kLWltYWdlJzogYmcuaW1hZ2Uuam9pbignLCAnKSxcclxuXHRcdFx0XHQnYmFja2dyb3VuZC1wb3NpdGlvbic6IGJnLnBvc2l0aW9uLmpvaW4oJywgJyksXHJcblx0XHRcdFx0J2JhY2tncm91bmQtc2l6ZSc6IGJnLnNpemUuam9pbignLCAnKSxcclxuXHRcdFx0XHQnYmFja2dyb3VuZC1yZXBlYXQnOiBiZy5yZXBlYXQuam9pbignLCAnKSxcclxuXHRcdFx0XHQnYmFja2dyb3VuZC1vcmlnaW4nOiBiZy5vcmlnaW4uam9pbignLCAnKSxcclxuXHRcdFx0fTtcclxuXHRcdFx0anNjLnNldFN0eWxlKHRoaXMucHJldmlld0VsZW1lbnQsIHN0eSwgdGhpcy5mb3JjZVN0eWxlKTtcclxuXHJcblxyXG5cdFx0XHQvLyBzZXQvcmVzdG9yZSBwcmV2aWV3RWxlbWVudCdzIHBhZGRpbmdcclxuXHRcdFx0dmFyIHBhZGRpbmcgPSB7XHJcblx0XHRcdFx0bGVmdDogbnVsbCxcclxuXHRcdFx0XHRyaWdodDogbnVsbCxcclxuXHRcdFx0fTtcclxuXHRcdFx0aWYgKHBvc2l0aW9uKSB7XHJcblx0XHRcdFx0cGFkZGluZ1twb3NpdGlvbl0gPSAodGhpcy5wcmV2aWV3U2l6ZSArIHRoaXMucHJldmlld1BhZGRpbmcpICsgJ3B4JztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHN0eSA9IHtcclxuXHRcdFx0XHQncGFkZGluZy1sZWZ0JzogcGFkZGluZy5sZWZ0LFxyXG5cdFx0XHRcdCdwYWRkaW5nLXJpZ2h0JzogcGFkZGluZy5yaWdodCxcclxuXHRcdFx0fTtcclxuXHRcdFx0anNjLnNldFN0eWxlKHRoaXMucHJldmlld0VsZW1lbnQsIHN0eSwgdGhpcy5mb3JjZVN0eWxlLCB0cnVlKTtcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVFbGVtZW50VmFsdWUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRcdGlmICh0aGlzLnZhbHVlRWxlbWVudCkge1xyXG5cdFx0XHRcdGlmIChqc2Mubm9kZU5hbWUodGhpcy52YWx1ZUVsZW1lbnQpID09PSAnaW5wdXQnKSB7XHJcblx0XHRcdFx0XHR0aGlzLnZhbHVlRWxlbWVudC52YWx1ZSA9IHN0cjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy52YWx1ZUVsZW1lbnQuaW5uZXJIVE1MID0gc3RyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblxyXG5cdFx0dGhpcy5zZXRBbHBoYUVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRcdFx0aWYgKHRoaXMuYWxwaGFFbGVtZW50KSB7XHJcblx0XHRcdFx0aWYgKGpzYy5ub2RlTmFtZSh0aGlzLmFscGhhRWxlbWVudCkgPT09ICdpbnB1dCcpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWxwaGFFbGVtZW50LnZhbHVlID0gc3RyO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLmFscGhhRWxlbWVudC5pbm5lckhUTUwgPSBzdHI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHR0aGlzLl9wcm9jZXNzUGFyZW50RWxlbWVudHNJbkRPTSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2xpbmtlZEVsZW1lbnRzUHJvY2Vzc2VkKSB7IHJldHVybjsgfVxyXG5cdFx0XHR0aGlzLl9saW5rZWRFbGVtZW50c1Byb2Nlc3NlZCA9IHRydWU7XHJcblxyXG5cdFx0XHR2YXIgZWxtID0gdGhpcy50YXJnZXRFbGVtZW50O1xyXG5cdFx0XHRkbyB7XHJcblx0XHRcdFx0Ly8gSWYgdGhlIHRhcmdldCBlbGVtZW50IG9yIG9uZSBvZiBpdHMgcGFyZW50IG5vZGVzIGhhcyBmaXhlZCBwb3NpdGlvbixcclxuXHRcdFx0XHQvLyB0aGVuIHVzZSBmaXhlZCBwb3NpdGlvbmluZyBpbnN0ZWFkXHJcblx0XHRcdFx0dmFyIGNvbXBTdHlsZSA9IGpzYy5nZXRDb21wU3R5bGUoZWxtKTtcclxuXHRcdFx0XHRpZiAoY29tcFN0eWxlLnBvc2l0aW9uICYmIGNvbXBTdHlsZS5wb3NpdGlvbi50b0xvd2VyQ2FzZSgpID09PSAnZml4ZWQnKSB7XHJcblx0XHRcdFx0XHR0aGlzLmZpeGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChlbG0gIT09IHRoaXMudGFyZ2V0RWxlbWVudCkge1xyXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHRvIGF0dGFjaCBvblBhcmVudFNjcm9sbCBvbmx5IG9uY2UgdG8gZWFjaCBwYXJlbnQgZWxlbWVudFxyXG5cdFx0XHRcdFx0Ly8gKG11bHRpcGxlIHRhcmdldEVsZW1lbnRzIGNhbiBzaGFyZSB0aGUgc2FtZSBwYXJlbnQgbm9kZXMpXHJcblx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0Ly8gTm90ZTogSXQncyBub3QganVzdCBvZmZzZXRQYXJlbnRzIHRoYXQgY2FuIGJlIHNjcm9sbGFibGUsXHJcblx0XHRcdFx0XHQvLyB0aGF0J3Mgd2h5IHdlIGxvb3AgdGhyb3VnaCBhbGwgcGFyZW50IG5vZGVzXHJcblx0XHRcdFx0XHRpZiAoIWpzYy5nZXREYXRhKGVsbSwgJ2hhc1Njcm9sbExpc3RlbmVyJykpIHtcclxuXHRcdFx0XHRcdFx0ZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGpzYy5vblBhcmVudFNjcm9sbCwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHRqc2Muc2V0RGF0YShlbG0sICdoYXNTY3JvbGxMaXN0ZW5lcicsIHRydWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSB3aGlsZSAoKGVsbSA9IGVsbS5wYXJlbnROb2RlKSAmJiBqc2Mubm9kZU5hbWUoZWxtKSAhPT0gJ2JvZHknKTtcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdHRoaXMudHJ5SGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHRoaXMuaGlkZU9uTGVhdmUpIHtcclxuXHRcdFx0XHR0aGlzLmhpZGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gc2V0T3B0aW9uIChvcHRpb24sIHZhbHVlKSB7XHJcblx0XHRcdGlmICh0eXBlb2Ygb3B0aW9uICE9PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIG5hbWU6ICcgKyBvcHRpb24pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBlbnVtIG9wdGlvblxyXG5cdFx0XHRpZiAoanNjLmVudW1PcHRzLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcclxuXHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgeyAvLyBlbnVtIHN0cmluZyB2YWx1ZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmVcclxuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGpzYy5lbnVtT3B0c1tvcHRpb25dLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcHRpb24gXFwnJyArIG9wdGlvbiArICdcXCcgaGFzIGludmFsaWQgdmFsdWU6ICcgKyB2YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBkZXByZWNhdGVkIG9wdGlvblxyXG5cdFx0XHRpZiAoanNjLmRlcHJlY2F0ZWRPcHRzLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcclxuXHRcdFx0XHR2YXIgb2xkT3B0ID0gb3B0aW9uO1xyXG5cdFx0XHRcdHZhciBuZXdPcHQgPSBqc2MuZGVwcmVjYXRlZE9wdHNbb3B0aW9uXTtcclxuXHRcdFx0XHRpZiAobmV3T3B0KSB7XHJcblx0XHRcdFx0XHQvLyBpZiB3ZSBoYXZlIGEgbmV3IG5hbWUgZm9yIHRoaXMgb3B0aW9uLCBsZXQncyBsb2cgYSB3YXJuaW5nIGFuZCB1c2UgdGhlIG5ldyBuYW1lXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ09wdGlvbiBcXCclc1xcJyBpcyBERVBSRUNBVEVELCB1c2luZyBcXCclc1xcJyBpbnN0ZWFkLicgKyBqc2MuZG9jc1JlZiwgb2xkT3B0LCBuZXdPcHQpO1xyXG5cdFx0XHRcdFx0b3B0aW9uID0gbmV3T3B0O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBuZXcgbmFtZSBub3QgYXZhaWxhYmxlIGZvciB0aGUgb3B0aW9uXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBcXCcnICsgb3B0aW9uICsgJ1xcJyBpcyBERVBSRUNBVEVEJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIShvcHRpb24gaW4gVEhJUykpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBjb25maWd1cmF0aW9uIG9wdGlvbjogJyArIG9wdGlvbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdFRISVNbb3B0aW9uXSA9IHZhbHVlO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0T3B0aW9uIChvcHRpb24pIHtcclxuXHRcdFx0Ly8gZGVwcmVjYXRlZCBvcHRpb25cclxuXHRcdFx0aWYgKGpzYy5kZXByZWNhdGVkT3B0cy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XHJcblx0XHRcdFx0dmFyIG9sZE9wdCA9IG9wdGlvbjtcclxuXHRcdFx0XHR2YXIgbmV3T3B0ID0ganNjLmRlcHJlY2F0ZWRPcHRzW29wdGlvbl07XHJcblx0XHRcdFx0aWYgKG5ld09wdCkge1xyXG5cdFx0XHRcdFx0Ly8gaWYgd2UgaGF2ZSBhIG5ldyBuYW1lIGZvciB0aGlzIG9wdGlvbiwgbGV0J3MgbG9nIGEgd2FybmluZyBhbmQgdXNlIHRoZSBuZXcgbmFtZVxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdPcHRpb24gXFwnJXNcXCcgaXMgREVQUkVDQVRFRCwgdXNpbmcgXFwnJXNcXCcgaW5zdGVhZC4nICsganNjLmRvY3NSZWYsIG9sZE9wdCwgbmV3T3B0KTtcclxuXHRcdFx0XHRcdG9wdGlvbiA9IG5ld09wdDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gbmV3IG5hbWUgbm90IGF2YWlsYWJsZSBmb3IgdGhlIG9wdGlvblxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcHRpb24gXFwnJyArIG9wdGlvbiArICdcXCcgaXMgREVQUkVDQVRFRCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCEob3B0aW9uIGluIFRISVMpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgY29uZmlndXJhdGlvbiBvcHRpb246ICcgKyBvcHRpb24pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gVEhJU1tvcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBkZXRhY2hQaWNrZXIgKCkge1xyXG5cdFx0XHRqc2MucmVtb3ZlQ2xhc3MoVEhJUy50YXJnZXRFbGVtZW50LCBqc2MucHViLmFjdGl2ZUNsYXNzTmFtZSk7XHJcblx0XHRcdGpzYy5waWNrZXIud3JhcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGpzYy5waWNrZXIud3JhcCk7XHJcblx0XHRcdGRlbGV0ZSBqc2MucGlja2VyLm93bmVyO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBkcmF3UGlja2VyICgpIHtcclxuXHJcblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdoZW4gZHJhd2luZyB0aGUgcGlja2VyLCB3ZSBrbm93IHdoYXQgdGhlIHBhcmVudCBlbGVtZW50cyBhcmVcclxuXHRcdFx0Ly8gYW5kIHdlIGNhbiBkbyBhbGwgcmVsYXRlZCBET00gb3BlcmF0aW9ucywgc3VjaCBhcyByZWdpc3RlcmluZyBldmVudHMgb24gdGhlbVxyXG5cdFx0XHQvLyBvciBjaGVja2luZyB0aGVpciBwb3NpdGlvbmluZ1xyXG5cdFx0XHRUSElTLl9wcm9jZXNzUGFyZW50RWxlbWVudHNJbkRPTSgpO1xyXG5cclxuXHRcdFx0aWYgKCFqc2MucGlja2VyKSB7XHJcblx0XHRcdFx0anNjLnBpY2tlciA9IHtcclxuXHRcdFx0XHRcdG93bmVyOiBudWxsLCAvLyBvd25lciBwaWNrZXIgaW5zdGFuY2VcclxuXHRcdFx0XHRcdHdyYXAgOiBqc2MuY3JlYXRlRWwoJ2RpdicpLFxyXG5cdFx0XHRcdFx0Ym94IDoganNjLmNyZWF0ZUVsKCdkaXYnKSxcclxuXHRcdFx0XHRcdGJveFMgOiBqc2MuY3JlYXRlRWwoJ2RpdicpLCAvLyBzaGFkb3cgYXJlYVxyXG5cdFx0XHRcdFx0Ym94QiA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIGJvcmRlclxyXG5cdFx0XHRcdFx0cGFkIDoganNjLmNyZWF0ZUVsKCdkaXYnKSxcclxuXHRcdFx0XHRcdHBhZEIgOiBqc2MuY3JlYXRlRWwoJ2RpdicpLCAvLyBib3JkZXJcclxuXHRcdFx0XHRcdHBhZE0gOiBqc2MuY3JlYXRlRWwoJ2RpdicpLCAvLyBtb3VzZS90b3VjaCBhcmVhXHJcblx0XHRcdFx0XHRwYWRQYWwgOiBqc2MuY3JlYXRlUGFsZXR0ZSgpLFxyXG5cdFx0XHRcdFx0Y3Jvc3MgOiBqc2MuY3JlYXRlRWwoJ2RpdicpLFxyXG5cdFx0XHRcdFx0Y3Jvc3NCWSA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIGJvcmRlciBZXHJcblx0XHRcdFx0XHRjcm9zc0JYIDoganNjLmNyZWF0ZUVsKCdkaXYnKSwgLy8gYm9yZGVyIFhcclxuXHRcdFx0XHRcdGNyb3NzTFkgOiBqc2MuY3JlYXRlRWwoJ2RpdicpLCAvLyBsaW5lIFlcclxuXHRcdFx0XHRcdGNyb3NzTFggOiBqc2MuY3JlYXRlRWwoJ2RpdicpLCAvLyBsaW5lIFhcclxuXHRcdFx0XHRcdHNsZCA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIHNsaWRlclxyXG5cdFx0XHRcdFx0c2xkQiA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIGJvcmRlclxyXG5cdFx0XHRcdFx0c2xkTSA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIG1vdXNlL3RvdWNoIGFyZWFcclxuXHRcdFx0XHRcdHNsZEdyYWQgOiBqc2MuY3JlYXRlU2xpZGVyR3JhZGllbnQoKSxcclxuXHRcdFx0XHRcdHNsZFB0clMgOiBqc2MuY3JlYXRlRWwoJ2RpdicpLCAvLyBzbGlkZXIgcG9pbnRlciBzcGFjZXJcclxuXHRcdFx0XHRcdHNsZFB0cklCIDoganNjLmNyZWF0ZUVsKCdkaXYnKSwgLy8gc2xpZGVyIHBvaW50ZXIgaW5uZXIgYm9yZGVyXHJcblx0XHRcdFx0XHRzbGRQdHJNQiA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIHNsaWRlciBwb2ludGVyIG1pZGRsZSBib3JkZXJcclxuXHRcdFx0XHRcdHNsZFB0ck9CIDoganNjLmNyZWF0ZUVsKCdkaXYnKSwgLy8gc2xpZGVyIHBvaW50ZXIgb3V0ZXIgYm9yZGVyXHJcblx0XHRcdFx0XHRhc2xkIDoganNjLmNyZWF0ZUVsKCdkaXYnKSwgLy8gYWxwaGEgc2xpZGVyXHJcblx0XHRcdFx0XHRhc2xkQiA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIGJvcmRlclxyXG5cdFx0XHRcdFx0YXNsZE0gOiBqc2MuY3JlYXRlRWwoJ2RpdicpLCAvLyBtb3VzZS90b3VjaCBhcmVhXHJcblx0XHRcdFx0XHRhc2xkR3JhZCA6IGpzYy5jcmVhdGVBU2xpZGVyR3JhZGllbnQoKSxcclxuXHRcdFx0XHRcdGFzbGRQdHJTIDoganNjLmNyZWF0ZUVsKCdkaXYnKSwgLy8gc2xpZGVyIHBvaW50ZXIgc3BhY2VyXHJcblx0XHRcdFx0XHRhc2xkUHRySUIgOiBqc2MuY3JlYXRlRWwoJ2RpdicpLCAvLyBzbGlkZXIgcG9pbnRlciBpbm5lciBib3JkZXJcclxuXHRcdFx0XHRcdGFzbGRQdHJNQiA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIHNsaWRlciBwb2ludGVyIG1pZGRsZSBib3JkZXJcclxuXHRcdFx0XHRcdGFzbGRQdHJPQiA6IGpzYy5jcmVhdGVFbCgnZGl2JyksIC8vIHNsaWRlciBwb2ludGVyIG91dGVyIGJvcmRlclxyXG5cdFx0XHRcdFx0YnRuIDoganNjLmNyZWF0ZUVsKCdkaXYnKSxcclxuXHRcdFx0XHRcdGJ0blQgOiBqc2MuY3JlYXRlRWwoJ3NwYW4nKSwgLy8gdGV4dFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGpzYy5waWNrZXIucGFkLmFwcGVuZENoaWxkKGpzYy5waWNrZXIucGFkUGFsLmVsbSk7XHJcblx0XHRcdFx0anNjLnBpY2tlci5wYWRCLmFwcGVuZENoaWxkKGpzYy5waWNrZXIucGFkKTtcclxuXHRcdFx0XHRqc2MucGlja2VyLmNyb3NzLmFwcGVuZENoaWxkKGpzYy5waWNrZXIuY3Jvc3NCWSk7XHJcblx0XHRcdFx0anNjLnBpY2tlci5jcm9zcy5hcHBlbmRDaGlsZChqc2MucGlja2VyLmNyb3NzQlgpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIuY3Jvc3MuYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5jcm9zc0xZKTtcclxuXHRcdFx0XHRqc2MucGlja2VyLmNyb3NzLmFwcGVuZENoaWxkKGpzYy5waWNrZXIuY3Jvc3NMWCk7XHJcblx0XHRcdFx0anNjLnBpY2tlci5wYWRCLmFwcGVuZENoaWxkKGpzYy5waWNrZXIuY3Jvc3MpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIuYm94LmFwcGVuZENoaWxkKGpzYy5waWNrZXIucGFkQik7XHJcblx0XHRcdFx0anNjLnBpY2tlci5ib3guYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5wYWRNKTtcclxuXHJcblx0XHRcdFx0anNjLnBpY2tlci5zbGQuYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5zbGRHcmFkLmVsbSk7XHJcblx0XHRcdFx0anNjLnBpY2tlci5zbGRCLmFwcGVuZENoaWxkKGpzYy5waWNrZXIuc2xkKTtcclxuXHRcdFx0XHRqc2MucGlja2VyLnNsZEIuYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5zbGRQdHJPQik7XHJcblx0XHRcdFx0anNjLnBpY2tlci5zbGRQdHJPQi5hcHBlbmRDaGlsZChqc2MucGlja2VyLnNsZFB0ck1CKTtcclxuXHRcdFx0XHRqc2MucGlja2VyLnNsZFB0ck1CLmFwcGVuZENoaWxkKGpzYy5waWNrZXIuc2xkUHRySUIpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIuc2xkUHRySUIuYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5zbGRQdHJTKTtcclxuXHRcdFx0XHRqc2MucGlja2VyLmJveC5hcHBlbmRDaGlsZChqc2MucGlja2VyLnNsZEIpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIuYm94LmFwcGVuZENoaWxkKGpzYy5waWNrZXIuc2xkTSk7XHJcblxyXG5cdFx0XHRcdGpzYy5waWNrZXIuYXNsZC5hcHBlbmRDaGlsZChqc2MucGlja2VyLmFzbGRHcmFkLmVsbSk7XHJcblx0XHRcdFx0anNjLnBpY2tlci5hc2xkQi5hcHBlbmRDaGlsZChqc2MucGlja2VyLmFzbGQpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIuYXNsZEIuYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5hc2xkUHRyT0IpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIuYXNsZFB0ck9CLmFwcGVuZENoaWxkKGpzYy5waWNrZXIuYXNsZFB0ck1CKTtcclxuXHRcdFx0XHRqc2MucGlja2VyLmFzbGRQdHJNQi5hcHBlbmRDaGlsZChqc2MucGlja2VyLmFzbGRQdHJJQik7XHJcblx0XHRcdFx0anNjLnBpY2tlci5hc2xkUHRySUIuYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5hc2xkUHRyUyk7XHJcblx0XHRcdFx0anNjLnBpY2tlci5ib3guYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5hc2xkQik7XHJcblx0XHRcdFx0anNjLnBpY2tlci5ib3guYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5hc2xkTSk7XHJcblxyXG5cdFx0XHRcdGpzYy5waWNrZXIuYnRuLmFwcGVuZENoaWxkKGpzYy5waWNrZXIuYnRuVCk7XHJcblx0XHRcdFx0anNjLnBpY2tlci5ib3guYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5idG4pO1xyXG5cclxuXHRcdFx0XHRqc2MucGlja2VyLmJveEIuYXBwZW5kQ2hpbGQoanNjLnBpY2tlci5ib3gpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIud3JhcC5hcHBlbmRDaGlsZChqc2MucGlja2VyLmJveFMpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIud3JhcC5hcHBlbmRDaGlsZChqc2MucGlja2VyLmJveEIpO1xyXG5cclxuXHRcdFx0XHRqc2MucGlja2VyLndyYXAuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGpzYy5vblBpY2tlclRvdWNoU3RhcnQsXHJcblx0XHRcdFx0XHRqc2MuaXNQYXNzaXZlRXZlbnRTdXBwb3J0ZWQgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcCA9IGpzYy5waWNrZXI7XHJcblxyXG5cdFx0XHR2YXIgZGlzcGxheVNsaWRlciA9ICEhanNjLmdldFNsaWRlckNoYW5uZWwoVEhJUyk7XHJcblx0XHRcdHZhciBkaXNwbGF5QWxwaGFTbGlkZXIgPSBUSElTLmhhc0FscGhhQ2hhbm5lbCgpO1xyXG5cdFx0XHR2YXIgZGltcyA9IGpzYy5nZXRQaWNrZXJEaW1zKFRISVMpO1xyXG5cdFx0XHR2YXIgY3Jvc3NPdXRlclNpemUgPSAoMiAqIFRISVMucG9pbnRlckJvcmRlcldpZHRoICsgVEhJUy5wb2ludGVyVGhpY2tuZXNzICsgMiAqIFRISVMuY3Jvc3NTaXplKTtcclxuXHRcdFx0dmFyIGNvbnRyb2xQYWRkaW5nID0ganNjLmdldENvbnRyb2xQYWRkaW5nKFRISVMpO1xyXG5cdFx0XHR2YXIgYm9yZGVyUmFkaXVzID0gTWF0aC5taW4oXHJcblx0XHRcdFx0VEhJUy5ib3JkZXJSYWRpdXMsXHJcblx0XHRcdFx0TWF0aC5yb3VuZChUSElTLnBhZGRpbmcgKiBNYXRoLlBJKSk7IC8vIHB4XHJcblx0XHRcdHZhciBwYWRDdXJzb3IgPSAnY3Jvc3NoYWlyJztcclxuXHJcblx0XHRcdC8vIHdyYXBcclxuXHRcdFx0cC53cmFwLmNsYXNzTmFtZSA9ICdqc2NvbG9yLXBpY2tlci13cmFwJztcclxuXHRcdFx0cC53cmFwLnN0eWxlLmNsZWFyID0gJ2JvdGgnO1xyXG5cdFx0XHRwLndyYXAuc3R5bGUud2lkdGggPSAoZGltc1swXSArIDIgKiBUSElTLmJvcmRlcldpZHRoKSArICdweCc7XHJcblx0XHRcdHAud3JhcC5zdHlsZS5oZWlnaHQgPSAoZGltc1sxXSArIDIgKiBUSElTLmJvcmRlcldpZHRoKSArICdweCc7XHJcblx0XHRcdHAud3JhcC5zdHlsZS56SW5kZXggPSBUSElTLnpJbmRleDtcclxuXHJcblx0XHRcdC8vIHBpY2tlclxyXG5cdFx0XHRwLmJveC5jbGFzc05hbWUgPSAnanNjb2xvci1waWNrZXInO1xyXG5cdFx0XHRwLmJveC5zdHlsZS53aWR0aCA9IGRpbXNbMF0gKyAncHgnO1xyXG5cdFx0XHRwLmJveC5zdHlsZS5oZWlnaHQgPSBkaW1zWzFdICsgJ3B4JztcclxuXHRcdFx0cC5ib3guc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cclxuXHRcdFx0Ly8gcGlja2VyIHNoYWRvd1xyXG5cdFx0XHRwLmJveFMuY2xhc3NOYW1lID0gJ2pzY29sb3ItcGlja2VyLXNoYWRvdyc7XHJcblx0XHRcdHAuYm94Uy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblx0XHRcdHAuYm94Uy5zdHlsZS5sZWZ0ID0gJzAnO1xyXG5cdFx0XHRwLmJveFMuc3R5bGUudG9wID0gJzAnO1xyXG5cdFx0XHRwLmJveFMuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcblx0XHRcdHAuYm94Uy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XHJcblx0XHRcdGpzYy5zZXRCb3JkZXJSYWRpdXMocC5ib3hTLCBib3JkZXJSYWRpdXMgKyAncHgnKTtcclxuXHJcblx0XHRcdC8vIHBpY2tlciBib3JkZXJcclxuXHRcdFx0cC5ib3hCLmNsYXNzTmFtZSA9ICdqc2NvbG9yLXBpY2tlci1ib3JkZXInO1xyXG5cdFx0XHRwLmJveEIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0XHRwLmJveEIuc3R5bGUuYm9yZGVyID0gVEhJUy5ib3JkZXJXaWR0aCArICdweCBzb2xpZCc7XHJcblx0XHRcdHAuYm94Qi5zdHlsZS5ib3JkZXJDb2xvciA9IFRISVMuYm9yZGVyQ29sb3I7XHJcblx0XHRcdHAuYm94Qi5zdHlsZS5iYWNrZ3JvdW5kID0gVEhJUy5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0XHRcdGpzYy5zZXRCb3JkZXJSYWRpdXMocC5ib3hCLCBib3JkZXJSYWRpdXMgKyAncHgnKTtcclxuXHJcblx0XHRcdC8vIElFIGhhY2s6XHJcblx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGlzIHRyYW5zcGFyZW50LCBJRSB3aWxsIHRyaWdnZXIgdGhlIGV2ZW50IG9uIHRoZSBlbGVtZW50cyB1bmRlciBpdCxcclxuXHRcdFx0Ly8gZS5nLiBvbiBDYW52YXMgb3Igb24gZWxlbWVudHMgd2l0aCBib3JkZXJcclxuXHRcdFx0cC5wYWRNLnN0eWxlLmJhY2tncm91bmQgPSAncmdiYSgyNTUsMCwwLC4yKSc7XHJcblx0XHRcdHAuc2xkTS5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JnYmEoMCwyNTUsMCwuMiknO1xyXG5cdFx0XHRwLmFzbGRNLnN0eWxlLmJhY2tncm91bmQgPSAncmdiYSgwLDAsMjU1LC4yKSc7XHJcblxyXG5cdFx0XHRwLnBhZE0uc3R5bGUub3BhY2l0eSA9XHJcblx0XHRcdHAuc2xkTS5zdHlsZS5vcGFjaXR5ID1cclxuXHRcdFx0cC5hc2xkTS5zdHlsZS5vcGFjaXR5ID1cclxuXHRcdFx0XHQnMCc7XHJcblxyXG5cdFx0XHQvLyBwYWRcclxuXHRcdFx0cC5wYWQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0XHRwLnBhZC5zdHlsZS53aWR0aCA9IFRISVMud2lkdGggKyAncHgnO1xyXG5cdFx0XHRwLnBhZC5zdHlsZS5oZWlnaHQgPSBUSElTLmhlaWdodCArICdweCc7XHJcblxyXG5cdFx0XHQvLyBwYWQgcGFsZXR0ZXMgKEhTViBhbmQgSFZTKVxyXG5cdFx0XHRwLnBhZFBhbC5kcmF3KFRISVMud2lkdGgsIFRISVMuaGVpZ2h0LCBqc2MuZ2V0UGFkWUNoYW5uZWwoVEhJUykpO1xyXG5cclxuXHRcdFx0Ly8gcGFkIGJvcmRlclxyXG5cdFx0XHRwLnBhZEIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdFx0XHRwLnBhZEIuc3R5bGUubGVmdCA9IFRISVMucGFkZGluZyArICdweCc7XHJcblx0XHRcdHAucGFkQi5zdHlsZS50b3AgPSBUSElTLnBhZGRpbmcgKyAncHgnO1xyXG5cdFx0XHRwLnBhZEIuc3R5bGUuYm9yZGVyID0gVEhJUy5jb250cm9sQm9yZGVyV2lkdGggKyAncHggc29saWQnO1xyXG5cdFx0XHRwLnBhZEIuc3R5bGUuYm9yZGVyQ29sb3IgPSBUSElTLmNvbnRyb2xCb3JkZXJDb2xvcjtcclxuXHJcblx0XHRcdC8vIHBhZCBtb3VzZSBhcmVhXHJcblx0XHRcdHAucGFkTS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblx0XHRcdHAucGFkTS5zdHlsZS5sZWZ0ID0gMCArICdweCc7XHJcblx0XHRcdHAucGFkTS5zdHlsZS50b3AgPSAwICsgJ3B4JztcclxuXHRcdFx0cC5wYWRNLnN0eWxlLndpZHRoID0gKFRISVMucGFkZGluZyArIDIgKiBUSElTLmNvbnRyb2xCb3JkZXJXaWR0aCArIFRISVMud2lkdGggKyBjb250cm9sUGFkZGluZykgKyAncHgnO1xyXG5cdFx0XHRwLnBhZE0uc3R5bGUuaGVpZ2h0ID0gKDIgKiBUSElTLmNvbnRyb2xCb3JkZXJXaWR0aCArIDIgKiBUSElTLnBhZGRpbmcgKyBUSElTLmhlaWdodCkgKyAncHgnO1xyXG5cdFx0XHRwLnBhZE0uc3R5bGUuY3Vyc29yID0gcGFkQ3Vyc29yO1xyXG5cdFx0XHRqc2Muc2V0RGF0YShwLnBhZE0sIHtcclxuXHRcdFx0XHRpbnN0YW5jZTogVEhJUyxcclxuXHRcdFx0XHRjb250cm9sOiAncGFkJyxcclxuXHRcdFx0fSlcclxuXHJcblx0XHRcdC8vIHBhZCBjcm9zc1xyXG5cdFx0XHRwLmNyb3NzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHRcdFx0cC5jcm9zcy5zdHlsZS5sZWZ0ID1cclxuXHRcdFx0cC5jcm9zcy5zdHlsZS50b3AgPVxyXG5cdFx0XHRcdCcwJztcclxuXHRcdFx0cC5jcm9zcy5zdHlsZS53aWR0aCA9XHJcblx0XHRcdHAuY3Jvc3Muc3R5bGUuaGVpZ2h0ID1cclxuXHRcdFx0XHRjcm9zc091dGVyU2l6ZSArICdweCc7XHJcblxyXG5cdFx0XHQvLyBwYWQgY3Jvc3MgYm9yZGVyIFkgYW5kIFhcclxuXHRcdFx0cC5jcm9zc0JZLnN0eWxlLnBvc2l0aW9uID1cclxuXHRcdFx0cC5jcm9zc0JYLnN0eWxlLnBvc2l0aW9uID1cclxuXHRcdFx0XHQnYWJzb2x1dGUnO1xyXG5cdFx0XHRwLmNyb3NzQlkuc3R5bGUuYmFja2dyb3VuZCA9XHJcblx0XHRcdHAuY3Jvc3NCWC5zdHlsZS5iYWNrZ3JvdW5kID1cclxuXHRcdFx0XHRUSElTLnBvaW50ZXJCb3JkZXJDb2xvcjtcclxuXHRcdFx0cC5jcm9zc0JZLnN0eWxlLndpZHRoID1cclxuXHRcdFx0cC5jcm9zc0JYLnN0eWxlLmhlaWdodCA9XHJcblx0XHRcdFx0KDIgKiBUSElTLnBvaW50ZXJCb3JkZXJXaWR0aCArIFRISVMucG9pbnRlclRoaWNrbmVzcykgKyAncHgnO1xyXG5cdFx0XHRwLmNyb3NzQlkuc3R5bGUuaGVpZ2h0ID1cclxuXHRcdFx0cC5jcm9zc0JYLnN0eWxlLndpZHRoID1cclxuXHRcdFx0XHRjcm9zc091dGVyU2l6ZSArICdweCc7XHJcblx0XHRcdHAuY3Jvc3NCWS5zdHlsZS5sZWZ0ID1cclxuXHRcdFx0cC5jcm9zc0JYLnN0eWxlLnRvcCA9XHJcblx0XHRcdFx0KE1hdGguZmxvb3IoY3Jvc3NPdXRlclNpemUgLyAyKSAtIE1hdGguZmxvb3IoVEhJUy5wb2ludGVyVGhpY2tuZXNzIC8gMikgLSBUSElTLnBvaW50ZXJCb3JkZXJXaWR0aCkgKyAncHgnO1xyXG5cdFx0XHRwLmNyb3NzQlkuc3R5bGUudG9wID1cclxuXHRcdFx0cC5jcm9zc0JYLnN0eWxlLmxlZnQgPVxyXG5cdFx0XHRcdCcwJztcclxuXHJcblx0XHRcdC8vIHBhZCBjcm9zcyBsaW5lIFkgYW5kIFhcclxuXHRcdFx0cC5jcm9zc0xZLnN0eWxlLnBvc2l0aW9uID1cclxuXHRcdFx0cC5jcm9zc0xYLnN0eWxlLnBvc2l0aW9uID1cclxuXHRcdFx0XHQnYWJzb2x1dGUnO1xyXG5cdFx0XHRwLmNyb3NzTFkuc3R5bGUuYmFja2dyb3VuZCA9XHJcblx0XHRcdHAuY3Jvc3NMWC5zdHlsZS5iYWNrZ3JvdW5kID1cclxuXHRcdFx0XHRUSElTLnBvaW50ZXJDb2xvcjtcclxuXHRcdFx0cC5jcm9zc0xZLnN0eWxlLmhlaWdodCA9XHJcblx0XHRcdHAuY3Jvc3NMWC5zdHlsZS53aWR0aCA9XHJcblx0XHRcdFx0KGNyb3NzT3V0ZXJTaXplIC0gMiAqIFRISVMucG9pbnRlckJvcmRlcldpZHRoKSArICdweCc7XHJcblx0XHRcdHAuY3Jvc3NMWS5zdHlsZS53aWR0aCA9XHJcblx0XHRcdHAuY3Jvc3NMWC5zdHlsZS5oZWlnaHQgPVxyXG5cdFx0XHRcdFRISVMucG9pbnRlclRoaWNrbmVzcyArICdweCc7XHJcblx0XHRcdHAuY3Jvc3NMWS5zdHlsZS5sZWZ0ID1cclxuXHRcdFx0cC5jcm9zc0xYLnN0eWxlLnRvcCA9XHJcblx0XHRcdFx0KE1hdGguZmxvb3IoY3Jvc3NPdXRlclNpemUgLyAyKSAtIE1hdGguZmxvb3IoVEhJUy5wb2ludGVyVGhpY2tuZXNzIC8gMikpICsgJ3B4JztcclxuXHRcdFx0cC5jcm9zc0xZLnN0eWxlLnRvcCA9XHJcblx0XHRcdHAuY3Jvc3NMWC5zdHlsZS5sZWZ0ID1cclxuXHRcdFx0XHRUSElTLnBvaW50ZXJCb3JkZXJXaWR0aCArICdweCc7XHJcblxyXG5cclxuXHRcdFx0Ly8gc2xpZGVyXHJcblx0XHRcdHAuc2xkLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcblx0XHRcdHAuc2xkLnN0eWxlLndpZHRoID0gVEhJUy5zbGlkZXJTaXplICsgJ3B4JztcclxuXHRcdFx0cC5zbGQuc3R5bGUuaGVpZ2h0ID0gVEhJUy5oZWlnaHQgKyAncHgnO1xyXG5cclxuXHRcdFx0Ly8gc2xpZGVyIGdyYWRpZW50XHJcblx0XHRcdHAuc2xkR3JhZC5kcmF3KFRISVMuc2xpZGVyU2l6ZSwgVEhJUy5oZWlnaHQsICcjMDAwJywgJyMwMDAnKTtcclxuXHJcblx0XHRcdC8vIHNsaWRlciBib3JkZXJcclxuXHRcdFx0cC5zbGRCLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5U2xpZGVyID8gJ2Jsb2NrJyA6ICdub25lJztcclxuXHRcdFx0cC5zbGRCLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHRcdFx0cC5zbGRCLnN0eWxlLmxlZnQgPSAoVEhJUy5wYWRkaW5nICsgVEhJUy53aWR0aCArIDIgKiBUSElTLmNvbnRyb2xCb3JkZXJXaWR0aCArIDIgKiBjb250cm9sUGFkZGluZykgKyAncHgnO1xyXG5cdFx0XHRwLnNsZEIuc3R5bGUudG9wID0gVEhJUy5wYWRkaW5nICsgJ3B4JztcclxuXHRcdFx0cC5zbGRCLnN0eWxlLmJvcmRlciA9IFRISVMuY29udHJvbEJvcmRlcldpZHRoICsgJ3B4IHNvbGlkJztcclxuXHRcdFx0cC5zbGRCLnN0eWxlLmJvcmRlckNvbG9yID0gVEhJUy5jb250cm9sQm9yZGVyQ29sb3I7XHJcblxyXG5cdFx0XHQvLyBzbGlkZXIgbW91c2UgYXJlYVxyXG5cdFx0XHRwLnNsZE0uc3R5bGUuZGlzcGxheSA9IGRpc3BsYXlTbGlkZXIgPyAnYmxvY2snIDogJ25vbmUnO1xyXG5cdFx0XHRwLnNsZE0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdFx0XHRwLnNsZE0uc3R5bGUubGVmdCA9IChUSElTLnBhZGRpbmcgKyBUSElTLndpZHRoICsgMiAqIFRISVMuY29udHJvbEJvcmRlcldpZHRoICsgY29udHJvbFBhZGRpbmcpICsgJ3B4JztcclxuXHRcdFx0cC5zbGRNLnN0eWxlLnRvcCA9IDAgKyAncHgnO1xyXG5cdFx0XHRwLnNsZE0uc3R5bGUud2lkdGggPSAoXHJcblx0XHRcdFx0XHQoVEhJUy5zbGlkZXJTaXplICsgMiAqIGNvbnRyb2xQYWRkaW5nICsgMiAqIFRISVMuY29udHJvbEJvcmRlcldpZHRoKSArXHJcblx0XHRcdFx0XHQoZGlzcGxheUFscGhhU2xpZGVyID8gMCA6IE1hdGgubWF4KDAsIFRISVMucGFkZGluZyAtIGNvbnRyb2xQYWRkaW5nKSkgLy8gcmVtYWluaW5nIHBhZGRpbmcgdG8gdGhlIHJpZ2h0IGVkZ2VcclxuXHRcdFx0XHQpICsgJ3B4JztcclxuXHRcdFx0cC5zbGRNLnN0eWxlLmhlaWdodCA9ICgyICogVEhJUy5jb250cm9sQm9yZGVyV2lkdGggKyAyICogVEhJUy5wYWRkaW5nICsgVEhJUy5oZWlnaHQpICsgJ3B4JztcclxuXHRcdFx0cC5zbGRNLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcclxuXHRcdFx0anNjLnNldERhdGEocC5zbGRNLCB7XHJcblx0XHRcdFx0aW5zdGFuY2U6IFRISVMsXHJcblx0XHRcdFx0Y29udHJvbDogJ3NsZCcsXHJcblx0XHRcdH0pXHJcblxyXG5cdFx0XHQvLyBzbGlkZXIgcG9pbnRlciBpbm5lciBhbmQgb3V0ZXIgYm9yZGVyXHJcblx0XHRcdHAuc2xkUHRySUIuc3R5bGUuYm9yZGVyID1cclxuXHRcdFx0cC5zbGRQdHJPQi5zdHlsZS5ib3JkZXIgPVxyXG5cdFx0XHRcdFRISVMucG9pbnRlckJvcmRlcldpZHRoICsgJ3B4IHNvbGlkICcgKyBUSElTLnBvaW50ZXJCb3JkZXJDb2xvcjtcclxuXHJcblx0XHRcdC8vIHNsaWRlciBwb2ludGVyIG91dGVyIGJvcmRlclxyXG5cdFx0XHRwLnNsZFB0ck9CLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHRcdFx0cC5zbGRQdHJPQi5zdHlsZS5sZWZ0ID0gLSgyICogVEhJUy5wb2ludGVyQm9yZGVyV2lkdGggKyBUSElTLnBvaW50ZXJUaGlja25lc3MpICsgJ3B4JztcclxuXHRcdFx0cC5zbGRQdHJPQi5zdHlsZS50b3AgPSAnMCc7XHJcblxyXG5cdFx0XHQvLyBzbGlkZXIgcG9pbnRlciBtaWRkbGUgYm9yZGVyXHJcblx0XHRcdHAuc2xkUHRyTUIuc3R5bGUuYm9yZGVyID0gVEhJUy5wb2ludGVyVGhpY2tuZXNzICsgJ3B4IHNvbGlkICcgKyBUSElTLnBvaW50ZXJDb2xvcjtcclxuXHJcblx0XHRcdC8vIHNsaWRlciBwb2ludGVyIHNwYWNlclxyXG5cdFx0XHRwLnNsZFB0clMuc3R5bGUud2lkdGggPSBUSElTLnNsaWRlclNpemUgKyAncHgnO1xyXG5cdFx0XHRwLnNsZFB0clMuc3R5bGUuaGVpZ2h0ID0ganNjLnB1Yi5zbGlkZXJJbm5lclNwYWNlICsgJ3B4JztcclxuXHJcblxyXG5cdFx0XHQvLyBhbHBoYSBzbGlkZXJcclxuXHRcdFx0cC5hc2xkLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcblx0XHRcdHAuYXNsZC5zdHlsZS53aWR0aCA9IFRISVMuc2xpZGVyU2l6ZSArICdweCc7XHJcblx0XHRcdHAuYXNsZC5zdHlsZS5oZWlnaHQgPSBUSElTLmhlaWdodCArICdweCc7XHJcblxyXG5cdFx0XHQvLyBhbHBoYSBzbGlkZXIgZ3JhZGllbnRcclxuXHRcdFx0cC5hc2xkR3JhZC5kcmF3KFRISVMuc2xpZGVyU2l6ZSwgVEhJUy5oZWlnaHQsICcjMDAwJyk7XHJcblxyXG5cdFx0XHQvLyBhbHBoYSBzbGlkZXIgYm9yZGVyXHJcblx0XHRcdHAuYXNsZEIuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXlBbHBoYVNsaWRlciA/ICdibG9jaycgOiAnbm9uZSc7XHJcblx0XHRcdHAuYXNsZEIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdFx0XHRwLmFzbGRCLnN0eWxlLmxlZnQgPSAoXHJcblx0XHRcdFx0XHQoVEhJUy5wYWRkaW5nICsgVEhJUy53aWR0aCArIDIgKiBUSElTLmNvbnRyb2xCb3JkZXJXaWR0aCArIGNvbnRyb2xQYWRkaW5nKSArXHJcblx0XHRcdFx0XHQoZGlzcGxheVNsaWRlciA/IChUSElTLnNsaWRlclNpemUgKyAzICogY29udHJvbFBhZGRpbmcgKyAyICogVEhJUy5jb250cm9sQm9yZGVyV2lkdGgpIDogMClcclxuXHRcdFx0XHQpICsgJ3B4JztcclxuXHRcdFx0cC5hc2xkQi5zdHlsZS50b3AgPSBUSElTLnBhZGRpbmcgKyAncHgnO1xyXG5cdFx0XHRwLmFzbGRCLnN0eWxlLmJvcmRlciA9IFRISVMuY29udHJvbEJvcmRlcldpZHRoICsgJ3B4IHNvbGlkJztcclxuXHRcdFx0cC5hc2xkQi5zdHlsZS5ib3JkZXJDb2xvciA9IFRISVMuY29udHJvbEJvcmRlckNvbG9yO1xyXG5cclxuXHRcdFx0Ly8gYWxwaGEgc2xpZGVyIG1vdXNlIGFyZWFcclxuXHRcdFx0cC5hc2xkTS5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheUFscGhhU2xpZGVyID8gJ2Jsb2NrJyA6ICdub25lJztcclxuXHRcdFx0cC5hc2xkTS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblx0XHRcdHAuYXNsZE0uc3R5bGUubGVmdCA9IChcclxuXHRcdFx0XHRcdChUSElTLnBhZGRpbmcgKyBUSElTLndpZHRoICsgMiAqIFRISVMuY29udHJvbEJvcmRlcldpZHRoICsgY29udHJvbFBhZGRpbmcpICtcclxuXHRcdFx0XHRcdChkaXNwbGF5U2xpZGVyID8gKFRISVMuc2xpZGVyU2l6ZSArIDIgKiBjb250cm9sUGFkZGluZyArIDIgKiBUSElTLmNvbnRyb2xCb3JkZXJXaWR0aCkgOiAwKVxyXG5cdFx0XHRcdCkgKyAncHgnO1xyXG5cdFx0XHRwLmFzbGRNLnN0eWxlLnRvcCA9IDAgKyAncHgnO1xyXG5cdFx0XHRwLmFzbGRNLnN0eWxlLndpZHRoID0gKFxyXG5cdFx0XHRcdFx0KFRISVMuc2xpZGVyU2l6ZSArIDIgKiBjb250cm9sUGFkZGluZyArIDIgKiBUSElTLmNvbnRyb2xCb3JkZXJXaWR0aCkgK1xyXG5cdFx0XHRcdFx0TWF0aC5tYXgoMCwgVEhJUy5wYWRkaW5nIC0gY29udHJvbFBhZGRpbmcpIC8vIHJlbWFpbmluZyBwYWRkaW5nIHRvIHRoZSByaWdodCBlZGdlXHJcblx0XHRcdFx0KSArICdweCc7XHJcblx0XHRcdHAuYXNsZE0uc3R5bGUuaGVpZ2h0ID0gKDIgKiBUSElTLmNvbnRyb2xCb3JkZXJXaWR0aCArIDIgKiBUSElTLnBhZGRpbmcgKyBUSElTLmhlaWdodCkgKyAncHgnO1xyXG5cdFx0XHRwLmFzbGRNLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcclxuXHRcdFx0anNjLnNldERhdGEocC5hc2xkTSwge1xyXG5cdFx0XHRcdGluc3RhbmNlOiBUSElTLFxyXG5cdFx0XHRcdGNvbnRyb2w6ICdhc2xkJyxcclxuXHRcdFx0fSlcclxuXHJcblx0XHRcdC8vIGFscGhhIHNsaWRlciBwb2ludGVyIGlubmVyIGFuZCBvdXRlciBib3JkZXJcclxuXHRcdFx0cC5hc2xkUHRySUIuc3R5bGUuYm9yZGVyID1cclxuXHRcdFx0cC5hc2xkUHRyT0Iuc3R5bGUuYm9yZGVyID1cclxuXHRcdFx0XHRUSElTLnBvaW50ZXJCb3JkZXJXaWR0aCArICdweCBzb2xpZCAnICsgVEhJUy5wb2ludGVyQm9yZGVyQ29sb3I7XHJcblxyXG5cdFx0XHQvLyBhbHBoYSBzbGlkZXIgcG9pbnRlciBvdXRlciBib3JkZXJcclxuXHRcdFx0cC5hc2xkUHRyT0Iuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdFx0XHRwLmFzbGRQdHJPQi5zdHlsZS5sZWZ0ID0gLSgyICogVEhJUy5wb2ludGVyQm9yZGVyV2lkdGggKyBUSElTLnBvaW50ZXJUaGlja25lc3MpICsgJ3B4JztcclxuXHRcdFx0cC5hc2xkUHRyT0Iuc3R5bGUudG9wID0gJzAnO1xyXG5cclxuXHRcdFx0Ly8gYWxwaGEgc2xpZGVyIHBvaW50ZXIgbWlkZGxlIGJvcmRlclxyXG5cdFx0XHRwLmFzbGRQdHJNQi5zdHlsZS5ib3JkZXIgPSBUSElTLnBvaW50ZXJUaGlja25lc3MgKyAncHggc29saWQgJyArIFRISVMucG9pbnRlckNvbG9yO1xyXG5cclxuXHRcdFx0Ly8gYWxwaGEgc2xpZGVyIHBvaW50ZXIgc3BhY2VyXHJcblx0XHRcdHAuYXNsZFB0clMuc3R5bGUud2lkdGggPSBUSElTLnNsaWRlclNpemUgKyAncHgnO1xyXG5cdFx0XHRwLmFzbGRQdHJTLnN0eWxlLmhlaWdodCA9IGpzYy5wdWIuc2xpZGVySW5uZXJTcGFjZSArICdweCc7XHJcblxyXG5cclxuXHRcdFx0Ly8gdGhlIENsb3NlIGJ1dHRvblxyXG5cdFx0XHRmdW5jdGlvbiBzZXRCdG5Cb3JkZXIgKCkge1xyXG5cdFx0XHRcdHZhciBpbnNldENvbG9ycyA9IFRISVMuY29udHJvbEJvcmRlckNvbG9yLnNwbGl0KC9cXHMrLyk7XHJcblx0XHRcdFx0dmFyIG91dHNldENvbG9yID0gaW5zZXRDb2xvcnMubGVuZ3RoIDwgMiA/IGluc2V0Q29sb3JzWzBdIDogaW5zZXRDb2xvcnNbMV0gKyAnICcgKyBpbnNldENvbG9yc1swXSArICcgJyArIGluc2V0Q29sb3JzWzBdICsgJyAnICsgaW5zZXRDb2xvcnNbMV07XHJcblx0XHRcdFx0cC5idG4uc3R5bGUuYm9yZGVyQ29sb3IgPSBvdXRzZXRDb2xvcjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgYnRuUGFkZGluZyA9IDE1OyAvLyBweFxyXG5cdFx0XHRwLmJ0bi5jbGFzc05hbWUgPSAnanNjb2xvci1idG4tY2xvc2UnO1xyXG5cdFx0XHRwLmJ0bi5zdHlsZS5kaXNwbGF5ID0gVEhJUy5jbG9zZUJ1dHRvbiA/ICdibG9jaycgOiAnbm9uZSc7XHJcblx0XHRcdHAuYnRuLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHRcdFx0cC5idG4uc3R5bGUubGVmdCA9IFRISVMucGFkZGluZyArICdweCc7XHJcblx0XHRcdHAuYnRuLnN0eWxlLmJvdHRvbSA9IFRISVMucGFkZGluZyArICdweCc7XHJcblx0XHRcdHAuYnRuLnN0eWxlLnBhZGRpbmcgPSAnMCAnICsgYnRuUGFkZGluZyArICdweCc7XHJcblx0XHRcdHAuYnRuLnN0eWxlLm1heFdpZHRoID0gKGRpbXNbMF0gLSAyICogVEhJUy5wYWRkaW5nIC0gMiAqIFRISVMuY29udHJvbEJvcmRlcldpZHRoIC0gMiAqIGJ0blBhZGRpbmcpICsgJ3B4JztcclxuXHRcdFx0cC5idG4uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuXHRcdFx0cC5idG4uc3R5bGUuaGVpZ2h0ID0gVEhJUy5idXR0b25IZWlnaHQgKyAncHgnO1xyXG5cdFx0XHRwLmJ0bi5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblx0XHRcdHAuYnRuLnN0eWxlLmJvcmRlciA9IFRISVMuY29udHJvbEJvcmRlcldpZHRoICsgJ3B4IHNvbGlkJztcclxuXHRcdFx0c2V0QnRuQm9yZGVyKCk7XHJcblx0XHRcdHAuYnRuLnN0eWxlLmNvbG9yID0gVEhJUy5idXR0b25Db2xvcjtcclxuXHRcdFx0cC5idG4uc3R5bGUuZm9udCA9ICcxMnB4IHNhbnMtc2VyaWYnO1xyXG5cdFx0XHRwLmJ0bi5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuXHRcdFx0cC5idG4uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG5cdFx0XHRwLmJ0bi5vbm1vdXNlZG93biA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRUSElTLmhpZGUoKTtcclxuXHRcdFx0fTtcclxuXHRcdFx0cC5idG5ULnN0eWxlLmxpbmVIZWlnaHQgPSBUSElTLmJ1dHRvbkhlaWdodCArICdweCc7XHJcblx0XHRcdHAuYnRuVC5pbm5lckhUTUwgPSAnJztcclxuXHRcdFx0cC5idG5ULmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFRISVMuY2xvc2VUZXh0KSk7XHJcblxyXG5cdFx0XHQvLyByZXBvc2l0aW9uIHRoZSBwb2ludGVyc1xyXG5cdFx0XHRyZWRyYXdQYWQoKTtcclxuXHRcdFx0cmVkcmF3U2xkKCk7XHJcblx0XHRcdHJlZHJhd0FTbGQoKTtcclxuXHJcblx0XHRcdC8vIElmIHdlIGFyZSBjaGFuZ2luZyB0aGUgb3duZXIgd2l0aG91dCBmaXJzdCBjbG9zaW5nIHRoZSBwaWNrZXIsXHJcblx0XHRcdC8vIG1ha2Ugc3VyZSB0byBmaXJzdCBkZWFsIHdpdGggdGhlIG9sZCBvd25lclxyXG5cdFx0XHRpZiAoanNjLnBpY2tlci5vd25lciAmJiBqc2MucGlja2VyLm93bmVyICE9PSBUSElTKSB7XHJcblx0XHRcdFx0anNjLnJlbW92ZUNsYXNzKGpzYy5waWNrZXIub3duZXIudGFyZ2V0RWxlbWVudCwganNjLnB1Yi5hY3RpdmVDbGFzc05hbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBTZXQgYSBuZXcgcGlja2VyIG93bmVyXHJcblx0XHRcdGpzYy5waWNrZXIub3duZXIgPSBUSElTO1xyXG5cclxuXHRcdFx0Ly8gVGhlIHJlZHJhd1Bvc2l0aW9uKCkgbWV0aG9kIG5lZWRzIHBpY2tlci5vd25lciB0byBiZSBzZXQsIHRoYXQncyB3aHkgd2UgY2FsbCBpdCBoZXJlLFxyXG5cdFx0XHQvLyBhZnRlciBzZXR0aW5nIHRoZSBvd25lclxyXG5cdFx0XHRpZiAoVEhJUy5jb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuXHRcdFx0XHRqc2MucmVkcmF3UG9zaXRpb24oKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRqc2MuX2RyYXdQb3NpdGlvbihUSElTLCAwLCAwLCAncmVsYXRpdmUnLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChwLndyYXAucGFyZW50Tm9kZSAhPT0gVEhJUy5jb250YWluZXIpIHtcclxuXHRcdFx0XHRUSElTLmNvbnRhaW5lci5hcHBlbmRDaGlsZChwLndyYXApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRqc2MuYWRkQ2xhc3MoVEhJUy50YXJnZXRFbGVtZW50LCBqc2MucHViLmFjdGl2ZUNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlZHJhd1BhZCAoKSB7XHJcblx0XHRcdC8vIHJlZHJhdyB0aGUgcGFkIHBvaW50ZXJcclxuXHRcdFx0dmFyIHlDaGFubmVsID0ganNjLmdldFBhZFlDaGFubmVsKFRISVMpO1xyXG5cdFx0XHR2YXIgeCA9IE1hdGgucm91bmQoKFRISVMuY2hhbm5lbHMuaCAvIDM2MCkgKiAoVEhJUy53aWR0aCAtIDEpKTtcclxuXHRcdFx0dmFyIHkgPSBNYXRoLnJvdW5kKCgxIC0gVEhJUy5jaGFubmVsc1t5Q2hhbm5lbF0gLyAxMDApICogKFRISVMuaGVpZ2h0IC0gMSkpO1xyXG5cdFx0XHR2YXIgY3Jvc3NPdXRlclNpemUgPSAoMiAqIFRISVMucG9pbnRlckJvcmRlcldpZHRoICsgVEhJUy5wb2ludGVyVGhpY2tuZXNzICsgMiAqIFRISVMuY3Jvc3NTaXplKTtcclxuXHRcdFx0dmFyIG9mcyA9IC1NYXRoLmZsb29yKGNyb3NzT3V0ZXJTaXplIC8gMik7XHJcblx0XHRcdGpzYy5waWNrZXIuY3Jvc3Muc3R5bGUubGVmdCA9ICh4ICsgb2ZzKSArICdweCc7XHJcblx0XHRcdGpzYy5waWNrZXIuY3Jvc3Muc3R5bGUudG9wID0gKHkgKyBvZnMpICsgJ3B4JztcclxuXHJcblx0XHRcdC8vIHJlZHJhdyB0aGUgc2xpZGVyXHJcblx0XHRcdHN3aXRjaCAoanNjLmdldFNsaWRlckNoYW5uZWwoVEhJUykpIHtcclxuXHRcdFx0Y2FzZSAncyc6XHJcblx0XHRcdFx0dmFyIHJnYjEgPSBqc2MuSFNWX1JHQihUSElTLmNoYW5uZWxzLmgsIDEwMCwgVEhJUy5jaGFubmVscy52KTtcclxuXHRcdFx0XHR2YXIgcmdiMiA9IGpzYy5IU1ZfUkdCKFRISVMuY2hhbm5lbHMuaCwgMCwgVEhJUy5jaGFubmVscy52KTtcclxuXHRcdFx0XHR2YXIgY29sb3IxID0gJ3JnYignICtcclxuXHRcdFx0XHRcdE1hdGgucm91bmQocmdiMVswXSkgKyAnLCcgK1xyXG5cdFx0XHRcdFx0TWF0aC5yb3VuZChyZ2IxWzFdKSArICcsJyArXHJcblx0XHRcdFx0XHRNYXRoLnJvdW5kKHJnYjFbMl0pICsgJyknO1xyXG5cdFx0XHRcdHZhciBjb2xvcjIgPSAncmdiKCcgK1xyXG5cdFx0XHRcdFx0TWF0aC5yb3VuZChyZ2IyWzBdKSArICcsJyArXHJcblx0XHRcdFx0XHRNYXRoLnJvdW5kKHJnYjJbMV0pICsgJywnICtcclxuXHRcdFx0XHRcdE1hdGgucm91bmQocmdiMlsyXSkgKyAnKSc7XHJcblx0XHRcdFx0anNjLnBpY2tlci5zbGRHcmFkLmRyYXcoVEhJUy5zbGlkZXJTaXplLCBUSElTLmhlaWdodCwgY29sb3IxLCBjb2xvcjIpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICd2JzpcclxuXHRcdFx0XHR2YXIgcmdiID0ganNjLkhTVl9SR0IoVEhJUy5jaGFubmVscy5oLCBUSElTLmNoYW5uZWxzLnMsIDEwMCk7XHJcblx0XHRcdFx0dmFyIGNvbG9yMSA9ICdyZ2IoJyArXHJcblx0XHRcdFx0XHRNYXRoLnJvdW5kKHJnYlswXSkgKyAnLCcgK1xyXG5cdFx0XHRcdFx0TWF0aC5yb3VuZChyZ2JbMV0pICsgJywnICtcclxuXHRcdFx0XHRcdE1hdGgucm91bmQocmdiWzJdKSArICcpJztcclxuXHRcdFx0XHR2YXIgY29sb3IyID0gJyMwMDAnO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIuc2xkR3JhZC5kcmF3KFRISVMuc2xpZGVyU2l6ZSwgVEhJUy5oZWlnaHQsIGNvbG9yMSwgY29sb3IyKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmVkcmF3IHRoZSBhbHBoYSBzbGlkZXJcclxuXHRcdFx0anNjLnBpY2tlci5hc2xkR3JhZC5kcmF3KFRISVMuc2xpZGVyU2l6ZSwgVEhJUy5oZWlnaHQsIFRISVMudG9IRVhTdHJpbmcoKSk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlZHJhd1NsZCAoKSB7XHJcblx0XHRcdHZhciBzbGRDaGFubmVsID0ganNjLmdldFNsaWRlckNoYW5uZWwoVEhJUyk7XHJcblx0XHRcdGlmIChzbGRDaGFubmVsKSB7XHJcblx0XHRcdFx0Ly8gcmVkcmF3IHRoZSBzbGlkZXIgcG9pbnRlclxyXG5cdFx0XHRcdHZhciB5ID0gTWF0aC5yb3VuZCgoMSAtIFRISVMuY2hhbm5lbHNbc2xkQ2hhbm5lbF0gLyAxMDApICogKFRISVMuaGVpZ2h0IC0gMSkpO1xyXG5cdFx0XHRcdGpzYy5waWNrZXIuc2xkUHRyT0Iuc3R5bGUudG9wID0gKHkgLSAoMiAqIFRISVMucG9pbnRlckJvcmRlcldpZHRoICsgVEhJUy5wb2ludGVyVGhpY2tuZXNzKSAtIE1hdGguZmxvb3IoanNjLnB1Yi5zbGlkZXJJbm5lclNwYWNlIC8gMikpICsgJ3B4JztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmVkcmF3IHRoZSBhbHBoYSBzbGlkZXJcclxuXHRcdFx0anNjLnBpY2tlci5hc2xkR3JhZC5kcmF3KFRISVMuc2xpZGVyU2l6ZSwgVEhJUy5oZWlnaHQsIFRISVMudG9IRVhTdHJpbmcoKSk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlZHJhd0FTbGQgKCkge1xyXG5cdFx0XHR2YXIgeSA9IE1hdGgucm91bmQoKDEgLSBUSElTLmNoYW5uZWxzLmEpICogKFRISVMuaGVpZ2h0IC0gMSkpO1xyXG5cdFx0XHRqc2MucGlja2VyLmFzbGRQdHJPQi5zdHlsZS50b3AgPSAoeSAtICgyICogVEhJUy5wb2ludGVyQm9yZGVyV2lkdGggKyBUSElTLnBvaW50ZXJUaGlja25lc3MpIC0gTWF0aC5mbG9vcihqc2MucHViLnNsaWRlcklubmVyU3BhY2UgLyAyKSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBpc1BpY2tlck93bmVyICgpIHtcclxuXHRcdFx0cmV0dXJuIGpzYy5waWNrZXIgJiYganNjLnBpY2tlci5vd25lciA9PT0gVEhJUztcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gb25WYWx1ZUtleURvd24gKGV2KSB7XHJcblx0XHRcdGlmIChqc2MuZXZlbnRLZXkoZXYpID09PSAnRW50ZXInKSB7XHJcblx0XHRcdFx0aWYgKFRISVMudmFsdWVFbGVtZW50KSB7XHJcblx0XHRcdFx0XHRUSElTLnByb2Nlc3NWYWx1ZUlucHV0KFRISVMudmFsdWVFbGVtZW50LnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0VEhJUy50cnlIaWRlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gb25BbHBoYUtleURvd24gKGV2KSB7XHJcblx0XHRcdGlmIChqc2MuZXZlbnRLZXkoZXYpID09PSAnRW50ZXInKSB7XHJcblx0XHRcdFx0aWYgKFRISVMuYWxwaGFFbGVtZW50KSB7XHJcblx0XHRcdFx0XHRUSElTLnByb2Nlc3NBbHBoYUlucHV0KFRISVMuYWxwaGFFbGVtZW50LnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0VEhJUy50cnlIaWRlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gb25WYWx1ZUNoYW5nZSAoZXYpIHtcclxuXHRcdFx0aWYgKGpzYy5nZXREYXRhKGV2LCAnaW50ZXJuYWwnKSkge1xyXG5cdFx0XHRcdHJldHVybjsgLy8gc2tpcCBpZiB0aGUgZXZlbnQgd2FzIGludGVybmFsbHkgdHJpZ2dlcmVkIGJ5IGpzY29sb3JcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG9sZFZhbCA9IFRISVMudmFsdWVFbGVtZW50LnZhbHVlO1xyXG5cclxuXHRcdFx0VEhJUy5wcm9jZXNzVmFsdWVJbnB1dChUSElTLnZhbHVlRWxlbWVudC52YWx1ZSk7IC8vIHRoaXMgbWlnaHQgY2hhbmdlIHRoZSB2YWx1ZVxyXG5cclxuXHRcdFx0anNjLnRyaWdnZXJDYWxsYmFjayhUSElTLCAnb25DaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmIChUSElTLnZhbHVlRWxlbWVudC52YWx1ZSAhPT0gb2xkVmFsKSB7XHJcblx0XHRcdFx0Ly8gdmFsdWUgd2FzIGFkZGl0aW9uYWxseSBjaGFuZ2VkIC0+IGxldCdzIHRyaWdnZXIgdGhlIGNoYW5nZSBldmVudCBhZ2FpbiwgZXZlbiB0aG91Z2ggaXQgd2FzIG5hdGl2ZWx5IGRpc3BhdGNoZWRcclxuXHRcdFx0XHRqc2MudHJpZ2dlcklucHV0RXZlbnQoVEhJUy52YWx1ZUVsZW1lbnQsICdjaGFuZ2UnLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBvbkFscGhhQ2hhbmdlIChldikge1xyXG5cdFx0XHRpZiAoanNjLmdldERhdGEoZXYsICdpbnRlcm5hbCcpKSB7XHJcblx0XHRcdFx0cmV0dXJuOyAvLyBza2lwIGlmIHRoZSBldmVudCB3YXMgaW50ZXJuYWxseSB0cmlnZ2VyZWQgYnkganNjb2xvclxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgb2xkVmFsID0gVEhJUy5hbHBoYUVsZW1lbnQudmFsdWU7XHJcblxyXG5cdFx0XHRUSElTLnByb2Nlc3NBbHBoYUlucHV0KFRISVMuYWxwaGFFbGVtZW50LnZhbHVlKTsgLy8gdGhpcyBtaWdodCBjaGFuZ2UgdGhlIHZhbHVlXHJcblxyXG5cdFx0XHRqc2MudHJpZ2dlckNhbGxiYWNrKFRISVMsICdvbkNoYW5nZScpO1xyXG5cclxuXHRcdFx0Ly8gdHJpZ2dlcmluZyB2YWx1ZUVsZW1lbnQncyBvbkNoYW5nZSAoYmVjYXVzZSBjaGFuZ2luZyBhbHBoYSBjaGFuZ2VzIHRoZSBlbnRpcmUgY29sb3IsIGUuZy4gd2l0aCByZ2JhIGZvcm1hdClcclxuXHRcdFx0anNjLnRyaWdnZXJJbnB1dEV2ZW50KFRISVMudmFsdWVFbGVtZW50LCAnY2hhbmdlJywgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRpZiAoVEhJUy5hbHBoYUVsZW1lbnQudmFsdWUgIT09IG9sZFZhbCkge1xyXG5cdFx0XHRcdC8vIHZhbHVlIHdhcyBhZGRpdGlvbmFsbHkgY2hhbmdlZCAtPiBsZXQncyB0cmlnZ2VyIHRoZSBjaGFuZ2UgZXZlbnQgYWdhaW4sIGV2ZW4gdGhvdWdoIGl0IHdhcyBuYXRpdmVseSBkaXNwYXRjaGVkXHJcblx0XHRcdFx0anNjLnRyaWdnZXJJbnB1dEV2ZW50KFRISVMuYWxwaGFFbGVtZW50LCAnY2hhbmdlJywgdHJ1ZSwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gb25WYWx1ZUlucHV0IChldikge1xyXG5cdFx0XHRpZiAoanNjLmdldERhdGEoZXYsICdpbnRlcm5hbCcpKSB7XHJcblx0XHRcdFx0cmV0dXJuOyAvLyBza2lwIGlmIHRoZSBldmVudCB3YXMgaW50ZXJuYWxseSB0cmlnZ2VyZWQgYnkganNjb2xvclxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoVEhJUy52YWx1ZUVsZW1lbnQpIHtcclxuXHRcdFx0XHRUSElTLmZyb21TdHJpbmcoVEhJUy52YWx1ZUVsZW1lbnQudmFsdWUsIGpzYy5mbGFncy5sZWF2ZVZhbHVlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0anNjLnRyaWdnZXJDYWxsYmFjayhUSElTLCAnb25JbnB1dCcpO1xyXG5cclxuXHRcdFx0Ly8gdHJpZ2dlcmluZyB2YWx1ZUVsZW1lbnQncyBvbklucHV0XHJcblx0XHRcdC8vIChub3QgbmVlZGVkLCBpdCB3YXMgZGlzcGF0Y2hlZCBub3JtYWxseSBieSB0aGUgYnJvd3NlcilcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gb25BbHBoYUlucHV0IChldikge1xyXG5cdFx0XHRpZiAoanNjLmdldERhdGEoZXYsICdpbnRlcm5hbCcpKSB7XHJcblx0XHRcdFx0cmV0dXJuOyAvLyBza2lwIGlmIHRoZSBldmVudCB3YXMgaW50ZXJuYWxseSB0cmlnZ2VyZWQgYnkganNjb2xvclxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoVEhJUy5hbHBoYUVsZW1lbnQpIHtcclxuXHRcdFx0XHRUSElTLmZyb21IU1ZBKG51bGwsIG51bGwsIG51bGwsIHBhcnNlRmxvYXQoVEhJUy5hbHBoYUVsZW1lbnQudmFsdWUpLCBqc2MuZmxhZ3MubGVhdmVBbHBoYSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGpzYy50cmlnZ2VyQ2FsbGJhY2soVEhJUywgJ29uSW5wdXQnKTtcclxuXHJcblx0XHRcdC8vIHRyaWdnZXJpbmcgdmFsdWVFbGVtZW50J3Mgb25JbnB1dCAoYmVjYXVzZSBjaGFuZ2luZyBhbHBoYSBjaGFuZ2VzIHRoZSBlbnRpcmUgY29sb3IsIGUuZy4gd2l0aCByZ2JhIGZvcm1hdClcclxuXHRcdFx0anNjLnRyaWdnZXJJbnB1dEV2ZW50KFRISVMudmFsdWVFbGVtZW50LCAnaW5wdXQnLCB0cnVlLCB0cnVlKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly9cclxuXHRcdC8vIEluc3RhbGwgdGhlIGNvbG9yIHBpY2tlciBvbiBjaG9zZW4gZWxlbWVudChzKVxyXG5cdFx0Ly9cclxuXHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIHBpY2tlcidzIGNvbnRhaW5lciBlbGVtZW50XHJcblx0XHRpZiAodGhpcy5jb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmJvZHk7IC8vIGRlZmF1bHQgY29udGFpbmVyIGlzIEJPRFkgZWxlbWVudFxyXG5cclxuXHRcdH0gZWxzZSB7IC8vIGV4cGxpY2l0bHkgc2V0IHRvIGN1c3RvbSBlbGVtZW50XHJcblx0XHRcdHRoaXMuY29udGFpbmVyID0ganNjLm5vZGUodGhpcy5jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5jb250YWluZXIpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW5zdGFudGlhdGUgY29sb3IgcGlja2VyIHdpdGhvdXQgYSBjb250YWluZXIgZWxlbWVudCcpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBGZXRjaCB0aGUgdGFyZ2V0IGVsZW1lbnRcclxuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IGpzYy5ub2RlKHRhcmdldEVsZW1lbnQpO1xyXG5cclxuXHRcdGlmICghdGhpcy50YXJnZXRFbGVtZW50KSB7XHJcblx0XHRcdC8vIHRlbXBvcmFyaWx5IGN1c3RvbWl6ZWQgZXJyb3IgbWVzc2FnZSB0byBoZWxwIHdpdGggbWlncmF0aW5nIGZyb20gdmVyc2lvbnMgcHJpb3IgdG8gMi4yXHJcblx0XHRcdGlmICh0eXBlb2YgdGFyZ2V0RWxlbWVudCA9PT0gJ3N0cmluZycgJiYgL15bYS16QS1aXVtcXHc6Li1dKiQvLnRlc3QodGFyZ2V0RWxlbWVudCkpIHtcclxuXHRcdFx0XHQvLyB0YXJnZXRFbGVtZW50IGxvb2tzIGxpa2UgdmFsaWQgSURcclxuXHRcdFx0XHR2YXIgcG9zc2libHlJZCA9IHRhcmdldEVsZW1lbnQ7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJZiBcXCcnICsgcG9zc2libHlJZCArICdcXCcgaXMgc3VwcG9zZWQgdG8gYmUgYW4gSUQsIHBsZWFzZSB1c2UgXFwnIycgKyBwb3NzaWJseUlkICsgJ1xcJyBvciBhbnkgdmFsaWQgQ1NTIHNlbGVjdG9yLicpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnN0YW50aWF0ZSBjb2xvciBwaWNrZXIgd2l0aG91dCBhIHRhcmdldCBlbGVtZW50Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMudGFyZ2V0RWxlbWVudC5qc2NvbG9yICYmIHRoaXMudGFyZ2V0RWxlbWVudC5qc2NvbG9yIGluc3RhbmNlb2YganNjLnB1Yikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvbG9yIHBpY2tlciBhbHJlYWR5IGluc3RhbGxlZCBvbiB0aGlzIGVsZW1lbnQnKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gbGluayB0aGlzIGluc3RhbmNlIHdpdGggdGhlIHRhcmdldCBlbGVtZW50XHJcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQuanNjb2xvciA9IHRoaXM7XHJcblx0XHRqc2MuYWRkQ2xhc3ModGhpcy50YXJnZXRFbGVtZW50LCBqc2MucHViLmNsYXNzTmFtZSk7XHJcblxyXG5cdFx0Ly8gcmVnaXN0ZXIgdGhpcyBpbnN0YW5jZVxyXG5cdFx0anNjLmluc3RhbmNlcy5wdXNoKHRoaXMpO1xyXG5cclxuXHJcblx0XHQvLyBpZiB0YXJnZXQgaXMgQlVUVE9OXHJcblx0XHRpZiAoanNjLmlzQnV0dG9uKHRoaXMudGFyZ2V0RWxlbWVudCkpIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLnRhcmdldEVsZW1lbnQudHlwZS50b0xvd2VyQ2FzZSgpICE9PSAnYnV0dG9uJykge1xyXG5cdFx0XHRcdC8vIG9uIGJ1dHRvbnMsIGFsd2F5cyBmb3JjZSB0eXBlIHRvIGJlICdidXR0b24nLCBlLmcuIGluIHNpdHVhdGlvbnMgdGhlIHRhcmdldCA8YnV0dG9uPiBoYXMgbm8gdHlwZVxyXG5cdFx0XHRcdC8vIGFuZCB0aHVzIGRlZmF1bHRzIHRvICdzdWJtaXQnIGFuZCB3b3VsZCBzdWJtaXQgdGhlIGZvcm0gd2hlbiBjbGlja2VkXHJcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50LnR5cGUgPSAnYnV0dG9uJztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGpzYy5pc0J1dHRvbkVtcHR5KHRoaXMudGFyZ2V0RWxlbWVudCkpIHsgLy8gZW1wdHkgYnV0dG9uXHJcblx0XHRcdFx0Ly8gaXQgaXMgaW1wb3J0YW50IHRvIGNsZWFyIGVsZW1lbnQncyBjb250ZW50cyBmaXJzdC5cclxuXHRcdFx0XHQvLyBpZiB3ZSdyZSByZS1pbnN0YW50aWF0aW5nIGNvbG9yIHBpY2tlcnMgb24gRE9NIHRoYXQgaGFzIGJlZW4gbW9kaWZpZWQgYnkgY2hhbmdpbmcgcGFnZSdzIGlubmVySFRNTCxcclxuXHRcdFx0XHQvLyB3ZSB3b3VsZCBrZWVwIGFkZGluZyBtb3JlIG5vbi1icmVha2luZyBzcGFjZXMgdG8gZWxlbWVudCdzIGNvbnRlbnQgKGJlY2F1c2UgZWxlbWVudCdzIGNvbnRlbnRzIHN1cnZpdmVcclxuXHRcdFx0XHQvLyBpbm5lckhUTUwgY2hhbmdlcywgYnV0IHBpY2tlciBpbnN0YW5jZXMgZG9uJ3QpXHJcblx0XHRcdFx0anNjLnJlbW92ZUNoaWxkcmVuKHRoaXMudGFyZ2V0RWxlbWVudCk7XHJcblxyXG5cdFx0XHRcdC8vIGxldCdzIGluc2VydCBhIG5vbi1icmVha2luZyBzcGFjZVxyXG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx4YTAnKSk7XHJcblxyXG5cdFx0XHRcdC8vIHNldCBtaW4td2lkdGggPSBwcmV2aWV3U2l6ZSwgaWYgbm90IGFscmVhZHkgZ3JlYXRlclxyXG5cdFx0XHRcdHZhciBjb21wU3R5bGUgPSBqc2MuZ2V0Q29tcFN0eWxlKHRoaXMudGFyZ2V0RWxlbWVudCk7XHJcblx0XHRcdFx0dmFyIGN1cnJNaW5XaWR0aCA9IHBhcnNlRmxvYXQoY29tcFN0eWxlWydtaW4td2lkdGgnXSkgfHwgMDtcclxuXHRcdFx0XHRpZiAoY3Vyck1pbldpZHRoIDwgdGhpcy5wcmV2aWV3U2l6ZSkge1xyXG5cdFx0XHRcdFx0anNjLnNldFN0eWxlKHRoaXMudGFyZ2V0RWxlbWVudCwge1xyXG5cdFx0XHRcdFx0XHQnbWluLXdpZHRoJzogdGhpcy5wcmV2aWV3U2l6ZSArICdweCcsXHJcblx0XHRcdFx0XHR9LCB0aGlzLmZvcmNlU3R5bGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERldGVybWluZSB0aGUgdmFsdWUgZWxlbWVudFxyXG5cdFx0aWYgKHRoaXMudmFsdWVFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYgKGpzYy5pc1RleHRJbnB1dCh0aGlzLnRhcmdldEVsZW1lbnQpKSB7XHJcblx0XHRcdFx0Ly8gZm9yIHRleHQgaW5wdXRzLCBkZWZhdWx0IHZhbHVlRWxlbWVudCBpcyB0YXJnZXRFbGVtZW50XHJcblx0XHRcdFx0dGhpcy52YWx1ZUVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gbGVhdmUgaXQgdW5kZWZpbmVkXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKHRoaXMudmFsdWVFbGVtZW50ID09PSBudWxsKSB7IC8vIGV4cGxpY2l0bHkgc2V0IHRvIG51bGxcclxuXHRcdFx0Ly8gbGVhdmUgaXQgbnVsbFxyXG5cclxuXHRcdH0gZWxzZSB7IC8vIGV4cGxpY2l0bHkgc2V0IHRvIGN1c3RvbSBlbGVtZW50XHJcblx0XHRcdHRoaXMudmFsdWVFbGVtZW50ID0ganNjLm5vZGUodGhpcy52YWx1ZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERldGVybWluZSB0aGUgYWxwaGEgZWxlbWVudFxyXG5cdFx0aWYgKHRoaXMuYWxwaGFFbGVtZW50KSB7XHJcblx0XHRcdHRoaXMuYWxwaGFFbGVtZW50ID0ganNjLm5vZGUodGhpcy5hbHBoYUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERldGVybWluZSB0aGUgcHJldmlldyBlbGVtZW50XHJcblx0XHRpZiAodGhpcy5wcmV2aWV3RWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMucHJldmlld0VsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7IC8vIGRlZmF1bHQgcHJldmlld0VsZW1lbnQgaXMgdGFyZ2V0RWxlbWVudFxyXG5cclxuXHRcdH0gZWxzZSBpZiAodGhpcy5wcmV2aWV3RWxlbWVudCA9PT0gbnVsbCkgeyAvLyBleHBsaWNpdGx5IHNldCB0byBudWxsXHJcblx0XHRcdC8vIGxlYXZlIGl0IG51bGxcclxuXHJcblx0XHR9IGVsc2UgeyAvLyBleHBsaWNpdGx5IHNldCB0byBjdXN0b20gZWxlbWVudFxyXG5cdFx0XHR0aGlzLnByZXZpZXdFbGVtZW50ID0ganNjLm5vZGUodGhpcy5wcmV2aWV3RWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdmFsdWVFbGVtZW50XHJcblx0XHRpZiAodGhpcy52YWx1ZUVsZW1lbnQgJiYganNjLmlzVGV4dElucHV0KHRoaXMudmFsdWVFbGVtZW50KSkge1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIHZhbHVlIGVsZW1lbnQgaGFzIG9uSW5wdXQgZXZlbnQgYWxyZWFkeSBzZXQsIHdlIG5lZWQgdG8gZGV0YWNoIGl0IGFuZCBhdHRhY2ggQUZURVIgb3VyIGxpc3RlbmVyLlxyXG5cdFx0XHQvLyBvdGhlcndpc2UgdGhlIHBpY2tlciBpbnN0YW5jZSB3b3VsZCBzdGlsbCBjb250YWluIHRoZSBvbGQgY29sb3Igd2hlbiBhY2Nlc3NlZCBmcm9tIHRoZSBvbklucHV0IGhhbmRsZXIuXHJcblx0XHRcdHZhciB2YWx1ZUVsZW1lbnRPcmlnRXZlbnRzID0ge1xyXG5cdFx0XHRcdG9uSW5wdXQ6IHRoaXMudmFsdWVFbGVtZW50Lm9uaW5wdXRcclxuXHRcdFx0fTtcclxuXHRcdFx0dGhpcy52YWx1ZUVsZW1lbnQub25pbnB1dCA9IG51bGw7XHJcblxyXG5cdFx0XHR0aGlzLnZhbHVlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25WYWx1ZUtleURvd24sIGZhbHNlKTtcclxuXHRcdFx0dGhpcy52YWx1ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25WYWx1ZUNoYW5nZSwgZmFsc2UpO1xyXG5cdFx0XHR0aGlzLnZhbHVlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIG9uVmFsdWVJbnB1dCwgZmFsc2UpO1xyXG5cdFx0XHQvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbGlzdGVuZXIgbXVzdCBiZSBhdHRhY2hlZCBBRlRFUiBvdXIgaGFuZGxlciAodG8gbGV0IGl0IGZpcnN0IHNldCBwaWNrZXIncyBjb2xvcilcclxuXHRcdFx0aWYgKHZhbHVlRWxlbWVudE9yaWdFdmVudHMub25JbnB1dCkge1xyXG5cdFx0XHRcdHRoaXMudmFsdWVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdmFsdWVFbGVtZW50T3JpZ0V2ZW50cy5vbklucHV0LCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudmFsdWVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJywgJ29mZicpO1xyXG5cdFx0XHR0aGlzLnZhbHVlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xyXG5cdFx0XHR0aGlzLnZhbHVlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xyXG5cdFx0XHR0aGlzLnZhbHVlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWxwaGFFbGVtZW50XHJcblx0XHRpZiAodGhpcy5hbHBoYUVsZW1lbnQgJiYganNjLmlzVGV4dElucHV0KHRoaXMuYWxwaGFFbGVtZW50KSkge1xyXG5cdFx0XHR0aGlzLmFscGhhRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25BbHBoYUtleURvd24sIGZhbHNlKTtcclxuXHRcdFx0dGhpcy5hbHBoYUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25BbHBoYUNoYW5nZSwgZmFsc2UpO1xyXG5cdFx0XHR0aGlzLmFscGhhRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIG9uQWxwaGFJbnB1dCwgZmFsc2UpO1xyXG5cclxuXHRcdFx0dGhpcy5hbHBoYUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XHJcblx0XHRcdHRoaXMuYWxwaGFFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b2NvcnJlY3QnLCAnb2ZmJyk7XHJcblx0XHRcdHRoaXMuYWxwaGFFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XHJcblx0XHRcdHRoaXMuYWxwaGFFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgaW5pdGlhbCBjb2xvciB2YWx1ZVxyXG5cdFx0Ly9cclxuXHRcdHZhciBpbml0VmFsdWUgPSAnRkZGRkZGJztcclxuXHJcblx0XHRpZiAodGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGluaXRWYWx1ZSA9IHRoaXMudmFsdWU7IC8vIGdldCBpbml0aWFsIGNvbG9yIGZyb20gdGhlICd2YWx1ZScgcHJvcGVydHlcclxuXHRcdH0gZWxzZSBpZiAodGhpcy52YWx1ZUVsZW1lbnQgJiYgdGhpcy52YWx1ZUVsZW1lbnQudmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpbml0VmFsdWUgPSB0aGlzLnZhbHVlRWxlbWVudC52YWx1ZTsgLy8gZ2V0IGluaXRpYWwgY29sb3IgZnJvbSB2YWx1ZUVsZW1lbnQncyB2YWx1ZVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRldGVybWluZSBpbml0aWFsIGFscGhhIHZhbHVlXHJcblx0XHQvL1xyXG5cdFx0dmFyIGluaXRBbHBoYSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAodGhpcy5hbHBoYSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGluaXRBbHBoYSA9ICgnJyt0aGlzLmFscGhhKTsgLy8gZ2V0IGluaXRpYWwgYWxwaGEgdmFsdWUgZnJvbSB0aGUgJ2FscGhhJyBwcm9wZXJ0eVxyXG5cdFx0fSBlbHNlIGlmICh0aGlzLmFscGhhRWxlbWVudCAmJiB0aGlzLmFscGhhRWxlbWVudC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGluaXRBbHBoYSA9IHRoaXMuYWxwaGFFbGVtZW50LnZhbHVlOyAvLyBnZXQgaW5pdGlhbCBjb2xvciBmcm9tIGFscGhhRWxlbWVudCdzIHZhbHVlXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGV0ZXJtaW5lIGN1cnJlbnQgZm9ybWF0IGJhc2VkIG9uIHRoZSBpbml0aWFsIGNvbG9yIHZhbHVlXHJcblx0XHQvL1xyXG5cdFx0dGhpcy5fY3VycmVudEZvcm1hdCA9IG51bGw7XHJcblxyXG5cdFx0aWYgKFsnYXV0bycsICdhbnknXS5pbmRleE9mKHRoaXMuZm9ybWF0LnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcclxuXHRcdFx0Ly8gZm9ybWF0IGlzICdhdXRvJyBvciAnYW55JyAtPiBsZXQncyBhdXRvLWRldGVjdCBjdXJyZW50IGZvcm1hdFxyXG5cdFx0XHR2YXIgY29sb3IgPSBqc2MucGFyc2VDb2xvclN0cmluZyhpbml0VmFsdWUpO1xyXG5cdFx0XHR0aGlzLl9jdXJyZW50Rm9ybWF0ID0gY29sb3IgPyBjb2xvci5mb3JtYXQgOiAnaGV4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGZvcm1hdCBpcyBzcGVjaWZpZWRcclxuXHRcdFx0dGhpcy5fY3VycmVudEZvcm1hdCA9IHRoaXMuZm9ybWF0LnRvTG93ZXJDYXNlKCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIGxldCdzIHBhcnNlIHRoZSBpbml0aWFsIGNvbG9yIHZhbHVlIGFuZCBleHBvc2UgY29sb3IncyBwcmV2aWV3XHJcblx0XHR0aGlzLnByb2Nlc3NWYWx1ZUlucHV0KGluaXRWYWx1ZSk7XHJcblxyXG5cdFx0Ly8gbGV0J3MgYWxzbyBwYXJzZSBhbmQgZXhwb3NlIHRoZSBpbml0aWFsIGFscGhhIHZhbHVlLCBpZiBhbnlcclxuXHRcdC8vXHJcblx0XHQvLyBOb3RlOiBJZiB0aGUgaW5pdGlhbCBjb2xvciB2YWx1ZSBjb250YWlucyBhbHBoYSB2YWx1ZSBpbiBpdCAoZS5nLiBpbiByZ2JhIGZvcm1hdCksXHJcblx0XHQvLyB0aGlzIHdpbGwgb3ZlcndyaXRlIGl0LiBTbyB3ZSBzaG91bGQgb25seSBwcm9jZXNzIGFscGhhIGlucHV0IGlmIHRoZXJlIHdhcyBhbnkgaW5pdGlhbFxyXG5cdFx0Ly8gYWxwaGEgZXhwbGljaXRseSBzZXQsIG90aGVyd2lzZSB3ZSBjb3VsZCBuZWVkbGVzc2x5IGxvc2UgaW5pdGlhbCB2YWx1ZSdzIGFscGhhXHJcblx0XHRpZiAoaW5pdEFscGhhICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5wcm9jZXNzQWxwaGFJbnB1dChpbml0QWxwaGEpO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUHVibGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHNcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLy9cclxuLy8gVGhlc2Ugd2lsbCBiZSBwdWJsaWNseSBhdmFpbGFibGUgdmlhIGpzY29sb3IuPG5hbWU+IGFuZCBKU0NvbG9yLjxuYW1lPlxyXG4vL1xyXG5cclxuXHJcbi8vIGNsYXNzIHRoYXQgd2lsbCBiZSBzZXQgdG8gZWxlbWVudHMgaGF2aW5nIGpzY29sb3IgaW5zdGFsbGVkIG9uIHRoZW1cclxuanNjLnB1Yi5jbGFzc05hbWUgPSAnanNjb2xvcic7XHJcblxyXG5cclxuLy8gY2xhc3MgdGhhdCB3aWxsIGJlIHNldCB0byBlbGVtZW50cyBoYXZpbmcganNjb2xvciBhY3RpdmUgb24gdGhlbVxyXG5qc2MucHViLmFjdGl2ZUNsYXNzTmFtZSA9ICdqc2NvbG9yLWFjdGl2ZSc7XHJcblxyXG5cclxuLy8gd2hldGhlciB0byB0cnkgdG8gcGFyc2UgdGhlIG9wdGlvbnMgc3RyaW5nIGJ5IGV2YWx1YXRpbmcgaXQgdXNpbmcgJ25ldyBGdW5jdGlvbigpJ1xyXG4vLyBpbiBjYXNlIGl0IGNvdWxkIG5vdCBiZSBwYXJzZWQgd2l0aCBKU09OLnBhcnNlKClcclxuanNjLnB1Yi5sb29zZUpTT04gPSB0cnVlO1xyXG5cclxuXHJcbi8vIHByZXNldHNcclxuanNjLnB1Yi5wcmVzZXRzID0ge307XHJcblxyXG4vLyBidWlsdC1pbiBwcmVzZXRzXHJcbmpzYy5wdWIucHJlc2V0c1snZGVmYXVsdCddID0ge307IC8vIGJhc2VsaW5lIGZvciBjdXN0b21pemF0aW9uXHJcblxyXG5qc2MucHViLnByZXNldHNbJ2xpZ2h0J10gPSB7IC8vIGRlZmF1bHQgY29sb3Igc2NoZW1lXHJcblx0YmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwxKScsXHJcblx0Y29udHJvbEJvcmRlckNvbG9yOiAncmdiYSgxODcsMTg3LDE4NywxKScsXHJcblx0YnV0dG9uQ29sb3I6ICdyZ2JhKDAsMCwwLDEpJyxcclxufTtcclxuanNjLnB1Yi5wcmVzZXRzWydkYXJrJ10gPSB7XHJcblx0YmFja2dyb3VuZENvbG9yOiAncmdiYSg1MSw1MSw1MSwxKScsXHJcblx0Y29udHJvbEJvcmRlckNvbG9yOiAncmdiYSgxNTMsMTUzLDE1MywxKScsXHJcblx0YnV0dG9uQ29sb3I6ICdyZ2JhKDI0MCwyNDAsMjQwLDEpJyxcclxufTtcclxuXHJcbmpzYy5wdWIucHJlc2V0c1snc21hbGwnXSA9IHsgd2lkdGg6MTAxLCBoZWlnaHQ6MTAxLCBwYWRkaW5nOjEwLCBzbGlkZXJTaXplOjE0IH07XHJcbmpzYy5wdWIucHJlc2V0c1snbWVkaXVtJ10gPSB7IHdpZHRoOjE4MSwgaGVpZ2h0OjEwMSwgcGFkZGluZzoxMiwgc2xpZGVyU2l6ZToxNiB9OyAvLyBkZWZhdWx0IHNpemVcclxuanNjLnB1Yi5wcmVzZXRzWydsYXJnZSddID0geyB3aWR0aDoyNzEsIGhlaWdodDoxNTEsIHBhZGRpbmc6MTIsIHNsaWRlclNpemU6MjQgfTtcclxuXHJcbmpzYy5wdWIucHJlc2V0c1sndGhpbiddID0geyBib3JkZXJXaWR0aDoxLCBjb250cm9sQm9yZGVyV2lkdGg6MSwgcG9pbnRlckJvcmRlcldpZHRoOjEgfTsgLy8gZGVmYXVsdCB0aGlja25lc3NcclxuanNjLnB1Yi5wcmVzZXRzWyd0aGljayddID0geyBib3JkZXJXaWR0aDoyLCBjb250cm9sQm9yZGVyV2lkdGg6MiwgcG9pbnRlckJvcmRlcldpZHRoOjIgfTtcclxuXHJcblxyXG4vLyBzaXplIG9mIHNwYWNlIGluIHRoZSBzbGlkZXJzXHJcbmpzYy5wdWIuc2xpZGVySW5uZXJTcGFjZSA9IDM7IC8vIHB4XHJcblxyXG4vLyB0cmFuc3BhcmVuY3kgY2hlc3Nib2FyZFxyXG5qc2MucHViLmNoZXNzYm9hcmRTaXplID0gODsgLy8gcHhcclxuanNjLnB1Yi5jaGVzc2JvYXJkQ29sb3IxID0gJyM2NjY2NjYnO1xyXG5qc2MucHViLmNoZXNzYm9hcmRDb2xvcjIgPSAnIzk5OTk5OSc7XHJcblxyXG4vLyBwcmV2aWV3IHNlcGFyYXRvclxyXG5qc2MucHViLnByZXZpZXdTZXBhcmF0b3IgPSBbJ3JnYmEoMjU1LDI1NSwyNTUsLjY1KScsICdyZ2JhKDEyOCwxMjgsMTI4LC42NSknXTtcclxuXHJcblxyXG4vLyBJbnN0YWxscyBqc2NvbG9yIG9uIGN1cnJlbnQgRE9NIHRyZWVcclxuanNjLnB1Yi5pbnN0YWxsID0gZnVuY3Rpb24gKHJvb3ROb2RlKSB7XHJcblx0dmFyIHN1Y2Nlc3MgPSB0cnVlO1xyXG5cclxuXHR0cnkge1xyXG5cdFx0anNjLmluc3RhbGxCeVNlbGVjdG9yKCdbZGF0YS1qc2NvbG9yXScsIHJvb3ROb2RlKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRzdWNjZXNzID0gZmFsc2U7XHJcblx0XHRjb25zb2xlLndhcm4oZSk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIERFUFJFQ0FURUQgaW5zdGFsbGF0aW9uIHVzaW5nIGNsYXNzIG5hbWVcclxuXHRpZiAoanNjLnB1Yi5sb29rdXBDbGFzcykge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0anNjLmluc3RhbGxCeVNlbGVjdG9yKFxyXG5cdFx0XHRcdChcclxuXHRcdFx0XHRcdCdpbnB1dC4nICsganNjLnB1Yi5sb29rdXBDbGFzcyArICcsICcgK1xyXG5cdFx0XHRcdFx0J2J1dHRvbi4nICsganNjLnB1Yi5sb29rdXBDbGFzc1xyXG5cdFx0XHRcdCksXHJcblx0XHRcdFx0cm9vdE5vZGVcclxuXHRcdFx0KTtcclxuXHRcdH0gY2F0Y2ggKGUpIHt9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc3VjY2VzcztcclxufTtcclxuXHJcblxyXG4vLyBUcmlnZ2VycyBnaXZlbiBpbnB1dCBldmVudChzKSAoZS5nLiAnaW5wdXQnIG9yICdjaGFuZ2UnKSBvbiBhbGwgY29sb3IgcGlja2Vycy5cclxuLy9cclxuLy8gSXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIHdpdGggYSBzcGFjZS5cclxuLy8gSWYgY2FsbGVkIGJlZm9yZSBqc2NvbG9yIGlzIGluaXRpYWxpemVkLCB0aGVuIHRoZSBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXHJcbi8vXHJcbmpzYy5wdWIudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudE5hbWVzKSB7XHJcblx0aWYgKGpzYy5pbml0aWFsaXplZCkge1xyXG5cdFx0anNjLnRyaWdnZXJHbG9iYWwoZXZlbnROYW1lcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGpzYy50cmlnZ2VyUXVldWUucHVzaChldmVudE5hbWVzKTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gSGlkZXMgY3VycmVudCBjb2xvciBwaWNrZXIgYm94XHJcbmpzYy5wdWIuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRpZiAoanNjLnBpY2tlciAmJiBqc2MucGlja2VyLm93bmVyKSB7XHJcblx0XHRqc2MucGlja2VyLm93bmVyLmhpZGUoKTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gUmV0dXJucyBhIGRhdGEgVVJMIG9mIGEgZ3JheSBjaGVzc2JvYXJkIGltYWdlIHRoYXQgaW5kaWNhdGVzIHRyYW5zcGFyZW5jeVxyXG5qc2MucHViLmNoZXNzYm9hcmQgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuXHRpZiAoIWNvbG9yKSB7XHJcblx0XHRjb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcclxuXHR9XHJcblx0dmFyIHByZXZpZXcgPSBqc2MuZ2VuQ29sb3JQcmV2aWV3Q2FudmFzKGNvbG9yKTtcclxuXHRyZXR1cm4gcHJldmlldy5jYW52YXMudG9EYXRhVVJMKCk7XHJcbn07XHJcblxyXG5cclxuLy8gUmV0dXJucyBhIGRhdGEgVVJMIG9mIGEgZ3JheSBjaGVzc2JvYXJkIGltYWdlIHRoYXQgaW5kaWNhdGVzIHRyYW5zcGFyZW5jeVxyXG5qc2MucHViLmJhY2tncm91bmQgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuXHR2YXIgYmFja2dyb3VuZHMgPSBbXTtcclxuXHJcblx0Ly8gQ1NTIGdyYWRpZW50IGZvciBiYWNrZ3JvdW5kIGNvbG9yIHByZXZpZXdcclxuXHRiYWNrZ3JvdW5kcy5wdXNoKGpzYy5nZW5Db2xvclByZXZpZXdHcmFkaWVudChjb2xvcikpO1xyXG5cclxuXHQvLyBkYXRhIFVSTCBvZiBnZW5lcmF0ZWQgUE5HIGltYWdlIHdpdGggYSBncmF5IHRyYW5zcGFyZW5jeSBjaGVzc2JvYXJkXHJcblx0dmFyIHByZXZpZXcgPSBqc2MuZ2VuQ29sb3JQcmV2aWV3Q2FudmFzKCk7XHJcblx0YmFja2dyb3VuZHMucHVzaChbXHJcblx0XHQndXJsKFxcJycgKyBwcmV2aWV3LmNhbnZhcy50b0RhdGFVUkwoKSArICdcXCcpJyxcclxuXHRcdCdsZWZ0IHRvcCcsXHJcblx0XHQncmVwZWF0JyxcclxuXHRdLmpvaW4oJyAnKSk7XHJcblxyXG5cdHJldHVybiBiYWNrZ3JvdW5kcy5qb2luKCcsICcpO1xyXG59O1xyXG5cclxuXHJcbi8vXHJcbi8vIERFUFJFQ0FURUQgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xyXG4vL1xyXG5cclxuXHJcbi8vIERFUFJFQ0FURUQuIFVzZSBqc2NvbG9yLnByZXNldHMuZGVmYXVsdCBpbnN0ZWFkLlxyXG4vL1xyXG4vLyBDdXN0b20gZGVmYXVsdCBvcHRpb25zIGZvciBhbGwgY29sb3IgcGlja2VycywgZS5nLiB7IGhhc2g6IHRydWUsIHdpZHRoOiAzMDAgfVxyXG5qc2MucHViLm9wdGlvbnMgPSB7fTtcclxuXHJcblxyXG4vLyBERVBSRUNBVEVELiBVc2UgZGF0YS1qc2NvbG9yIGF0dHJpYnV0ZSBpbnN0ZWFkLCB3aGljaCBpbnN0YWxscyBqc2NvbG9yIG9uIGdpdmVuIGVsZW1lbnQuXHJcbi8vXHJcbi8vIEJ5IGRlZmF1bHQsIHdlJ2xsIHNlYXJjaCBmb3IgYWxsIGVsZW1lbnRzIHdpdGggY2xhc3M9XCJqc2NvbG9yXCIgYW5kIGluc3RhbGwgYSBjb2xvciBwaWNrZXIgb24gdGhlbS5cclxuLy9cclxuLy8gWW91IGNhbiBjaGFuZ2Ugd2hhdCBjbGFzcyBuYW1lIHdpbGwgYmUgbG9va2VkIGZvciBieSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBqc2NvbG9yLmxvb2t1cENsYXNzXHJcbi8vIGFueXdoZXJlIGluIHlvdXIgSFRNTCBkb2N1bWVudC4gVG8gY29tcGxldGVseSBkaXNhYmxlIHRoZSBhdXRvbWF0aWMgbG9va3VwLCBzZXQgaXQgdG8gbnVsbC5cclxuLy9cclxuanNjLnB1Yi5sb29rdXBDbGFzcyA9ICdqc2NvbG9yJztcclxuXHJcblxyXG4vLyBERVBSRUNBVEVELiBVc2UganNjb2xvci5pbnN0YWxsKCkgaW5zdGVhZFxyXG4vL1xyXG5qc2MucHViLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0Y29uc29sZS53YXJuKCdqc2NvbG9yLmluaXQoKSBpcyBERVBSRUNBVEVELiBVc2luZyBqc2NvbG9yLmluc3RhbGwoKSBpbnN0ZWFkLicgKyBqc2MuZG9jc1JlZik7XHJcblx0cmV0dXJuIGpzYy5wdWIuaW5zdGFsbCgpO1xyXG59O1xyXG5cclxuXHJcbi8vIERFUFJFQ0FURUQuIFVzZSBkYXRhLWpzY29sb3IgYXR0cmlidXRlIGluc3RlYWQsIHdoaWNoIGluc3RhbGxzIGpzY29sb3Igb24gZ2l2ZW4gZWxlbWVudC5cclxuLy9cclxuLy8gSW5zdGFsbCBqc2NvbG9yIG9uIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHNwZWNpZmllZCBjbGFzcyBuYW1lXHJcbmpzYy5wdWIuaW5zdGFsbEJ5Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdGNvbnNvbGUuZXJyb3IoJ2pzY29sb3IuaW5zdGFsbEJ5Q2xhc3NOYW1lKCkgaXMgREVQUkVDQVRFRC4gVXNlIGRhdGEtanNjb2xvcj1cIlwiIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIGEgY2xhc3MgbmFtZS4nICsganNjLmRvY3NSZWYpO1xyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcblxyXG5qc2MucmVnaXN0ZXIoKTtcclxuXHJcblxyXG5yZXR1cm4ganNjLnB1YjtcclxuXHJcblxyXG59KSgpOyAvLyBFTkQgd2luZG93LmpzY29sb3JcclxuXHJcbndpbmRvdy5KU0NvbG9yID0gd2luZG93LmpzY29sb3I7IC8vICdKU0NvbG9yJyBpcyBhbiBhbGlhcyB0byAnanNjb2xvcidcclxuXHJcbn0gLy8gZW5kaWZcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7QUFhQTtBQUNBOzs7QUFFQTtBQUVBO0FBQUE7QUFFQTtBQUdBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBUEE7QUFTQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFDQTtBQWdCQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFSQTtBQVdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFZQTtBQUVBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBSUE7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBdEJBO0FBQ0E7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUF4NUZBO0FBODVGQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/jscolor.js\n");

/***/ }),

/***/ "./node_modules/lodash.throttle/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.throttle/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLnRocm90dGxlL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qcz84NGEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.throttle/index.js\n");

/***/ }),

/***/ "./node_modules/nprogress/nprogress.js":
/*!*********************************************!*\
  !*** ./node_modules/nprogress/nprogress.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n * @license MIT */\n\n;(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})(this, function() {\n  var NProgress = {};\n\n  NProgress.version = '0.2.0';\n\n  var Settings = NProgress.settings = {\n    minimum: 0.08,\n    easing: 'ease',\n    positionUsing: '',\n    speed: 200,\n    trickle: true,\n    trickleRate: 0.02,\n    trickleSpeed: 800,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: 'body',\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n  };\n\n  /**\n   * Updates configuration.\n   *\n   *     NProgress.configure({\n   *       minimum: 0.1\n   *     });\n   */\n  NProgress.configure = function(options) {\n    var key, value;\n    for (key in options) {\n      value = options[key];\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n    }\n\n    return this;\n  };\n\n  /**\n   * Last number.\n   */\n\n  NProgress.status = null;\n\n  /**\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n   *\n   *     NProgress.set(0.4);\n   *     NProgress.set(1.0);\n   */\n\n  NProgress.set = function(n) {\n    var started = NProgress.isStarted();\n\n    n = clamp(n, Settings.minimum, 1);\n    NProgress.status = (n === 1 ? null : n);\n\n    var progress = NProgress.render(!started),\n        bar      = progress.querySelector(Settings.barSelector),\n        speed    = Settings.speed,\n        ease     = Settings.easing;\n\n    progress.offsetWidth; /* Repaint */\n\n    queue(function(next) {\n      // Set positionUsing if it hasn't already been set\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\n      // Add transition\n      css(bar, barPositionCSS(n, speed, ease));\n\n      if (n === 1) {\n        // Fade out\n        css(progress, { \n          transition: 'none', \n          opacity: 1 \n        });\n        progress.offsetWidth; /* Repaint */\n\n        setTimeout(function() {\n          css(progress, { \n            transition: 'all ' + speed + 'ms linear', \n            opacity: 0 \n          });\n          setTimeout(function() {\n            NProgress.remove();\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n\n    return this;\n  };\n\n  NProgress.isStarted = function() {\n    return typeof NProgress.status === 'number';\n  };\n\n  /**\n   * Shows the progress bar.\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n   *\n   *     NProgress.start();\n   *\n   */\n  NProgress.start = function() {\n    if (!NProgress.status) NProgress.set(0);\n\n    var work = function() {\n      setTimeout(function() {\n        if (!NProgress.status) return;\n        NProgress.trickle();\n        work();\n      }, Settings.trickleSpeed);\n    };\n\n    if (Settings.trickle) work();\n\n    return this;\n  };\n\n  /**\n   * Hides the progress bar.\n   * This is the *sort of* the same as setting the status to 100%, with the\n   * difference being `done()` makes some placebo effect of some realistic motion.\n   *\n   *     NProgress.done();\n   *\n   * If `true` is passed, it will show the progress bar even if its hidden.\n   *\n   *     NProgress.done(true);\n   */\n\n  NProgress.done = function(force) {\n    if (!force && !NProgress.status) return this;\n\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n  };\n\n  /**\n   * Increments by a random amount.\n   */\n\n  NProgress.inc = function(amount) {\n    var n = NProgress.status;\n\n    if (!n) {\n      return NProgress.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n      }\n\n      n = clamp(n + amount, 0, 0.994);\n      return NProgress.set(n);\n    }\n  };\n\n  NProgress.trickle = function() {\n    return NProgress.inc(Math.random() * Settings.trickleRate);\n  };\n\n  /**\n   * Waits for all supplied jQuery promises and\n   * increases the progress as the promises resolve.\n   *\n   * @param $promise jQUery Promise\n   */\n  (function() {\n    var initial = 0, current = 0;\n\n    NProgress.promise = function($promise) {\n      if (!$promise || $promise.state() === \"resolved\") {\n        return this;\n      }\n\n      if (current === 0) {\n        NProgress.start();\n      }\n\n      initial++;\n      current++;\n\n      $promise.always(function() {\n        current--;\n        if (current === 0) {\n            initial = 0;\n            NProgress.done();\n        } else {\n            NProgress.set((initial - current) / initial);\n        }\n      });\n\n      return this;\n    };\n\n  })();\n\n  /**\n   * (Internal) renders the progress bar markup based on the `template`\n   * setting.\n   */\n\n  NProgress.render = function(fromStart) {\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\n    addClass(document.documentElement, 'nprogress-busy');\n    \n    var progress = document.createElement('div');\n    progress.id = 'nprogress';\n    progress.innerHTML = Settings.template;\n\n    var bar      = progress.querySelector(Settings.barSelector),\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n        parent   = document.querySelector(Settings.parent),\n        spinner;\n    \n    css(bar, {\n      transition: 'all 0 linear',\n      transform: 'translate3d(' + perc + '%,0,0)'\n    });\n\n    if (!Settings.showSpinner) {\n      spinner = progress.querySelector(Settings.spinnerSelector);\n      spinner && removeElement(spinner);\n    }\n\n    if (parent != document.body) {\n      addClass(parent, 'nprogress-custom-parent');\n    }\n\n    parent.appendChild(progress);\n    return progress;\n  };\n\n  /**\n   * Removes the element. Opposite of render().\n   */\n\n  NProgress.remove = function() {\n    removeClass(document.documentElement, 'nprogress-busy');\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n    var progress = document.getElementById('nprogress');\n    progress && removeElement(progress);\n  };\n\n  /**\n   * Checks if the progress bar is rendered.\n   */\n\n  NProgress.isRendered = function() {\n    return !!document.getElementById('nprogress');\n  };\n\n  /**\n   * Determine which positioning CSS rule to use.\n   */\n\n  NProgress.getPositioningCSS = function() {\n    // Sniff on document.body.style\n    var bodyStyle = document.body.style;\n\n    // Sniff prefixes\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\n                       ('msTransform' in bodyStyle) ? 'ms' :\n                       ('OTransform' in bodyStyle) ? 'O' : '';\n\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\n      // Modern browsers with 3D support, e.g. Webkit, IE10\n      return 'translate3d';\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n      // Browsers without 3D support, e.g. IE9\n      return 'translate';\n    } else {\n      // Browsers without translate() support, e.g. IE7-8\n      return 'margin';\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  function clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n  }\n\n  /**\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\n   * percentage (`-100%..0%`).\n   */\n\n  function toBarPerc(n) {\n    return (-1 + n) * 100;\n  }\n\n\n  /**\n   * (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings\n   */\n\n  function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n    } else if (Settings.positionUsing === 'translate') {\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n    } else {\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n    }\n\n    barCSS.transition = 'all '+speed+'ms '+ease;\n\n    return barCSS;\n  }\n\n  /**\n   * (Internal) Queues a function to be executed.\n   */\n\n  var queue = (function() {\n    var pending = [];\n    \n    function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }\n    }\n\n    return function(fn) {\n      pending.push(fn);\n      if (pending.length == 1) next();\n    };\n  })();\n\n  /**\n   * (Internal) Applies css properties to an element, similar to the jQuery \n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it \n   * does not perform any manipulation of values prior to setting styles.\n   */\n\n  var css = (function() {\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n        cssProps    = {};\n\n    function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      });\n    }\n\n    function getVendorProp(name) {\n      var style = document.body.style;\n      if (name in style) return name;\n\n      var i = cssPrefixes.length,\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\n          vendorName;\n      while (i--) {\n        vendorName = cssPrefixes[i] + capName;\n        if (vendorName in style) return vendorName;\n      }\n\n      return name;\n    }\n\n    function getStyleProp(name) {\n      name = camelCase(name);\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n    }\n\n    function applyCss(element, prop, value) {\n      prop = getStyleProp(prop);\n      element.style[prop] = value;\n    }\n\n    return function(element, properties) {\n      var args = arguments,\n          prop, \n          value;\n\n      if (args.length == 2) {\n        for (prop in properties) {\n          value = properties[prop];\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n        }\n      } else {\n        applyCss(element, args[1], args[2]);\n      }\n    }\n  })();\n\n  /**\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\n   */\n\n  function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }\n\n  /**\n   * (Internal) Adds a class to an element.\n   */\n\n  function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return; \n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }\n\n  /**\n   * (Internal) Removes a class from an element.\n   */\n\n  function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }\n\n  /**\n   * (Internal) Gets a space separated list of the class names on the element. \n   * The list is wrapped with a single space on each end to facilitate finding \n   * matches within the list.\n   */\n\n  function classList(element) {\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }\n\n  /**\n   * (Internal) Removes an element from the DOM.\n   */\n\n  function removeElement(element) {\n    element && element.parentNode && element.parentNode.removeChild(element);\n  }\n\n  return NProgress;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzL25wcm9ncmVzcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzPzMyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyogTlByb2dyZXNzLCAoYykgMjAxMywgMjAxNCBSaWNvIFN0YS4gQ3J1eiAtIGh0dHA6Ly9yaWNvc3RhY3J1ei5jb20vbnByb2dyZXNzXG4gKiBAbGljZW5zZSBNSVQgKi9cblxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk5Qcm9ncmVzcyA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgdmFyIE5Qcm9ncmVzcyA9IHt9O1xuXG4gIE5Qcm9ncmVzcy52ZXJzaW9uID0gJzAuMi4wJztcblxuICB2YXIgU2V0dGluZ3MgPSBOUHJvZ3Jlc3Muc2V0dGluZ3MgPSB7XG4gICAgbWluaW11bTogMC4wOCxcbiAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICBwb3NpdGlvblVzaW5nOiAnJyxcbiAgICBzcGVlZDogMjAwLFxuICAgIHRyaWNrbGU6IHRydWUsXG4gICAgdHJpY2tsZVJhdGU6IDAuMDIsXG4gICAgdHJpY2tsZVNwZWVkOiA4MDAsXG4gICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgYmFyU2VsZWN0b3I6ICdbcm9sZT1cImJhclwiXScsXG4gICAgc3Bpbm5lclNlbGVjdG9yOiAnW3JvbGU9XCJzcGlubmVyXCJdJyxcbiAgICBwYXJlbnQ6ICdib2R5JyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJiYXJcIiByb2xlPVwiYmFyXCI+PGRpdiBjbGFzcz1cInBlZ1wiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzcGlubmVyXCIgcm9sZT1cInNwaW5uZXJcIj48ZGl2IGNsYXNzPVwic3Bpbm5lci1pY29uXCI+PC9kaXY+PC9kaXY+J1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuY29uZmlndXJlKHtcbiAgICogICAgICAgbWluaW11bTogMC4xXG4gICAqICAgICB9KTtcbiAgICovXG4gIE5Qcm9ncmVzcy5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIFNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGFzdCBudW1iZXIuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zdGF0dXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9ncmVzcyBiYXIgc3RhdHVzLCB3aGVyZSBgbmAgaXMgYSBudW1iZXIgZnJvbSBgMC4wYCB0byBgMS4wYC5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMC40KTtcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMS4wKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLnNldCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgc3RhcnRlZCA9IE5Qcm9ncmVzcy5pc1N0YXJ0ZWQoKTtcblxuICAgIG4gPSBjbGFtcChuLCBTZXR0aW5ncy5taW5pbXVtLCAxKTtcbiAgICBOUHJvZ3Jlc3Muc3RhdHVzID0gKG4gPT09IDEgPyBudWxsIDogbik7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSBOUHJvZ3Jlc3MucmVuZGVyKCFzdGFydGVkKSxcbiAgICAgICAgYmFyICAgICAgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLmJhclNlbGVjdG9yKSxcbiAgICAgICAgc3BlZWQgICAgPSBTZXR0aW5ncy5zcGVlZCxcbiAgICAgICAgZWFzZSAgICAgPSBTZXR0aW5ncy5lYXNpbmc7XG5cbiAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgcXVldWUoZnVuY3Rpb24obmV4dCkge1xuICAgICAgLy8gU2V0IHBvc2l0aW9uVXNpbmcgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzZXRcbiAgICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAnJykgU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9IE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUygpO1xuXG4gICAgICAvLyBBZGQgdHJhbnNpdGlvblxuICAgICAgY3NzKGJhciwgYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpKTtcblxuICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJywgXG4gICAgICAgICAgb3BhY2l0eTogMSBcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2dyZXNzLm9mZnNldFdpZHRoOyAvKiBSZXBhaW50ICovXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjc3MocHJvZ3Jlc3MsIHsgXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsICcgKyBzcGVlZCArICdtcyBsaW5lYXInLCBcbiAgICAgICAgICAgIG9wYWNpdHk6IDAgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9LCBzcGVlZCk7XG4gICAgICAgIH0sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQobmV4dCwgc3BlZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgTlByb2dyZXNzLmlzU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlb2YgTlByb2dyZXNzLnN0YXR1cyA9PT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDAlLCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGdvIGJhY2t3YXJkcy5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgKlxuICAgKi9cbiAgTlByb2dyZXNzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFOUHJvZ3Jlc3Muc3RhdHVzKSBOUHJvZ3Jlc3Muc2V0KDApO1xuXG4gICAgdmFyIHdvcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBOUHJvZ3Jlc3MudHJpY2tsZSgpO1xuICAgICAgICB3b3JrKCk7XG4gICAgICB9LCBTZXR0aW5ncy50cmlja2xlU3BlZWQpO1xuICAgIH07XG5cbiAgICBpZiAoU2V0dGluZ3MudHJpY2tsZSkgd29yaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlICpzb3J0IG9mKiB0aGUgc2FtZSBhcyBzZXR0aW5nIHRoZSBzdGF0dXMgdG8gMTAwJSwgd2l0aCB0aGVcbiAgICogZGlmZmVyZW5jZSBiZWluZyBgZG9uZSgpYCBtYWtlcyBzb21lIHBsYWNlYm8gZWZmZWN0IG9mIHNvbWUgcmVhbGlzdGljIG1vdGlvbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAqXG4gICAqIElmIGB0cnVlYCBpcyBwYXNzZWQsIGl0IHdpbGwgc2hvdyB0aGUgcHJvZ3Jlc3MgYmFyIGV2ZW4gaWYgaXRzIGhpZGRlbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKHRydWUpO1xuICAgKi9cblxuICBOUHJvZ3Jlc3MuZG9uZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSAmJiAhTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gTlByb2dyZXNzLmluYygwLjMgKyAwLjUgKiBNYXRoLnJhbmRvbSgpKS5zZXQoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgYnkgYSByYW5kb20gYW1vdW50LlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaW5jID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIG4gPSBOUHJvZ3Jlc3Muc3RhdHVzO1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhbW91bnQgPSAoMSAtIG4pICogY2xhbXAoTWF0aC5yYW5kb20oKSAqIG4sIDAuMSwgMC45NSk7XG4gICAgICB9XG5cbiAgICAgIG4gPSBjbGFtcChuICsgYW1vdW50LCAwLCAwLjk5NCk7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnNldChuKTtcbiAgICB9XG4gIH07XG5cbiAgTlByb2dyZXNzLnRyaWNrbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTlByb2dyZXNzLmluYyhNYXRoLnJhbmRvbSgpICogU2V0dGluZ3MudHJpY2tsZVJhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYWxsIHN1cHBsaWVkIGpRdWVyeSBwcm9taXNlcyBhbmRcbiAgICogaW5jcmVhc2VzIHRoZSBwcm9ncmVzcyBhcyB0aGUgcHJvbWlzZXMgcmVzb2x2ZS5cbiAgICpcbiAgICogQHBhcmFtICRwcm9taXNlIGpRVWVyeSBQcm9taXNlXG4gICAqL1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluaXRpYWwgPSAwLCBjdXJyZW50ID0gMDtcblxuICAgIE5Qcm9ncmVzcy5wcm9taXNlID0gZnVuY3Rpb24oJHByb21pc2UpIHtcbiAgICAgIGlmICghJHByb21pc2UgfHwgJHByb21pc2Uuc3RhdGUoKSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbCsrO1xuICAgICAgY3VycmVudCsrO1xuXG4gICAgICAkcHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnQtLTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSAwO1xuICAgICAgICAgICAgTlByb2dyZXNzLmRvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5zZXQoKGluaXRpYWwgLSBjdXJyZW50KSAvIGluaXRpYWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJlbmRlcnMgdGhlIHByb2dyZXNzIGJhciBtYXJrdXAgYmFzZWQgb24gdGhlIGB0ZW1wbGF0ZWBcbiAgICogc2V0dGluZy5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbmRlciA9IGZ1bmN0aW9uKGZyb21TdGFydCkge1xuICAgIGlmIChOUHJvZ3Jlc3MuaXNSZW5kZXJlZCgpKSByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICBcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcm9ncmVzcy5pZCA9ICducHJvZ3Jlc3MnO1xuICAgIHByb2dyZXNzLmlubmVySFRNTCA9IFNldHRpbmdzLnRlbXBsYXRlO1xuXG4gICAgdmFyIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHBlcmMgICAgID0gZnJvbVN0YXJ0ID8gJy0xMDAnIDogdG9CYXJQZXJjKE5Qcm9ncmVzcy5zdGF0dXMgfHwgMCksXG4gICAgICAgIHBhcmVudCAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLFxuICAgICAgICBzcGlubmVyO1xuICAgIFxuICAgIGNzcyhiYXIsIHtcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMCBsaW5lYXInLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIHBlcmMgKyAnJSwwLDApJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFTZXR0aW5ncy5zaG93U3Bpbm5lcikge1xuICAgICAgc3Bpbm5lciA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3Muc3Bpbm5lclNlbGVjdG9yKTtcbiAgICAgIHNwaW5uZXIgJiYgcmVtb3ZlRWxlbWVudChzcGlubmVyKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICE9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGFkZENsYXNzKHBhcmVudCwgJ25wcm9ncmVzcy1jdXN0b20tcGFyZW50Jyk7XG4gICAgfVxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQuIE9wcG9zaXRlIG9mIHJlbmRlcigpLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnBhcmVudCksICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIHZhciBwcm9ncmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgICBwcm9ncmVzcyAmJiByZW1vdmVFbGVtZW50KHByb2dyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm9ncmVzcyBiYXIgaXMgcmVuZGVyZWQuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5pc1JlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggcG9zaXRpb25pbmcgQ1NTIHJ1bGUgdG8gdXNlLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTbmlmZiBvbiBkb2N1bWVudC5ib2R5LnN0eWxlXG4gICAgdmFyIGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICAvLyBTbmlmZiBwcmVmaXhlc1xuICAgIHZhciB2ZW5kb3JQcmVmaXggPSAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdXZWJraXQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdNb3pUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnTW96JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnbXNUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnbXMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdPVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ08nIDogJyc7XG5cbiAgICBpZiAodmVuZG9yUHJlZml4ICsgJ1BlcnNwZWN0aXZlJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VycyB3aXRoIDNEIHN1cHBvcnQsIGUuZy4gV2Via2l0LCBJRTEwXG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkJztcbiAgICB9IGVsc2UgaWYgKHZlbmRvclByZWZpeCArICdUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCAzRCBzdXBwb3J0LCBlLmcuIElFOVxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VycyB3aXRob3V0IHRyYW5zbGF0ZSgpIHN1cHBvcnQsIGUuZy4gSUU3LThcbiAgICAgIHJldHVybiAnbWFyZ2luJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICBpZiAobiA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICBpZiAobiA+IG1heCkgcmV0dXJuIG1heDtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIGNvbnZlcnRzIGEgcGVyY2VudGFnZSAoYDAuLjFgKSB0byBhIGJhciB0cmFuc2xhdGVYXG4gICAqIHBlcmNlbnRhZ2UgKGAtMTAwJS4uMCVgKS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9CYXJQZXJjKG4pIHtcbiAgICByZXR1cm4gKC0xICsgbikgKiAxMDA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJldHVybnMgdGhlIGNvcnJlY3QgQ1NTIGZvciBjaGFuZ2luZyB0aGUgYmFyJ3NcbiAgICogcG9zaXRpb24gZ2l2ZW4gYW4gbiBwZXJjZW50YWdlLCBhbmQgc3BlZWQgYW5kIGVhc2UgZnJvbSBTZXR0aW5nc1xuICAgKi9cblxuICBmdW5jdGlvbiBiYXJQb3NpdGlvbkNTUyhuLCBzcGVlZCwgZWFzZSkge1xuICAgIHZhciBiYXJDU1M7XG5cbiAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZTNkJykge1xuICAgICAgYmFyQ1NTID0geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnK3RvQmFyUGVyYyhuKSsnJSwwLDApJyB9O1xuICAgIH0gZWxzZSBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcrdG9CYXJQZXJjKG4pKyclLDApJyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJDU1MgPSB7ICdtYXJnaW4tbGVmdCc6IHRvQmFyUGVyYyhuKSsnJScgfTtcbiAgICB9XG5cbiAgICBiYXJDU1MudHJhbnNpdGlvbiA9ICdhbGwgJytzcGVlZCsnbXMgJytlYXNlO1xuXG4gICAgcmV0dXJuIGJhckNTUztcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFF1ZXVlcyBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKi9cblxuICB2YXIgcXVldWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgICBcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIGZuID0gcGVuZGluZy5zaGlmdCgpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgcGVuZGluZy5wdXNoKGZuKTtcbiAgICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PSAxKSBuZXh0KCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBBcHBsaWVzIGNzcyBwcm9wZXJ0aWVzIHRvIGFuIGVsZW1lbnQsIHNpbWlsYXIgdG8gdGhlIGpRdWVyeSBcbiAgICogY3NzIG1ldGhvZC5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBoZWxwZXIgZG9lcyBhc3Npc3Qgd2l0aCB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkgbmFtZXMsIGl0IFxuICAgKiBkb2VzIG5vdCBwZXJmb3JtIGFueSBtYW5pcHVsYXRpb24gb2YgdmFsdWVzIHByaW9yIHRvIHNldHRpbmcgc3R5bGVzLlxuICAgKi9cblxuICB2YXIgY3NzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjc3NQcmVmaXhlcyA9IFsgJ1dlYmtpdCcsICdPJywgJ01veicsICdtcycgXSxcbiAgICAgICAgY3NzUHJvcHMgICAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXi1tcy0vLCAnbXMtJykucmVwbGFjZSgvLShbXFxkYS16XSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmVuZG9yUHJvcChuYW1lKSB7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgaWYgKG5hbWUgaW4gc3R5bGUpIHJldHVybiBuYW1lO1xuXG4gICAgICB2YXIgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgICBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgdmVuZG9yTmFtZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmVuZG9yTmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcbiAgICAgICAgaWYgKHZlbmRvck5hbWUgaW4gc3R5bGUpIHJldHVybiB2ZW5kb3JOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdHlsZVByb3AobmFtZSkge1xuICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcbiAgICAgIHJldHVybiBjc3NQcm9wc1tuYW1lXSB8fCAoY3NzUHJvcHNbbmFtZV0gPSBnZXRWZW5kb3JQcm9wKG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJvcCA9IGdldFN0eWxlUHJvcChwcm9wKTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcHJvcCwgXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIGFwcGx5Q3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlDc3MoZWxlbWVudCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lcyBjb250YWlucyBhIGNsYXNzIG5hbWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgbGlzdCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID8gZWxlbWVudCA6IGNsYXNzTGlzdChlbGVtZW50KTtcbiAgICByZXR1cm4gbGlzdC5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpID49IDA7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBBZGRzIGEgY2xhc3MgdG8gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0ID0gb2xkTGlzdCArIG5hbWU7XG5cbiAgICBpZiAoaGFzQ2xhc3Mob2xkTGlzdCwgbmFtZSkpIHJldHVybjsgXG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIHNwYWNlLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIG9sZExpc3QgPSBjbGFzc0xpc3QoZWxlbWVudCksXG4gICAgICAgIG5ld0xpc3Q7XG5cbiAgICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpKSByZXR1cm47XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBjbGFzcyBuYW1lLlxuICAgIG5ld0xpc3QgPSBvbGRMaXN0LnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcblxuICAgIC8vIFRyaW0gdGhlIG9wZW5pbmcgYW5kIGNsb3Npbmcgc3BhY2VzLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSwgbmV3TGlzdC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEdldHMgYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiB0aGUgY2xhc3MgbmFtZXMgb24gdGhlIGVsZW1lbnQuIFxuICAgKiBUaGUgbGlzdCBpcyB3cmFwcGVkIHdpdGggYSBzaW5nbGUgc3BhY2Ugb24gZWFjaCBlbmQgdG8gZmFjaWxpdGF0ZSBmaW5kaW5nIFxuICAgKiBtYXRjaGVzIHdpdGhpbiB0aGUgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhc3NMaXN0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKCcgJyArIChlbGVtZW50LmNsYXNzTmFtZSB8fCAnJykgKyAnICcpLnJlcGxhY2UoL1xccysvZ2ksICcgJyk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gTlByb2dyZXNzO1xufSk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nprogress/nprogress.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./js/app.js */"./js/app.js");


/***/ })

/******/ });